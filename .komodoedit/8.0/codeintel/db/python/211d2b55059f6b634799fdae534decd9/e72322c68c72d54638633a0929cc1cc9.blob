<scope doc="Check Python source code formatting, according to PEP 8:&#xA;http://www.python.org/dev/peps/pep-0008/" ilk="blob" lang="Python" name="pep8" src="/usr/lib/python2.7/dist-packages/pep8.py"><import line="98" module="os" /><import line="99" module="sys" /><import line="100" module="re" /><import line="101" module="time" /><import line="102" module="inspect" /><import line="103" module="keyword" /><import line="104" module="tokenize" /><import line="105" module="optparse" symbol="OptionParser" /><import line="106" module="fnmatch" symbol="fnmatch" /><import alias="set" line="110" module="sets" symbol="Set" /><import alias="frozenset" line="110" module="sets" symbol="ImmutableSet" /><variable citdl="str" line="96" name="__version__" /><variable citdl="str" line="113" name="DEFAULT_EXCLUDE" /><variable citdl="str" line="114" name="DEFAULT_IGNORE" /><variable citdl="int" line="115" name="MAX_LINE_LENGTH" /><variable citdl="re.compile()" line="117" name="INDENT_REGEX" /><variable citdl="re.compile()" line="118" name="RAISE_COMMA_REGEX" /><variable citdl="re.compile()" line="119" name="RERAISE_COMMA_REGEX" /><variable citdl="re.compile()" line="120" name="SELFTEST_REGEX" /><variable citdl="re.compile()" line="121" name="ERRORCODE_REGEX" /><variable citdl="re.compile()" line="122" name="DOCSTRING_REGEX" /><variable citdl="re.compile()" line="123" name="WHITESPACE_AROUND_OPERATOR_REGEX" /><variable citdl="re.compile()" line="125" name="WHITESPACE_AROUND_KEYWORD_REGEX" /><variable citdl="re.compile()" line="127" name="EXTRANEOUS_WHITESPACE_REGEX" /><variable citdl="re.compile()" line="128" name="WHITESPACE_AROUND_NAMED_PARAMETER_REGEX" /><variable citdl="re.compile()" line="130" name="COMPARE_SINGLETON_REGEX" /><variable citdl="re.compile()" line="131" name="COMPARE_TYPE_REGEX" /><variable citdl="re.compile()" line="133" name="LAMBDA_REGEX" /><variable citdl="frozenset()" line="136" name="WHITESPACE" /><variable citdl="frozenset()" line="137" name="BINARY_OPERATORS" /><variable citdl="frozenset()" line="141" name="UNARY_OPERATORS" /><variable citdl="int" line="142" name="OPERATORS" /><variable citdl="frozenset()" line="143" name="SKIP_TOKENS" /><variable citdl="frozenset()" line="145" name="SINGLETONS" /><variable citdl="frozenset()" line="146" name="KEYWORDS" /><variable citdl="tuple" line="147" name="BENCHMARK_KEYS" /><variable line="149" name="options" /><variable line="150" name="args" /><scope doc="Never mix tabs and spaces.&#xA;&#xA;The most popular way of indenting Python is with spaces only.  The&#xA;second-most popular way is with tabs only.  Code indented with a mixture&#xA;of tabs and spaces should be converted to using spaces exclusively.  When&#xA;invoking the Python command line interpreter with the -t option, it issues&#xA;warnings about code that illegally mixes tabs and spaces.  When using -tt&#xA;these warnings become errors.  These options are highly recommended!&#xA;&#xA;Okay: if a == 0:\n        a = 1\n        b = 1&#xA;E101: if a == 0:\n        a = 1\n\tb = 1" ilk="function" line="158" lineend="175" name="tabs_or_spaces" returns="tuple" signature="tabs_or_spaces(physical_line, indent_char)"><variable ilk="argument" name="physical_line" /><variable ilk="argument" name="indent_char" /><variable line="172" name="indent" /></scope><scope doc="For new projects, spaces-only are strongly recommended over tabs.  Most&#xA;editors have features that make this easy to do.&#xA;&#xA;Okay: if True:\n    return&#xA;W191: if True:\n\treturn" ilk="function" line="178" lineend="188" name="tabs_obsolete" returns="tuple" signature="tabs_obsolete(physical_line)"><variable ilk="argument" name="physical_line" /><variable line="186" name="indent" /></scope><scope doc="JCR: Trailing whitespace is superfluous.&#xA;FBM: Except when it occurs as part of a blank line (i.e. the line is&#xA;     nothing but whitespace). According to Python docs[1] a line with only&#xA;     whitespace is considered a blank line, and is to be ignored. However,&#xA;     matching a blank line to its indentation level avoids mistakenly&#xA;     terminating a multi-line statement (e.g. class declaration) when&#xA;     pasting code into the standard Python interpreter.&#xA;&#xA;     [1] http://docs.python.org/reference/lexical_analysis.html#blank-lines&#xA;&#xA;The warning returned varies on whether the line itself is blank, for easier&#xA;filtering for those who want to indent their blank lines.&#xA;&#xA;Okay: spam(1)&#xA;W291: spam(1)\s&#xA;W293: class Foo(object):\n    \n    bang = 12" ilk="function" line="191" lineend="218" name="trailing_whitespace" returns="tuple" signature="trailing_whitespace(physical_line)"><variable citdl="physical_line.rstrip()" ilk="argument" name="physical_line" /><variable citdl="physical_line.rstrip()" line="213" name="stripped" /></scope><scope doc="JCR: Trailing blank lines are superfluous.&#xA;&#xA;Okay: spam(1)&#xA;W391: spam(1)\n" ilk="function" line="221" lineend="229" name="trailing_blank_lines" returns="tuple" signature="trailing_blank_lines(physical_line, lines, line_number)"><variable ilk="argument" name="physical_line" /><variable ilk="argument" name="lines" /><variable ilk="argument" name="line_number" /></scope><scope doc="JCR: The last line should have a newline." ilk="function" line="232" lineend="237" name="missing_newline" returns="tuple" signature="missing_newline(physical_line)"><variable ilk="argument" name="physical_line" /></scope><scope doc="Limit all lines to a maximum of 79 characters.&#xA;&#xA;There are still many devices around that are limited to 80 character&#xA;lines; plus, limiting windows to 80 characters makes it possible to have&#xA;several windows side-by-side.  The default wrapping on such devices looks&#xA;ugly.  Therefore, please limit all lines to a maximum of 79 characters.&#xA;For flowing long blocks of text (docstrings or comments), limiting the&#xA;length to 72 characters is recommended." ilk="function" line="240" lineend="263" name="maximum_line_length" returns="tuple" signature="maximum_line_length(physical_line)"><variable ilk="argument" name="physical_line" /><variable citdl="line.encode()" line="251" name="line" /><variable citdl="len()" line="252" name="length" /></scope><scope doc="Separate top-level function and class definitions with two blank lines.&#xA;&#xA;Method definitions inside a class are separated by a single blank line.&#xA;&#xA;Extra blank lines may be used (sparingly) to separate groups of related&#xA;functions.  Blank lines may be omitted between a bunch of related&#xA;one-liners (e.g. a set of dummy implementations).&#xA;&#xA;Use blank lines in functions, sparingly, to indicate logical sections.&#xA;&#xA;Okay: def a():\n    pass\n\n\ndef b():\n    pass&#xA;Okay: def a():\n    pass\n\n\n# Foo\n# Bar\n\ndef b():\n    pass&#xA;&#xA;E301: class Foo:\n    b = 0\n    def bar():\n        pass&#xA;E302: def a():\n    pass\n\ndef b(n):\n    pass&#xA;E303: def a():\n    pass\n\n\n\ndef b(n):\n    pass&#xA;E303: def a():\n\n\n\n    pass&#xA;E304: @decorator\n\ndef a():\n    pass" ilk="function" line="271" lineend="310" name="blank_lines" signature="blank_lines(logical_line, blank_lines, indent_level, line_number, previous_logical, previous_indent_level, blank_lines_before_comment)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="blank_lines" /><variable ilk="argument" name="indent_level" /><variable ilk="argument" name="line_number" /><variable ilk="argument" name="previous_logical" /><variable ilk="argument" name="previous_indent_level" /><variable ilk="argument" name="blank_lines_before_comment" /><variable citdl="max()" line="296" name="max_blank_lines" /></scope><scope doc="Avoid extraneous whitespace in the following situations:&#xA;&#xA;- Immediately inside parentheses, brackets or braces.&#xA;&#xA;- Immediately before a comma, semicolon, or colon.&#xA;&#xA;Okay: spam(ham[1], {eggs: 2})&#xA;E201: spam( ham[1], {eggs: 2})&#xA;E201: spam(ham[ 1], {eggs: 2})&#xA;E201: spam(ham[1], { eggs: 2})&#xA;E202: spam(ham[1], {eggs: 2} )&#xA;E202: spam(ham[1 ], {eggs: 2})&#xA;E202: spam(ham[1], {eggs: 2 })&#xA;&#xA;E203: if x == 4: print x, y; x, y = y , x&#xA;E203: if x == 4: print x, y ; x, y = y, x&#xA;E203: if x == 4 : print x, y; x, y = y, x" ilk="function" line="313" lineend="344" name="extraneous_whitespace" signature="extraneous_whitespace(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="333" name="line" /><variable citdl="match.group()" line="335" name="text" /><variable citdl="text.strip()" line="336" name="char" /><variable citdl="match.start()" line="337" name="found" /></scope><scope doc="Avoid extraneous whitespace around keywords.&#xA;&#xA;Okay: True and False&#xA;E271: True and  False&#xA;E272: True  and False&#xA;E273: True and\tFalse&#xA;E274: True\tand False" ilk="function" line="347" lineend="366" name="whitespace_around_keywords" signature="whitespace_around_keywords(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="358" name="before" /><variable line="358" name="after" /><variable line="358" name="whitespace" /><variable citdl="bool" line="359" name="tab" /><variable citdl="match.start()" line="360" name="offset" /></scope><scope doc="JCR: Each comma, semicolon or colon should be followed by whitespace.&#xA;&#xA;Okay: [a, b]&#xA;Okay: (3,)&#xA;Okay: a[1:4]&#xA;Okay: a[:4]&#xA;Okay: a[1:]&#xA;Okay: a[1:4:2]&#xA;E231: [&apos;a&apos;,&apos;b&apos;]&#xA;E231: foo(bar,baz)" ilk="function" line="369" lineend="391" name="missing_whitespace" signature="missing_whitespace(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="382" name="line" /><variable line="384" name="char" /><variable citdl="list" line="386" name="before" /></scope><scope doc="Use 4 spaces per indentation level.&#xA;&#xA;For really old code that you don&apos;t want to mess up, you can continue to&#xA;use 8-space tabs.&#xA;&#xA;Okay: a = 1&#xA;Okay: if a == 0:\n    a = 1&#xA;E111:   a = 1&#xA;&#xA;Okay: for item in items:\n    pass&#xA;E112: for item in items:\npass&#xA;&#xA;Okay: a = 1\nb = 2&#xA;E113: a = 1\n    b = 2" ilk="function" line="394" lineend="418" name="indentation" signature="indentation(logical_line, previous_logical, indent_char, indent_level, previous_indent_level)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="previous_logical" /><variable ilk="argument" name="indent_char" /><variable ilk="argument" name="indent_level" /><variable ilk="argument" name="previous_indent_level" /><variable citdl="previous_logical.endswith()" line="414" name="indent_expect" /></scope><scope doc="Continuation lines should align wrapped elements either vertically using&#xA;Python&apos;s implicit line joining inside parentheses, brackets and braces, or&#xA;using a hanging indent.&#xA;&#xA;When using a hanging indent the following considerations should be applied:&#xA;&#xA;- there should be no arguments on the first line, and&#xA;&#xA;- further indentation should be used to clearly distinguish itself as a&#xA;  continuation line.&#xA;&#xA;Okay: a = (\n)&#xA;E123: a = (\n    )&#xA;&#xA;Okay: a = (\n    42)&#xA;E121: a = (\n   42)&#xA;E122: a = (\n42)&#xA;E123: a = (42\n    )&#xA;E124: a = (24,\n     42\n)&#xA;E125: if (a or\n    b):\n    pass&#xA;E126: a = (\n        42)&#xA;E127: a = (24,\n      42)&#xA;E128: a = (24,\n    42)" ilk="function" line="421" lineend="596" name="continuation_line_indentation" signature="continuation_line_indentation(logical_line, tokens, indent_level)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="tokens" /><variable ilk="argument" name="indent_level" /><variable line="447" name="first_row" /><variable citdl="int" line="448" name="nrows" /><variable citdl="logical_line.endswith()" line="456" name="indent_next" /><variable line="458" name="indent_string" /><variable citdl="int" line="459" name="row" /><variable citdl="list" line="461" name="parens" /><variable citdl="list" line="463" name="rel_indent" /><variable citdl="list" line="465" name="indent" /><variable citdl="bool" line="470" name="newline" /><variable citdl="start" line="478" name="last_indent" /><variable citdl="int" line="493" name="open_row" /><variable line="494" name="hang" /><variable citdl="depth" line="497" name="d" /><variable citdl="True" line="500" name="is_visual" /><variable citdl="bool" line="505" name="is_not_hanging" /><variable citdl="bool" line="593" name="last_token_multiline" /></scope><scope doc="Avoid extraneous whitespace in the following situations:&#xA;&#xA;- Immediately before the open parenthesis that starts the argument&#xA;  list of a function call.&#xA;&#xA;- Immediately before the open parenthesis that starts an indexing or&#xA;  slicing.&#xA;&#xA;Okay: spam(1)&#xA;E211: spam (1)&#xA;&#xA;Okay: dict[&apos;key&apos;] = list[index]&#xA;E211: dict [&apos;key&apos;] = list[index]&#xA;E211: dict[&apos;key&apos;] = list [index]" ilk="function" line="600" lineend="633" name="whitespace_before_parameters" signature="whitespace_before_parameters(logical_line, tokens)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="tokens" /><variable citdl="token_type" line="617" name="prev_type" /><variable citdl="text" line="618" name="prev_text" /><variable citdl="end" line="619" name="prev_end" /></scope><scope doc="Avoid extraneous whitespace in the following situations:&#xA;&#xA;- More than one space around an assignment (or other) operator to&#xA;  align it with another.&#xA;&#xA;Okay: a = 12 + 3&#xA;E221: a = 4  + 5&#xA;E222: a = 4 +  5&#xA;E223: a = 4\t+ 5&#xA;E224: a = 4 +\t5" ilk="function" line="636" lineend="658" name="whitespace_around_operator" signature="whitespace_around_operator(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="650" name="before" /><variable line="650" name="after" /><variable line="650" name="whitespace" /><variable citdl="bool" line="651" name="tab" /><variable citdl="match.start()" line="652" name="offset" /></scope><scope doc="- Always surround these binary operators with a single space on&#xA;  either side: assignment (=), augmented assignment (+=, -= etc.),&#xA;  comparisons (==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not),&#xA;  Booleans (and, or, not).&#xA;&#xA;- Use spaces around arithmetic operators.&#xA;&#xA;Okay: i = i + 1&#xA;Okay: submitted += 1&#xA;Okay: x = x * 2 - 1&#xA;Okay: hypot2 = x * x + y * y&#xA;Okay: c = (a + b) * (a - b)&#xA;Okay: foo(bar, key=&apos;word&apos;, *args, **kwargs)&#xA;Okay: baz(**kwargs)&#xA;Okay: negative = -1&#xA;Okay: spam(-1)&#xA;Okay: alpha[:-i]&#xA;Okay: if not -5 &lt; x &lt; +5:\n    pass&#xA;Okay: lambda *args, **kw: (args, kw)&#xA;&#xA;E225: i=i+1&#xA;E225: submitted +=1&#xA;E225: x = x*2 - 1&#xA;E225: hypot2 = x*x + y*y&#xA;E225: c = (a+b) * (a-b)&#xA;E225: c = alpha -4&#xA;E225: z = x **y" ilk="function" line="661" lineend="735" name="missing_whitespace_around_operator" signature="missing_whitespace_around_operator(logical_line, tokens)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="tokens" /><variable citdl="int" line="691" name="parens" /><variable citdl="False" line="692" name="need_space" /><variable citdl="token_type" line="693" name="prev_type" /><variable citdl="text" line="694" name="prev_text" /><variable citdl="end" line="735" name="prev_end" /></scope><scope doc="Avoid extraneous whitespace in the following situations:&#xA;&#xA;- More than one space around an assignment (or other) operator to&#xA;  align it with another.&#xA;&#xA;JCR: This should also be applied around comma etc.&#xA;Note: these checks are disabled by default&#xA;&#xA;Okay: a = (1, 2)&#xA;E241: a = (1,  2)&#xA;E242: a = (1,\t2)" ilk="function" line="738" lineend="759" name="whitespace_around_comma" signature="whitespace_around_comma(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="752" name="line" /><variable citdl="line.find()" line="754" name="found" /></scope><scope doc="Don&apos;t use spaces around the &apos;=&apos; sign when used to indicate a&#xA;keyword argument or a default parameter value.&#xA;&#xA;Okay: def complex(real, imag=0.0):&#xA;Okay: return magic(r=real, i=imag)&#xA;Okay: boolean(a == b)&#xA;Okay: boolean(a != b)&#xA;Okay: boolean(a &lt;= b)&#xA;Okay: boolean(a &gt;= b)&#xA;&#xA;E251: def complex(real, imag = 0.0):&#xA;E251: return magic(r = real, i = imag)" ilk="function" line="762" lineend="787" name="whitespace_around_named_parameter_equals" signature="whitespace_around_named_parameter_equals(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="int" line="777" name="parens" /><variable citdl="match.group()" line="780" name="text" /><variable citdl="str" line="782" name="issue" /></scope><scope doc="Separate inline comments by at least two spaces.&#xA;&#xA;An inline comment is a comment on the same line as a statement.  Inline&#xA;comments should be separated by at least two spaces from the statement.&#xA;They should start with a # and a single space.&#xA;&#xA;Okay: x = x + 1  # Increment x&#xA;Okay: x = x + 1    # Increment x&#xA;E261: x = x + 1 # Increment x&#xA;E262: x = x + 1  #Increment x&#xA;E262: x = x + 1  #  Increment x" ilk="function" line="790" lineend="817" name="whitespace_before_inline_comment" signature="whitespace_before_inline_comment(logical_line, tokens)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="tokens" /><variable citdl="end" line="804" name="prev_end" /></scope><scope doc="Imports should usually be on separate lines.&#xA;&#xA;Okay: import os\nimport sys&#xA;E401: import sys, os&#xA;&#xA;Okay: from subprocess import Popen, PIPE&#xA;Okay: from myclas import MyClass&#xA;Okay: from foo.bar.yourclass import YourClass&#xA;Okay: import myclass&#xA;Okay: import foo.bar.yourclass" ilk="function" line="820" lineend="837" name="imports_on_separate_lines" signature="imports_on_separate_lines(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="833" name="line" /><variable citdl="line.find()" line="835" name="found" /></scope><scope doc="Compound statements (multiple statements on the same line) are&#xA;generally discouraged.&#xA;&#xA;While sometimes it&apos;s okay to put an if/for/while with a small body&#xA;on the same line, never do this for multi-clause statements. Also&#xA;avoid folding such long lines!&#xA;&#xA;Okay: if foo == &apos;blah&apos;:\n    do_blah_thing()&#xA;Okay: do_one()&#xA;Okay: do_two()&#xA;Okay: do_three()&#xA;&#xA;E701: if foo == &apos;blah&apos;: do_blah_thing()&#xA;E701: for x in lst: total += x&#xA;E701: while t &lt; 10: t = delay()&#xA;E701: if foo == &apos;blah&apos;: do_blah_thing()&#xA;E701: else: do_non_blah_thing()&#xA;E701: try: something()&#xA;E701: finally: cleanup()&#xA;E701: if foo == &apos;blah&apos;: one(); two(); three()&#xA;&#xA;E702: do_one(); do_two(); do_three()" ilk="function" line="840" lineend="876" name="compound_statements" signature="compound_statements(logical_line)"><variable ilk="argument" name="logical_line" /><variable line="865" name="line" /><variable citdl="line.find()" line="866" name="found" /><variable citdl="list" line="868" name="before" /></scope><scope doc="Avoid explicit line join between brackets.&#xA;&#xA;The preferred way of wrapping long lines is by using Python&apos;s implied line&#xA;continuation inside parentheses, brackets and braces.  Long lines can be&#xA;broken over multiple lines by wrapping expressions in parentheses.  These&#xA;should be used in preference to using a backslash for line continuation.&#xA;&#xA;E502: aaa = [123, \\n       123]&#xA;E502: aaa = (&quot;bbb &quot; \\n       &quot;ccc&quot;)&#xA;&#xA;Okay: aaa = [123,\n       123]&#xA;Okay: aaa = (&quot;bbb &quot;\n       &quot;ccc&quot;)&#xA;Okay: aaa = &quot;bbb &quot; \\n    &quot;ccc&quot;" ilk="function" line="879" lineend="909" name="explicit_line_join" signature="explicit_line_join(logical_line, tokens)"><variable ilk="argument" name="logical_line" /><variable ilk="argument" name="tokens" /><variable citdl="int" line="895" name="prev_start" /><variable citdl="tuple" line="901" name="backslash" /><variable line="909" name="prev_end" /></scope><scope doc="Comparisons to singletons like None should always be done&#xA;with &quot;is&quot; or &quot;is not&quot;, never the equality operators.&#xA;&#xA;E711: if arg != None:&#xA;Okay: if arg is not None:&#xA;&#xA;Also, beware of writing if x when you really mean if x is not None --&#xA;e.g. when testing whether a variable or argument that defaults to None was&#xA;set to some other value.  The other value might have a type (such as a&#xA;container) that could be false in a boolean context!" ilk="function" line="912" lineend="939" name="comparison_to_singleton" signature="comparison_to_singleton(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="COMPARE_SINGLETON_REGEX.search()" line="925" name="match" /><variable citdl="bool" line="927" name="same" /><variable citdl="match.group()" line="928" name="singleton" /><variable citdl="str" line="930" name="code" /><variable citdl="str" line="931" name="msg" /><variable citdl="bool" line="934" name="nonzero" /></scope><scope doc="Object type comparisons should always use isinstance() instead of&#xA;comparing types directly.&#xA;&#xA;Okay: if isinstance(obj, int):&#xA;E721: if type(obj) is type(1):&#xA;&#xA;When checking if an object is a string, keep in mind that it might be a&#xA;unicode string too! In Python 2.3, str and unicode have a common base&#xA;class, basestring, so you can do:&#xA;&#xA;Okay: if isinstance(obj, basestring):&#xA;Okay: if type(a1) is type(b1):" ilk="function" line="942" lineend="962" name="comparison_type" signature="comparison_type(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="COMPARE_TYPE_REGEX.search()" line="957" name="match" /><variable citdl="match.group()" line="959" name="inst" /></scope><scope doc="The {}.has_key() method will be removed in the future version of&#xA;Python. Use the &apos;in&apos; operation instead, like:&#xA;d = {&quot;a&quot;: 1, &quot;b&quot;: 2}&#xA;if &quot;b&quot; in d:&#xA;    print d[&quot;b&quot;]" ilk="function" line="965" lineend="975" name="python_3000_has_key" signature="python_3000_has_key(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="logical_line.find()" line="973" name="pos" /></scope><scope doc="When raising an exception, use &quot;raise ValueError(&apos;message&apos;)&quot;&#xA;instead of the older form &quot;raise ValueError, &apos;message&apos;&quot;.&#xA;&#xA;The paren-using form is preferred because when the exception arguments&#xA;are long or include string formatting, you don&apos;t need to use line&#xA;continuation characters thanks to the containing parentheses.  The older&#xA;form will be removed in Python 3000." ilk="function" line="978" lineend="990" name="python_3000_raise_comma" signature="python_3000_raise_comma(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="RAISE_COMMA_REGEX.match()" line="988" name="match" /></scope><scope doc="!= can also be written &lt;&gt;, but this is an obsolete usage kept for&#xA;backwards compatibility only. New code should always use !=.&#xA;The older syntax is removed in Python 3000." ilk="function" line="993" lineend="1001" name="python_3000_not_equal" signature="python_3000_not_equal(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="logical_line.find()" line="999" name="pos" /></scope><scope doc="Backticks are removed in Python 3000.&#xA;Use repr() instead." ilk="function" line="1004" lineend="1011" name="python_3000_backticks" signature="python_3000_backticks(logical_line)"><variable ilk="argument" name="logical_line" /><variable citdl="logical_line.find()" line="1009" name="pos" /></scope><scope ilk="function" line="1030" lineend="1031" name="readlines" signature="readlines(filename)"><variable ilk="argument" name="filename" /></scope><scope ilk="function" line="1033" lineend="1034" name="isidentifier" returns="s.isidentifier()" signature="isidentifier(s)"><variable ilk="argument" name="s" /></scope><scope doc="Return the amount of indentation.&#xA;Tabs are expanded to the next multiple of 8.&#xA;&#xA;&gt;&gt;&gt; expand_indent(&apos;    &apos;)&#xA;4&#xA;&gt;&gt;&gt; expand_indent(&apos;\t&apos;)&#xA;8&#xA;&gt;&gt;&gt; expand_indent(&apos;    \t&apos;)&#xA;8&#xA;&gt;&gt;&gt; expand_indent(&apos;       \t&apos;)&#xA;8&#xA;&gt;&gt;&gt; expand_indent(&apos;        \t&apos;)&#xA;16" ilk="function" line="1037" lineend="1061" name="expand_indent" returns="int" signature="expand_indent(line)"><variable ilk="argument" name="line" /><variable citdl="int" line="1053" name="result" /></scope><scope doc="Replace contents with &apos;xxx&apos; to prevent syntax matching.&#xA;&#xA;&gt;&gt;&gt; mute_string(&apos;&quot;abc&quot;&apos;)&#xA;&apos;&quot;xxx&quot;&apos;&#xA;&gt;&gt;&gt; mute_string(&quot;&apos;&apos;&apos;abc&apos;&apos;&apos;&quot;)&#xA;&quot;&apos;&apos;&apos;xxx&apos;&apos;&apos;&quot;&#xA;&gt;&gt;&gt; mute_string(&quot;r&apos;abc&apos;&quot;)&#xA;&quot;r&apos;xxx&apos;&quot;" ilk="function" line="1064" lineend="1086" name="mute_string" returns="str" signature="mute_string(text)"><variable ilk="argument" name="text" /><variable citdl="int" line="1075" name="start" /><variable citdl="len()" line="1076" name="end" /></scope><scope doc="Find all globally visible functions where the first argument name&#xA;starts with argument_name." ilk="function" line="1094" lineend="1111" name="find_checks" returns="list" signature="find_checks(argument_name)"><variable ilk="argument" name="argument_name" /><variable citdl="list" line="1099" name="checks" /><variable line="1103" name="args" /><variable citdl="ERRORCODE_REGEX.findall()" line="1105" name="codes" /></scope><scope classrefs="object" doc="Load a Python source file, tokenize it, check coding style." ilk="class" line="1114" lineend="1337" name="Checker"><scope attributes="__ctor__" ilk="function" line="1119" lineend="1128" name="__init__" signature="Checker(filename, lines=None)"><variable citdl="Checker" ilk="argument" name="self" /><variable ilk="argument" name="filename" /><variable ilk="argument" name="lines" /></scope><variable attributes="__instancevar__" citdl="str" line="1120" name="filename" /><variable attributes="__instancevar__" citdl="readlines()" line="1123" name="lines" /><scope doc="Get the next line from the input buffer." ilk="function" line="1130" lineend="1137" name="readline" returns="str" signature="readline()"><variable citdl="Checker" ilk="argument" name="self" /></scope><scope doc="Check and return the next physical line. This method can be&#xA;used to feed tokenize.generate_tokens." ilk="function" line="1139" lineend="1147" name="readline_check_physical" returns="readline()" signature="readline_check_physical()"><variable citdl="Checker" ilk="argument" name="self" /><variable citdl="readline()" line="1144" name="line" /></scope><scope doc="Run a check plugin." ilk="function" line="1149" lineend="1156" name="run_check" returns="Checker.run_check.check()" signature="run_check(check, argument_names)"><variable citdl="Checker" ilk="argument" name="self" /><variable ilk="argument" name="check" /><variable ilk="argument" name="argument_names" /><variable citdl="list" line="1153" name="arguments" /></scope><scope doc="Run all physical checks on a raw input line." ilk="function" line="1158" lineend="1169" name="check_physical" signature="check_physical(line)"><variable citdl="Checker" ilk="argument" name="self" /><variable ilk="argument" name="line" /><variable citdl="run_check()" line="1166" name="result" /></scope><variable attributes="__instancevar__" line="1162" name="physical_line" /><variable attributes="__instancevar__" line="1164" name="indent_char" /><scope doc="Build a logical line from tokens." ilk="function" line="1171" lineend="1203" name="build_tokens_line" signature="build_tokens_line()"><variable citdl="Checker" ilk="argument" name="self" /><variable citdl="list" line="1176" name="logical" /><variable citdl="int" line="1177" name="length" /><variable citdl="token" line="1178" name="previous" /><variable citdl="mute_string()" line="1184" name="text" /><variable line="1189" name="prev_text" /><variable citdl="list" line="1195" name="fill" /></scope><variable attributes="__instancevar__" citdl="list" line="1175" name="mapping" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1202" name="logical_line" /><scope doc="Build a line from tokens and run all logical checks on it." ilk="function" line="1205" lineend="1232" name="check_logical" signature="check_logical()"><variable citdl="Checker" ilk="argument" name="self" /><variable line="1211" name="first_line" /><variable citdl="list" line="1212" name="indent" /><variable line="1227" name="original_number" /><variable citdl="token_offset" line="1228" name="original_offset" /></scope><variable attributes="__instancevar__" citdl="self.indent_level" line="1213" name="previous_indent_level" /><variable attributes="__instancevar__" citdl="int" line="1214" name="indent_level" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1232" name="previous_logical" /><scope doc="Check if the syntax is valid." ilk="function" line="1234" lineend="1249" name="generate_tokens" signature="generate_tokens()"><variable citdl="Checker" ilk="argument" name="self" /><variable citdl="tokenize.generate_tokens()" line="1238" name="tokengen" /><variable citdl="list" line="1244" name="offset" /></scope><scope doc="Run all checks on the input file." ilk="function" line="1251" lineend="1305" name="check_all" returns="int" signature="check_all(expected=None, line_offset=0)"><variable citdl="Checker" ilk="argument" name="self" /><variable ilk="argument" name="expected" /><variable citdl="int" ilk="argument" name="line_offset" /><variable citdl="int" line="1265" name="parens" /><variable citdl="str" line="1269" name="pos" /><variable line="1293" name="source_line" /><variable line="1294" name="token_start" /></scope><variable attributes="__instancevar__" citdl="tuple" line="1255" name="expected" /><variable attributes="__instancevar__" citdl="int" line="1256" name="line_offset" /><variable attributes="__instancevar__" citdl="int" line="1257" name="line_number" /><variable attributes="__instancevar__" citdl="int" line="1258" name="file_errors" /><variable attributes="__instancevar__" citdl="int" line="1262" name="blank_lines" /><variable attributes="__instancevar__" citdl="int" line="1263" name="blank_lines_before_comment" /><variable attributes="__instancevar__" citdl="list" line="1264" name="tokens" /><scope doc="Report an error, according to options." ilk="function" line="1307" lineend="1337" name="report_error" signature="report_error(line_number, offset, text, check)"><variable citdl="Checker" ilk="argument" name="self" /><variable ilk="argument" name="line_number" /><variable ilk="argument" name="offset" /><variable ilk="argument" name="text" /><variable ilk="argument" name="check" /><variable citdl="list" line="1311" name="code" /><variable citdl="str" line="1331" name="line" /></scope></scope><scope doc="Run all checks on a Python source file." ilk="function" line="1340" lineend="1346" name="input_file" signature="input_file(filename)"><variable ilk="argument" name="filename" /><variable line="1346" name="errors" /></scope><scope doc="Check all Python source files in this directory and all subdirectories." ilk="function" line="1349" lineend="1370" name="input_dir" signature="input_dir(dirname, runner=None)"><variable citdl="dirname.rstrip()" ilk="argument" name="dirname" /><variable citdl="input_file" ilk="argument" name="runner" /></scope><scope doc="Check if options.exclude contains a pattern that matches filename." ilk="function" line="1373" lineend="1381" name="excluded" returns="bool" signature="excluded(filename)"><variable ilk="argument" name="filename" /><variable citdl="os.path.basename()" line="1377" name="basename" /></scope><scope doc="Check if options.filename contains a pattern that matches filename.&#xA;If options.filename is unspecified, this always returns True." ilk="function" line="1384" lineend="1393" name="filename_match" returns="bool" signature="filename_match(filename)"><variable ilk="argument" name="filename" /></scope><scope doc="Check if options.ignore contains a prefix of the error code.&#xA;If options.select contains a prefix of the error code, do not ignore it." ilk="function" line="1396" lineend="1406" name="ignore_code" returns="bool" signature="ignore_code(code)"><variable ilk="argument" name="code" /></scope><scope ilk="function" line="1409" lineend="1413" name="reset_counters" signature="reset_counters()" /><scope doc="Get error statistics." ilk="function" line="1416" lineend="1418" name="get_error_statistics" returns="get_statistics()" signature="get_error_statistics()" /><scope doc="Get warning statistics." ilk="function" line="1421" lineend="1423" name="get_warning_statistics" returns="get_statistics()" signature="get_warning_statistics()" /><scope doc="Get statistics for message codes that start with the prefix.&#xA;&#xA;prefix=&apos;&apos; matches all errors and warnings&#xA;prefix=&apos;E&apos; matches all errors&#xA;prefix=&apos;W&apos; matches all warnings&#xA;prefix=&apos;E4&apos; matches all errors that have to do with imports" ilk="function" line="1426" lineend="1442" name="get_statistics" returns="list" signature="get_statistics(prefix=&apos;&apos;)"><variable citdl="str" ilk="argument" name="prefix" /><variable citdl="list" line="1435" name="stats" /><variable citdl="list()" line="1436" name="keys" /></scope><scope doc="Return the total count of errors and warnings." ilk="function" line="1445" lineend="1452" name="get_count" returns="int" signature="get_count(prefix=&apos;&apos;)"><variable citdl="str" ilk="argument" name="prefix" /><variable citdl="list()" line="1447" name="keys" /><variable citdl="int" line="1448" name="count" /></scope><scope doc="Print overall statistics (number of errors and warnings)." ilk="function" line="1455" lineend="1458" name="print_statistics" signature="print_statistics(prefix=&apos;&apos;)"><variable citdl="str" ilk="argument" name="prefix" /></scope><scope doc="Print benchmark numbers." ilk="function" line="1461" lineend="1469" name="print_benchmark" signature="print_benchmark(elapsed)"><variable ilk="argument" name="elapsed" /></scope><scope doc="Run all the tests from a file.&#xA;&#xA;A test file can provide many tests.  Each test starts with a declaration.&#xA;This declaration is a single line starting with &apos;#:&apos;.&#xA;It declares codes of expected failures, separated by spaces or &apos;Okay&apos;&#xA;if no failure is expected.&#xA;If the file does not contain such declaration, it should pass all tests.&#xA;If the declaration is empty, following lines are not checked, until next&#xA;declaration.&#xA;&#xA;Examples:&#xA;&#xA; * Only E224 and W701 are expected:         #: E224 W701&#xA; * Following example is conform:            #: Okay&#xA; * Don&apos;t check these lines:                 #:" ilk="function" line="1472" lineend="1519" name="run_tests" signature="run_tests(filename)"><variable ilk="argument" name="filename" /><variable citdl="list" line="1490" name="lines" /><variable citdl="int" line="1491" name="line_offset" /><variable citdl="list" line="1492" name="codes" /><variable citdl="list" line="1493" name="testcase" /><variable citdl="str" line="1501" name="label" /><variable line="1504" name="errors" /></scope><scope doc="Test all check functions with test cases in docstrings." ilk="function" line="1522" lineend="1569" name="selftest" signature="selftest()"><variable citdl="int" line="1526" name="count_passed" /><variable citdl="int" line="1527" name="count_failed" /><variable citdl="options.physical_checks" line="1528" name="checks" /><variable citdl="line.lstrip()" line="1531" name="line" /><variable citdl="SELFTEST_REGEX.match()" line="1532" name="match" /><variable line="1535" name="code" /><variable line="1535" name="source" /><variable citdl="Checker" line="1536" name="checker" /><variable citdl="part.replace()" line="1538" name="part" /><variable citdl="str" line="1543" name="error" /><variable citdl="list" line="1546" name="codes" /></scope><scope doc="Process options passed either via arglist or via command line args." ilk="function" line="1572" lineend="1655" name="process_options" returns="tuple" signature="process_options(arglist=None)"><variable ilk="argument" name="arglist" /><variable citdl="OptionParser()" line="1577" name="parser" /><variable line="1621" name="options" /><variable line="1621" name="args" /></scope><scope attributes="protected" doc="Parse options and run checks on Python source." ilk="function" line="1658" lineend="1687" name="_main" signature="_main()"><import line="1664" module="doctest" /><variable line="1662" name="args" /><variable line="1662" name="options" /><variable citdl="run_tests" line="1668" name="runner" /><variable citdl="time.time()" line="1671" name="start_time" /><variable citdl="time.time()" line="1678" name="elapsed" /><variable citdl="get_count()" line="1683" name="count" /></scope></scope>