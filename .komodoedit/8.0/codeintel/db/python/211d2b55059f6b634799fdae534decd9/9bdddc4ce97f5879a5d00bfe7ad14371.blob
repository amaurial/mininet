<scope doc="Package resource API --------------------" ilk="blob" lang="Python" name="pkg_resources" src="/usr/lib/python2.7/dist-packages/pkg_resources.py"><import line="16" module="sys" /><import line="16" module="os" /><import line="16" module="zipimport" /><import line="16" module="time" /><import line="16" module="re" /><import line="16" module="imp" /><import line="16" module="types" /><import line="17" module="urlparse" symbol="urlparse" /><import line="17" module="urlparse" symbol="urlunparse" /><import alias="frozenset" line="22" module="sets" symbol="ImmutableSet" /><import line="25" module="os" symbol="utime" /><import line="27" module="os" symbol="mkdir" /><import line="27" module="os" symbol="rename" /><import line="27" module="os" symbol="unlink" /><import alias="os_open" line="33" module="os" symbol="open" /><import line="34" module="os.path" symbol="isdir" /><import line="34" module="os.path" symbol="split" /><import line="1330" module="_frozen_importlib" /><import line="1676" module="pkgutil" symbol="get_importer" /><import line="1676" module="pkgutil" symbol="ImpImporter" /><import line="1772" module="_frozen_importlib" /><import line="1879" module="_frozen_importlib" /><import line="2809" module="__main__" symbol="__requires__" /><variable citdl="False" line="28" name="WRITE_SUPPORT" /><variable attributes="protected" citdl="True" line="43" name="_distribute" /><scope attributes="protected" ilk="function" line="45" lineend="52" name="_bypass_ensure_directory" signature="_bypass_ensure_directory(name, mode=511)"><variable ilk="argument" name="name" /><variable citdl="int" ilk="argument" name="mode" /><variable line="49" name="dirname" /><variable line="49" name="filename" /></scope><variable attributes="protected" citdl="dict" line="55" name="_state_vars" /><scope attributes="protected" ilk="function" line="57" lineend="61" name="_declare_state" signature="_declare_state(vartype, **kw)"><variable ilk="argument" name="vartype" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="globals()" line="58" name="g" /></scope><scope ilk="function" line="63" lineend="68" name="__getstate__" returns="dict" signature="__getstate__()"><variable citdl="dict" line="64" name="state" /><variable citdl="globals()" line="65" name="g" /></scope><scope ilk="function" line="70" lineend="74" name="__setstate__" signature="__setstate__(state)"><variable ilk="argument" name="state" /><variable citdl="globals()" line="71" name="g" /></scope><scope attributes="protected" ilk="function" line="76" lineend="77" name="_sget_dict" returns="val.copy()" signature="_sget_dict(val)"><variable ilk="argument" name="val" /></scope><scope attributes="protected" ilk="function" line="79" lineend="81" name="_sset_dict" signature="_sset_dict(key, ob, state)"><variable ilk="argument" name="key" /><variable ilk="argument" name="ob" /><variable ilk="argument" name="state" /></scope><scope attributes="protected" ilk="function" line="83" lineend="84" name="_sget_object" returns="val.__getstate__()" signature="_sget_object(val)"><variable ilk="argument" name="val" /></scope><scope attributes="protected" ilk="function" line="86" lineend="87" name="_sset_object" signature="_sset_object(key, ob, state)"><variable ilk="argument" name="key" /><variable ilk="argument" name="ob" /><variable ilk="argument" name="state" /></scope><variable attributes="protected" line="89" name="_sget_none" /><scope doc="Return this platform&apos;s maximum compatible version.&#xA;&#xA;distutils.util.get_platform() normally reports the minimum version&#xA;of Mac OS X that would be required to *use* extensions produced by&#xA;distutils.  But what we want when checking compatibility is to know the&#xA;version of Mac OS X that we are *running*.  To allow usage of packages that&#xA;explicitly require a newer version of Mac OS X, we must also know the&#xA;current version of the OS.&#xA;&#xA;If this condition occurs for any other platform with a version in its&#xA;platform strings, this function should be extended accordingly." ilk="function" line="93" lineend="112" name="get_supported_platform" returns="tuple" signature="get_supported_platform()"><variable citdl="macosVersionString.match()" line="106" name="m" /><variable citdl="get_build_platform()" line="106" name="plat" /></scope><variable citdl="list" line="134" name="__all__" /><scope classrefs="Exception" doc="Abstract base for dependency resolution errors" ilk="class" line="175" lineend="178" name="ResolutionError"><scope ilk="function" line="177" lineend="178" name="__repr__" returns="repr()" signature="__repr__()"><variable citdl="ResolutionError" ilk="argument" name="self" /></scope></scope><scope classrefs="ResolutionError" doc="An already-installed version conflicts with the requested version" ilk="class" line="180" name="VersionConflict" /><scope classrefs="ResolutionError" doc="A requested distribution was not found" ilk="class" line="183" name="DistributionNotFound" /><scope classrefs="ResolutionError" doc="Distribution doesn&apos;t have an &quot;extra feature&quot; of the given name" ilk="class" line="186" name="UnknownExtra" /><variable attributes="protected" citdl="dict" line="188" name="_provider_factories" /><variable citdl="list" line="190" name="PY_MAJOR" /><variable citdl="int" line="191" name="EGG_DIST" /><variable citdl="int" line="192" name="BINARY_DIST" /><variable citdl="int" line="193" name="SOURCE_DIST" /><variable citdl="int" line="194" name="CHECKOUT_DIST" /><variable citdl="int" line="195" name="DEVELOP_DIST" /><scope doc="Register `provider_factory` to make providers for `loader_type`&#xA;&#xA;`loader_type` is the type or class of a PEP 302 ``module.__loader__``,&#xA;and `provider_factory` is a function that, passed a *module* object,&#xA;returns an ``IResourceProvider`` for that module." ilk="function" line="197" lineend="204" name="register_loader_type" signature="register_loader_type(loader_type, provider_factory)"><variable ilk="argument" name="loader_type" /><variable ilk="argument" name="provider_factory" /></scope><scope doc="Return an IResourceProvider for the named module or requirement" ilk="function" line="206" lineend="216" name="get_provider" returns="_find_adapter()()" signature="get_provider(moduleOrReq)"><variable ilk="argument" name="moduleOrReq" /><variable line="211" name="module" /><variable citdl="getattr()" line="215" name="loader" /></scope><scope attributes="protected" ilk="function" line="218" lineend="233" name="_macosx_vers" signature="_macosx_vers(_cache=[])"><import line="220" module="platform" /><import line="224" module="plistlib" /><variable citdl="list" ilk="argument" name="_cache" /><variable line="221" name="version" /><variable citdl="str" line="225" name="plist" /><variable citdl="plistlib.readPlist()" line="228" name="plist_content" /></scope><scope attributes="protected" ilk="function" line="235" lineend="236" name="_macosx_arch" returns="{}.get()" signature="_macosx_arch(machine)"><variable ilk="argument" name="machine" /></scope><scope doc="Return this platform&apos;s string for platform-specific distributions&#xA;&#xA;XXX Currently this is the same as ``distutils.util.get_platform()``, but it&#xA;needs some hacks for Linux and Mac OS X." ilk="function" line="238" lineend="260" name="get_build_platform" returns="tuple" signature="get_build_platform()"><import line="245" module="distutils.util" symbol="get_platform" /><import line="247" module="sysconfig" symbol="get_platform" /><variable citdl="get_platform()" line="249" name="plat" /><variable citdl="_macosx_vers()" line="252" name="version" /><variable line="253" name="machine" /></scope><variable citdl="re.compile()" line="262" name="macosVersionString" /><variable citdl="re.compile()" line="263" name="darwinVersionString" /><variable citdl="get_build_platform" line="264" name="get_platform" /><scope doc="Can code for the `provided` platform run on the `required` platform?&#xA;&#xA;Returns true if either platform is ``None``, or the platforms are equal.&#xA;&#xA;XXX Needs compatibility checks for Linux and other unixy OSes." ilk="function" line="266" lineend="314" name="compatible_platforms" returns="bool" signature="compatible_platforms(provided, required)"><variable ilk="argument" name="provided" /><variable ilk="argument" name="required" /><variable citdl="macosVersionString.match()" line="277" name="reqMac" /><variable citdl="macosVersionString.match()" line="279" name="provMac" /><variable citdl="darwinVersionString.match()" line="286" name="provDarwin" /><variable citdl="int()" line="288" name="dversion" /><variable citdl="str" line="289" name="macosversion" /></scope><variable citdl="function" doc="Locate distribution `dist_spec` and run its `script_name` script" line="317" name="run_script" /><variable citdl="function" line="325" name="run_main" /><scope doc="Return a current distribution object for a Requirement or string" ilk="function" line="327" lineend="333" name="get_distribution" returns="get_provider()" signature="get_distribution(dist)"><variable citdl="Requirement.parse()" ilk="argument" name="dist" /></scope><scope doc="Return `name` entry point of `group` for `dist` or raise ImportError" ilk="function" line="335" lineend="337" name="load_entry_point" signature="load_entry_point(dist, group, name)"><variable ilk="argument" name="dist" /><variable ilk="argument" name="group" /><variable ilk="argument" name="name" /></scope><scope doc="Return the entry point map for `group`, or the full entry map" ilk="function" line="339" lineend="341" name="get_entry_map" signature="get_entry_map(dist, group=None)"><variable ilk="argument" name="dist" /><variable ilk="argument" name="group" /></scope><scope doc="Return the EntryPoint object for `group`+`name`, or ``None``" ilk="function" line="343" lineend="345" name="get_entry_info" signature="get_entry_info(dist, group, name)"><variable ilk="argument" name="dist" /><variable ilk="argument" name="group" /><variable ilk="argument" name="name" /></scope><scope ilk="class" line="348" name="IMetadataProvider"><scope doc="Does the package&apos;s distribution contain the named metadata?" ilk="function" line="350" name="has_metadata" signature="has_metadata()"><variable citdl="IMetadataProvider" ilk="argument" name="name" /></scope><scope doc="The named metadata resource as a string" ilk="function" line="353" name="get_metadata" signature="get_metadata()"><variable citdl="IMetadataProvider" ilk="argument" name="name" /></scope><scope doc="Yield named metadata resource as list of non-blank non-comment lines&#xA;&#xA;Leading and trailing whitespace is stripped from each line, and lines&#xA;with ``#`` as the first non-blank character are omitted." ilk="function" line="356" name="get_metadata_lines" signature="get_metadata_lines()"><variable citdl="IMetadataProvider" ilk="argument" name="name" /></scope><scope doc="Is the named metadata a directory?  (like ``os.path.isdir()``)" ilk="function" line="362" name="metadata_isdir" signature="metadata_isdir()"><variable citdl="IMetadataProvider" ilk="argument" name="name" /></scope><scope doc="List of metadata names in the directory (like ``os.listdir()``)" ilk="function" line="365" name="metadata_listdir" signature="metadata_listdir()"><variable citdl="IMetadataProvider" ilk="argument" name="name" /></scope><scope doc="Execute the named script in the supplied namespace dictionary" ilk="function" line="368" name="run_script" signature="run_script(namespace)"><variable citdl="IMetadataProvider" ilk="argument" name="script_name" /><variable ilk="argument" name="namespace" /></scope></scope><scope classrefs="IMetadataProvider" doc="An object that provides access to package resources" ilk="class" line="380" name="IResourceProvider"><scope doc="Return a true filesystem path for `resource_name`&#xA;&#xA;`manager` must be an ``IResourceManager``" ilk="function" line="383" name="get_resource_filename" signature="get_resource_filename(resource_name)"><variable citdl="IResourceProvider" ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Return a readable file-like object for `resource_name`&#xA;&#xA;`manager` must be an ``IResourceManager``" ilk="function" line="388" name="get_resource_stream" signature="get_resource_stream(resource_name)"><variable citdl="IResourceProvider" ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Return a string containing the contents of `resource_name`&#xA;&#xA;`manager` must be an ``IResourceManager``" ilk="function" line="393" name="get_resource_string" signature="get_resource_string(resource_name)"><variable citdl="IResourceProvider" ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Does the package contain the named resource?" ilk="function" line="398" name="has_resource" signature="has_resource()"><variable citdl="IResourceProvider" ilk="argument" name="resource_name" /></scope><scope doc="Is the named resource a directory?  (like ``os.path.isdir()``)" ilk="function" line="401" name="resource_isdir" signature="resource_isdir()"><variable citdl="IResourceProvider" ilk="argument" name="resource_name" /></scope><scope doc="List of resource names in the directory (like ``os.listdir()``)" ilk="function" line="404" name="resource_listdir" signature="resource_listdir()"><variable citdl="IResourceProvider" ilk="argument" name="resource_name" /></scope></scope><scope classrefs="object" doc="A collection of active distributions on sys.path (or a similar list)" ilk="class" line="421" lineend="719" name="WorkingSet"><scope attributes="__ctor__" doc="Create working set from list of path entries (default=sys.path)" ilk="function" line="424" lineend="435" name="__init__" signature="WorkingSet(entries=None)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable citdl="sys.path" ilk="argument" name="entries" /></scope><variable attributes="__instancevar__" citdl="list" line="426" name="entries" /><variable attributes="__instancevar__" citdl="keys.copy()" line="427" name="entry_keys" /><variable attributes="__instancevar__" citdl="by_key.copy()" line="428" name="by_key" /><variable attributes="__instancevar__" citdl="list" line="429" name="callbacks" /><scope doc="Add a path item to ``.entries``, finding any distributions on it&#xA;&#xA;``find_distributions(entry,True)`` is used to find distributions&#xA;corresponding to the path entry, and they are added.  `entry` is&#xA;always appended to ``.entries``, even if it is already present.&#xA;(This is because ``sys.path`` can contain the same value more than&#xA;once, and the ``.entries`` of the ``sys.path`` WorkingSet should always&#xA;equal ``sys.path``.)" ilk="function" line="438" lineend="451" name="add_entry" signature="add_entry(entry)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="entry" /></scope><scope doc="True if `dist` is the active distribution for its project" ilk="function" line="454" lineend="456" name="__contains__" returns="bool" signature="__contains__(dist)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="dist" /></scope><scope doc="Find a distribution matching requirement `req`&#xA;&#xA;If there is an active distribution for the requested project, this&#xA;returns it as long as it meets the version requirement specified by&#xA;`req`.  But, if there is an active distribution for the project and it&#xA;does *not* meet the `req` requirement, ``VersionConflict`` is raised.&#xA;If there is no active distribution for the requested project, ``None``&#xA;is returned." ilk="function" line="462" lineend="476" name="find" returns="self.by_key.get()" signature="find(req)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="req" /><variable citdl="self.by_key.get()" line="472" name="dist" /></scope><scope doc="Yield entry point objects from `group` matching `name`&#xA;&#xA;If `name` is None, yields all entry points in `group` from all&#xA;distributions in the working set, otherwise only ones matching&#xA;both `group` and `name` are yielded (in distribution order)." ilk="function" line="478" lineend="491" name="iter_entry_points" signature="iter_entry_points(group, name=None)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="group" /><variable ilk="argument" name="name" /><variable citdl="dist.get_entry_map()" line="486" name="entries" /></scope><scope doc="Locate distribution for `requires` and run `script_name` script" ilk="function" line="493" lineend="499" name="run_script" signature="run_script(requires, script_name)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="requires" /><variable ilk="argument" name="script_name" /><variable line="495" name="ns" /><variable line="496" name="name" /></scope><scope doc="Yield distributions for non-duplicate projects in the working set&#xA;&#xA;The yield order is the order in which the items&apos; path entries were&#xA;added to the working set." ilk="function" line="503" lineend="518" name="__iter__" signature="__iter__()"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable citdl="dict" line="509" name="seen" /></scope><scope doc="Add `dist` to working set, associated with `entry`&#xA;&#xA;If `entry` is unspecified, it defaults to the ``.location`` of `dist`.&#xA;On exit from this routine, `entry` is added to the end of the working&#xA;set&apos;s ``.entries`` (if it wasn&apos;t already present).&#xA;&#xA;`dist` is only added to the working set if it&apos;s for a project that&#xA;doesn&apos;t already have a distribution in the set.  If it&apos;s added, any&#xA;callbacks registered with the ``subscribe()`` method will be called." ilk="function" line="520" lineend="546" name="add" signature="add(dist, entry=None, insert=True)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="dist" /><variable citdl="dist.location" ilk="argument" name="entry" /><variable citdl="True" ilk="argument" name="insert" /><variable citdl="self.entry_keys.setdefault()" line="536" name="keys" /><variable citdl="self.entry_keys.setdefault()" line="537" name="keys2" /></scope><scope doc="List all distributions needed to (recursively) meet `requirements`&#xA;&#xA;`requirements` must be a sequence of ``Requirement`` objects.  `env`,&#xA;if supplied, should be an ``Environment`` instance.  If&#xA;not supplied, it defaults to all distributions available within any&#xA;entry or distribution in the working set.  `installer`, if supplied,&#xA;will be invoked with each requirement that cannot be met by an&#xA;already-installed distribution; it should return a ``Distribution`` or&#xA;``None``." ilk="function" line="548" lineend="596" name="resolve" returns="list" signature="resolve(requirements, env=None, installer=None, replacement=True)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="requirements" /><variable citdl="Environment()" ilk="argument" name="env" /><variable ilk="argument" name="installer" /><variable citdl="True" ilk="argument" name="replacement" /><variable citdl="dict" line="561" name="processed" /><variable citdl="dict" line="562" name="best" /><variable citdl="list" line="563" name="to_activate" /><variable citdl="requirements.pop()" line="566" name="req" /><variable citdl="self.by_key.get()" line="573" name="dist" /></scope><scope doc="Find all activatable distributions in `plugin_env`&#xA;&#xA;Example usage::&#xA;&#xA;    distributions, errors = working_set.find_plugins(&#xA;        Environment(plugin_dirlist)&#xA;    )&#xA;    map(working_set.add, distributions)  # add plugins+libs to sys.path&#xA;    print &apos;Could not load&apos;, errors        # display errors&#xA;&#xA;The `plugin_env` should be an ``Environment`` instance that contains&#xA;only distributions that are in the project&apos;s &quot;plugin directory&quot; or&#xA;directories. The `full_env`, if supplied, should be an ``Environment``&#xA;contains all currently-available distributions.  If `full_env` is not&#xA;supplied, one is created automatically from the ``WorkingSet`` this&#xA;method is called on, which will typically mean that every directory on&#xA;``sys.path`` will be scanned for distributions.&#xA;&#xA;`installer` is a standard installer callback as used by the&#xA;``resolve()`` method. The `fallback` flag indicates whether we should&#xA;attempt to resolve older versions of a plugin if the newest version&#xA;cannot be resolved.&#xA;&#xA;This method returns a 2-tuple: (`distributions`, `error_info`), where&#xA;`distributions` is a list of the distributions found in `plugin_env`&#xA;that were loadable, along with any other distributions that are needed&#xA;to resolve their dependencies.  `error_info` is a dictionary mapping&#xA;unloadable plugin distributions to an exception instance describing the&#xA;error that occurred. Usually this will be a ``DistributionNotFound`` or&#xA;``VersionConflict`` instance." ilk="function" line="598" lineend="674" name="find_plugins" returns="tuple" signature="find_plugins(plugin_env, full_env=None, installer=None, fallback=True)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="plugin_env" /><variable ilk="argument" name="full_env" /><variable ilk="argument" name="installer" /><variable citdl="True" ilk="argument" name="fallback" /><variable citdl="list()" line="633" name="plugin_projects" /><variable citdl="dict" line="636" name="error_info" /><variable citdl="list()" line="637" name="distributions" /><variable citdl="Environment()" line="640" name="env" /><variable citdl="self.__class__()" line="645" name="shadow_set" /><variable citdl="list" line="652" name="req" /><variable citdl="shadow_set.resolve()" line="655" name="resolvees" /></scope><scope doc="Ensure that distributions matching `requirements` are activated&#xA;&#xA;`requirements` must be a string or a (possibly-nested) sequence&#xA;thereof, specifying the distributions and versions required.  The&#xA;return value is a sequence of the distributions that needed to be&#xA;activated to fulfill the requirements; all relevant distributions are&#xA;included, even if they were already activated in this working set." ilk="function" line="680" lineend="695" name="require" returns="resolve()" signature="require(*requirements)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="requirements" /><variable citdl="resolve()" line="690" name="needed" /></scope><scope doc="Invoke `callback` for all distributions (including existing ones)" ilk="function" line="698" lineend="704" name="subscribe" signature="subscribe(callback)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="callback" /></scope><scope attributes="protected" ilk="function" line="707" lineend="709" name="_added_new" signature="_added_new(dist)"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="dist" /></scope><scope ilk="function" line="711" lineend="713" name="__getstate__" returns="tuple" signature="__getstate__()"><variable citdl="WorkingSet" ilk="argument" name="self" /></scope><scope ilk="function" line="715" lineend="719" name="__setstate__" signature="__setstate__((&apos;entries&apos;, &apos;keys&apos;, &apos;by_key&apos;, &apos;callbacks&apos;))"><variable citdl="WorkingSet" ilk="argument" name="self" /><variable ilk="argument" name="entries" /><variable ilk="argument" name="keys" /><variable ilk="argument" name="by_key" /><variable ilk="argument" name="callbacks" /></scope></scope><scope classrefs="object" doc="Searchable snapshot of distributions on a search path" ilk="class" line="724" lineend="864" name="Environment"><scope attributes="__ctor__" doc="Snapshot distributions available on a search path&#xA;&#xA;Any distributions found on `search_path` are added to the environment.&#xA;`search_path` should be a sequence of ``sys.path`` items.  If not&#xA;supplied, ``sys.path`` is used.&#xA;&#xA;`platform` is an optional string specifying the name of the platform&#xA;that platform-specific distributions must be compatible with.  If&#xA;unspecified, it defaults to the current platform.  `python` is an&#xA;optional string naming the desired version of Python (e.g. ``&apos;2.4&apos;``);&#xA;it defaults to the current version.&#xA;&#xA;You may explicitly set `platform` (and/or `python`) to ``None`` if you&#xA;wish to map *all* distributions, not just those compatible with the&#xA;running platform or Python version." ilk="function" line="727" lineend="748" name="__init__" signature="Environment(search_path=None, platform=get_supported_platform(), python=PY_MAJOR)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="search_path" /><variable citdl="get_supported_platform()" ilk="argument" name="platform" /><variable citdl="list" ilk="argument" name="python" /></scope><variable attributes="protected __instancevar__" citdl="dict" line="744" name="_distmap" /><variable attributes="protected __instancevar__" citdl="dict" line="745" name="_cache" /><variable attributes="__instancevar__" citdl="get_supported_platform()" line="746" name="platform" /><variable attributes="__instancevar__" citdl="list" line="747" name="python" /><scope doc="Is distribution `dist` acceptable for this environment?&#xA;&#xA;The distribution must match the platform and python version&#xA;requirements specified when this environment was created, or False&#xA;is returned." ilk="function" line="750" lineend="759" name="can_add" returns="bool" signature="can_add(dist)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="dist" /></scope><scope doc="Remove `dist` from the environment" ilk="function" line="761" lineend="763" name="remove" signature="remove(dist)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="dist" /></scope><scope doc="Scan `search_path` for distributions usable in this environment&#xA;&#xA;Any distributions found are added to the environment.&#xA;`search_path` should be a sequence of ``sys.path`` items.  If not&#xA;supplied, ``sys.path`` is used.  Only distributions conforming to&#xA;the platform/python version defined at initialization are added." ilk="function" line="765" lineend="778" name="scan" signature="scan(search_path=None)"><variable citdl="Environment" ilk="argument" name="self" /><variable citdl="sys.path" ilk="argument" name="search_path" /></scope><scope doc="Return a newest-to-oldest list of distributions for `project_name`&#xA;        " ilk="function" line="780" lineend="794" name="__getitem__" returns="list" signature="__getitem__(project_name)"><variable citdl="Environment" ilk="argument" name="self" /><variable citdl="project_name.lower()" ilk="argument" name="project_name" /><variable line="791" name="dists" /></scope><scope doc="Add `dist` if we ``can_add()`` it and it isn&apos;t already added" ilk="function" line="796" lineend="803" name="add" signature="add(dist)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="dist" /><variable citdl="self._distmap.setdefault()" line="799" name="dists" /></scope><scope doc="Find distribution best matching `req` and usable on `working_set`&#xA;&#xA;This calls the ``find(req)`` method of the `working_set` to see if a&#xA;suitable distribution is already active.  (This may raise&#xA;``VersionConflict`` if an unsuitable version of the project is already&#xA;active in the specified `working_set`.)  If a suitable distribution&#xA;isn&apos;t active, this method returns the newest distribution in the&#xA;environment that meets the ``Requirement`` in `req`.  If no suitable&#xA;distribution is found, and `installer` is supplied, then the result of&#xA;calling the environment&apos;s ``obtain(req, installer)`` method will be&#xA;returned." ilk="function" line="806" lineend="825" name="best_match" returns="self.obtain()" signature="best_match(req, working_set, installer=None)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="req" /><variable ilk="argument" name="working_set" /><variable ilk="argument" name="installer" /><variable citdl="working_set.find()" line="819" name="dist" /></scope><scope doc="Obtain a distribution matching `requirement` (e.g. via download)&#xA;&#xA;Obtain a distro that matches requirement (e.g. via download).  In the&#xA;base ``Environment`` class, this routine just returns&#xA;``installer(requirement)``, unless `installer` is None, in which case&#xA;None is returned instead.  This method is a hook that allows subclasses&#xA;to attempt other ways of obtaining a distribution before falling back&#xA;to the `installer` argument." ilk="function" line="827" lineend="837" name="obtain" returns="Environment.obtain.installer()" signature="obtain(requirement, installer=None)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="requirement" /><variable ilk="argument" name="installer" /></scope><scope doc="Yield the unique project names of the available distributions" ilk="function" line="839" lineend="842" name="__iter__" signature="__iter__()"><variable citdl="Environment" ilk="argument" name="self" /></scope><scope doc="In-place addition of a distribution or environment" ilk="function" line="847" lineend="857" name="__iadd__" returns="Environment" signature="__iadd__(other)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope doc="Add an environment or distribution to an environment" ilk="function" line="859" lineend="864" name="__add__" returns="self.__class__()" signature="__add__(other)"><variable citdl="Environment" ilk="argument" name="self" /><variable ilk="argument" name="other" /><variable citdl="self.__class__()" line="861" name="new" /></scope></scope><variable citdl="Environment" line="867" name="AvailableDistributions" /><scope classrefs="RuntimeError" doc="An error occurred extracting a resource&#xA;&#xA;The following attributes are available from instances of this exception:&#xA;&#xA;manager&#xA;    The resource manager that raised this exception&#xA;&#xA;cache_path&#xA;    The base directory for resource extraction&#xA;&#xA;original_error&#xA;    The exception instance that caused extraction to fail" ilk="class" line="870" name="ExtractionError" /><scope doc="Manage resource extraction and packages" ilk="class" line="888" name="ResourceManager"><variable line="890" name="extraction_path" /><scope attributes="__ctor__" ilk="function" line="892" lineend="893" name="__init__" signature="ResourceManager()"><variable citdl="ResourceManager" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="dict" line="893" name="cached_files" /><scope doc="Does the named resource exist?" ilk="function" line="895" lineend="897" name="resource_exists" signature="resource_exists(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Is the named resource an existing directory?" ilk="function" line="899" lineend="902" name="resource_isdir" signature="resource_isdir(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Return a true filesystem path for specified resource" ilk="function" line="905" lineend="908" name="resource_filename" signature="resource_filename(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Return a readable file-like object for specified resource" ilk="function" line="911" lineend="914" name="resource_stream" signature="resource_stream(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Return specified resource as a string" ilk="function" line="917" lineend="920" name="resource_string" signature="resource_string(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="List the contents of the named resource directory" ilk="function" line="923" lineend="926" name="resource_listdir" signature="resource_listdir(package_or_requirement, resource_name)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="package_or_requirement" /><variable ilk="argument" name="resource_name" /></scope><scope doc="Give an error message for problems extracting file(s)" ilk="function" line="929" lineend="954" name="extraction_error" signature="extraction_error()"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable line="932" name="old_exc" /><variable citdl="get_default_cache()" line="933" name="cache_path" /><variable citdl="ExtractionError" line="935" name="err" /></scope><scope doc="Return absolute location in cache for `archive_name` and `names`&#xA;&#xA;The parent directory of the resulting path will be created if it does&#xA;not already exist.  `archive_name` should be the base filename of the&#xA;enclosing egg (which may not be the name of the enclosing zipfile!),&#xA;including its &quot;.egg&quot; extension.  `names`, if provided, should be a&#xA;sequence of path name parts &quot;under&quot; the egg&apos;s extraction location.&#xA;&#xA;This method should only be called by resource providers that need to&#xA;obtain an extraction location, and only for names they intend to&#xA;extract, as it tracks the generated names for possible cleanup later." ilk="function" line="970" lineend="991" name="get_cache_path" returns="os.path.join()" signature="get_cache_path(archive_name, names=())"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="archive_name" /><variable citdl="tuple" ilk="argument" name="names" /><variable citdl="get_default_cache()" line="983" name="extract_path" /><variable citdl="os.path.join()" line="984" name="target_path" /></scope><scope doc="Perform any platform-specific postprocessing of `tempname`&#xA;&#xA;This is where Mac header rewrites should be done; other platforms don&apos;t&#xA;have anything special they should do.&#xA;&#xA;Resource providers should call this method ONLY after successfully&#xA;extracting a compressed resource.  They must NOT call it on resources&#xA;that are already in the filesystem.&#xA;&#xA;`tempname` is the current (temporary) name of the file, and `filename`&#xA;is the name it will be renamed to by the caller after this routine&#xA;returns." ilk="function" line="1011" lineend="1029" name="postprocess" signature="postprocess(tempname, filename)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="tempname" /><variable ilk="argument" name="filename" /><variable citdl="int" line="1028" name="mode" /></scope><scope doc="Set the base path where resources will be extracted to, if needed.&#xA;&#xA;If you do not call this routine before any extractions take place, the&#xA;path defaults to the return value of ``get_default_cache()``.  (Which&#xA;is based on the ``PYTHON_EGG_CACHE`` environment variable, with various&#xA;platform-specific fallbacks.  See that routine&apos;s documentation for more&#xA;details.)&#xA;&#xA;Resources are extracted to subdirectories of this path based upon&#xA;information given by the ``IResourceProvider``.  You may set this to a&#xA;temporary directory, but then you must call ``cleanup_resources()`` to&#xA;delete the extracted files when done.  There is no guarantee that&#xA;``cleanup_resources()`` will be able to remove all extracted files.&#xA;&#xA;(Note: you may not change the extraction path for a given resource&#xA;manager once resources have been extracted, unless you first call&#xA;``cleanup_resources()``.)" ilk="function" line="1052" lineend="1076" name="set_extraction_path" signature="set_extraction_path(path)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope doc="Delete all extracted resource files and directories, returning a list&#xA;of the file and directory names that could not be successfully removed.&#xA;This function does not have any concurrency protection, so it should&#xA;generally only be called when the extraction path is a temporary&#xA;directory exclusive to a single process.  This method is not&#xA;automatically called; you must call it explicitly or register it as an&#xA;``atexit`` function if you wish to ensure cleanup of a temporary&#xA;directory used for extractions." ilk="function" line="1078" name="cleanup_resources" signature="cleanup_resources(force=False)"><variable citdl="ResourceManager" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="force" /></scope></scope><scope doc="Determine the default cache location&#xA;&#xA;This returns the ``PYTHON_EGG_CACHE`` environment variable, if set.&#xA;Otherwise, on Windows, it returns a &quot;Python-Eggs&quot; subdirectory of the&#xA;&quot;Application Data&quot; directory.  On all other systems, it&apos;s &quot;~/.python-eggs&quot;." ilk="function" line="1093" lineend="1131" name="get_default_cache" returns="os.path.join()" signature="get_default_cache()"><variable citdl="str" line="1108" name="app_data" /><variable citdl="list" line="1109" name="app_homes" /><variable citdl="os.path.join()" line="1119" name="dirname" /></scope><scope doc="Convert an arbitrary string to a standard distribution name&#xA;&#xA;Any runs of non-alphanumeric/. characters are replaced with a single &apos;-&apos;." ilk="function" line="1134" lineend="1139" name="safe_name" returns="re.sub()" signature="safe_name(name)"><variable ilk="argument" name="name" /></scope><scope doc="Convert an arbitrary string to a standard version string&#xA;&#xA;Spaces become dots, and all other non-alphanumeric characters become&#xA;dashes, with runs of multiple dashes condensed to a single dash." ilk="function" line="1142" lineend="1149" name="safe_version" returns="re.sub()" signature="safe_version(version)"><variable citdl="version.replace()" ilk="argument" name="version" /></scope><scope doc="Convert an arbitrary string to a standard &apos;extra&apos; name&#xA;&#xA;Any runs of non-alphanumeric characters are replaced with a single &apos;_&apos;,&#xA;and the result is always lowercased." ilk="function" line="1152" lineend="1158" name="safe_extra" signature="safe_extra(extra)"><variable ilk="argument" name="extra" /></scope><scope doc="Convert a project or version name to its filename-escaped form&#xA;&#xA;Any &apos;-&apos; characters are currently replaced with &apos;_&apos;." ilk="function" line="1161" lineend="1166" name="to_filename" returns="name.replace()" signature="to_filename(name)"><variable ilk="argument" name="name" /></scope><scope doc="Try to implement resources and metadata for arbitrary PEP 302 loaders" ilk="class" line="1175" lineend="1272" name="NullProvider"><variable line="1178" name="egg_name" /><variable line="1179" name="egg_info" /><variable citdl="getattr()" line="1180" name="loader" /><scope attributes="__ctor__" ilk="function" line="1182" lineend="1184" name="__init__" signature="NullProvider(module)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="module" /></scope><variable attributes="__instancevar__" citdl="os.path.dirname()" line="1184" name="module_path" /><scope ilk="function" line="1186" lineend="1187" name="get_resource_filename" returns="self._fn()" signature="get_resource_filename(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1189" lineend="1190" name="get_resource_stream" returns="StringIO()" signature="get_resource_stream(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1192" lineend="1193" name="get_resource_string" returns="self._get()" signature="get_resource_string(manager, resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1195" lineend="1196" name="has_resource" returns="self._has()" signature="has_resource(resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1198" lineend="1199" name="has_metadata" returns="self._has()" signature="has_metadata(name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1207" lineend="1210" name="get_metadata" returns="str" signature="get_metadata(name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1212" lineend="1213" name="get_metadata_lines" returns="yield_lines()" signature="get_metadata_lines(name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1215" lineend="1216" name="resource_isdir" returns="self._isdir()" signature="resource_isdir(resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1218" lineend="1219" name="metadata_isdir" returns="self._isdir()" signature="metadata_isdir(name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1222" lineend="1223" name="resource_listdir" returns="self._listdir()" signature="resource_listdir(resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="resource_name" /></scope><scope ilk="function" line="1225" lineend="1228" name="metadata_listdir" returns="list" signature="metadata_listdir(name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1230" lineend="1246" name="run_script" signature="run_script(script_name, namespace)"><import line="1241" module="linecache" symbol="cache" /><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="script_name" /><variable ilk="argument" name="namespace" /><variable citdl="str" line="1231" name="script" /><variable citdl="script_text.replace()" line="1234" name="script_text" /><variable citdl="self._fn()" line="1236" name="script_filename" /><variable citdl="compile()" line="1245" name="script_code" /></scope><scope attributes="protected" ilk="function" line="1248" lineend="1250" name="_has" signature="_has(path)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope attributes="protected" ilk="function" line="1253" lineend="1255" name="_isdir" signature="_isdir(path)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope attributes="protected" ilk="function" line="1258" lineend="1260" name="_listdir" signature="_listdir(path)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope attributes="protected" ilk="function" line="1263" lineend="1266" name="_fn" returns="os.path.join()" signature="_fn(base, resource_name)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="base" /><variable ilk="argument" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1268" lineend="1272" name="_get" returns="self.loader.get_data()" signature="_get(path)"><variable citdl="NullProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope></scope><scope classrefs="NullProvider" doc="Provider based on a virtual filesystem" ilk="class" line="1278" lineend="1297" name="EggProvider"><scope attributes="__ctor__" ilk="function" line="1281" lineend="1283" name="__init__" signature="EggProvider(module)"><variable citdl="EggProvider" ilk="argument" name="self" /><variable ilk="argument" name="module" /></scope><scope attributes="protected" ilk="function" line="1285" lineend="1297" name="_setup_prefix" signature="_setup_prefix()"><variable citdl="EggProvider" ilk="argument" name="self" /><variable citdl="self.module_path" line="1288" name="path" /><variable citdl="self.module_path" line="1289" name="old" /><variable line="1297" name="base" /></scope><variable attributes="__instancevar__" citdl="os.path.basename()" line="1292" name="egg_name" /><variable attributes="__instancevar__" citdl="os.path.join()" line="1293" name="egg_info" /><variable attributes="__instancevar__" citdl="self.module_path" line="1294" name="egg_root" /></scope><scope classrefs="EggProvider" doc="Provides access to package resources in the filesystem" ilk="class" line="1304" lineend="1324" name="DefaultProvider"><scope attributes="protected" ilk="function" line="1307" lineend="1308" name="_has" returns="os.path.exists()" signature="_has(path)"><variable citdl="DefaultProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope attributes="protected" ilk="function" line="1310" lineend="1311" name="_isdir" returns="os.path.isdir()" signature="_isdir(path)"><variable citdl="DefaultProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope attributes="protected" ilk="function" line="1313" lineend="1314" name="_listdir" returns="os.listdir()" signature="_listdir(path)"><variable citdl="DefaultProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><scope ilk="function" line="1316" lineend="1317" name="get_resource_stream" returns="open()" signature="get_resource_stream(manager, resource_name)"><variable citdl="DefaultProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1319" lineend="1324" name="_get" returns="stream.read()" signature="_get(path)"><variable citdl="DefaultProvider" ilk="argument" name="self" /><variable ilk="argument" name="path" /><variable citdl="open()" line="1320" name="stream" /></scope></scope><scope classrefs="NullProvider" doc="Provider that returns nothing for all requests" ilk="class" line="1337" lineend="1346" name="EmptyProvider"><variable attributes="protected" line="1340" name="_isdir" /><variable attributes="protected" line="1341" name="_get" /><variable attributes="protected" line="1342" name="_listdir" /><variable line="1343" name="module_path" /><scope attributes="__ctor__" ilk="function" line="1345" lineend="1346" name="__init__" signature="EmptyProvider()"><variable citdl="EmptyProvider" ilk="argument" name="self" /></scope></scope><variable citdl="EmptyProvider" line="1348" name="empty_provider" /><scope classrefs="EggProvider" doc="Resource support for zips and eggs" ilk="class" line="1353" lineend="1494" name="ZipProvider"><variable citdl="list" line="1356" name="eagers" /><scope attributes="__ctor__" ilk="function" line="1358" lineend="1361" name="__init__" signature="ZipProvider(module)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="module" /></scope><variable attributes="__instancevar__" line="1360" name="zipinfo" /><variable attributes="__instancevar__" citdl="self.loader.archive" line="1361" name="zip_pre" /><scope attributes="protected" ilk="function" line="1363" lineend="1369" name="_zipinfo_name" returns="list" signature="_zipinfo_name(fspath)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1372" lineend="1378" name="_parts" signature="_parts(zip_path)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="zip_path" /><variable citdl="self.loader.archive" line="1374" name="fspath" /></scope><scope ilk="function" line="1381" lineend="1392" name="get_resource_filename" returns="self._extract_resource()" signature="get_resource_filename(manager, resource_name)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="resource_name" /><variable citdl="self._resource_to_zip()" line="1387" name="zip_path" /><variable citdl="self._get_eager_resources()" line="1388" name="eagers" /></scope><scope attributes="protected" ilk="function" line="1394" lineend="1452" name="_extract_resource" returns="os.path.dirname()" signature="_extract_resource(manager, zip_path)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="manager" /><variable ilk="argument" name="zip_path" /><variable citdl="()" line="1398" name="last" /><variable line="1403" name="zip_stat" /><variable line="1404" name="d" /><variable line="1404" name="t" /><variable line="1404" name="size" /><variable citdl="tuple" line="1405" name="date_time" /><variable citdl="time.mktime()" line="1409" name="timestamp" /><variable citdl="manager.get_cache_path()" line="1416" name="real_path" /><variable citdl="os.stat()" line="1421" name="stat" /><variable line="1426" name="outf" /><variable line="1426" name="tmpnam" /></scope><scope attributes="protected" ilk="function" line="1454" lineend="1461" name="_get_eager_resources" returns="list" signature="_get_eager_resources()"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable citdl="list" line="1456" name="eagers" /></scope><scope attributes="protected" ilk="function" line="1463" lineend="1478" name="_index" returns="dict" signature="_index()"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable citdl="dict" line="1467" name="ind" /><variable citdl="path.split()" line="1469" name="parts" /><variable citdl="os.sep.join()" line="1471" name="parent" /></scope><variable attributes="protected __instancevar__" citdl="dict" line="1477" name="_dirindex" /><scope attributes="protected" ilk="function" line="1480" lineend="1482" name="_has" returns="bool" signature="_has(fspath)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="fspath" /><variable citdl="_zipinfo_name()" line="1481" name="zip_path" /></scope><scope attributes="protected" ilk="function" line="1484" lineend="1485" name="_isdir" returns="bool" signature="_isdir(fspath)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1487" lineend="1488" name="_listdir" returns="list()" signature="_listdir(fspath)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="fspath" /></scope><scope attributes="protected" ilk="function" line="1490" lineend="1491" name="_eager_to_zip" returns="ZipProvider._zipinfo_name()" signature="_eager_to_zip(resource_name)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="resource_name" /></scope><scope attributes="protected" ilk="function" line="1493" lineend="1494" name="_resource_to_zip" returns="ZipProvider._zipinfo_name()" signature="_resource_to_zip(resource_name)"><variable citdl="ZipProvider" ilk="argument" name="self" /><variable ilk="argument" name="resource_name" /></scope></scope><scope classrefs="EmptyProvider" doc="Metadata handler for standalone PKG-INFO files&#xA;&#xA;Usage::&#xA;&#xA;    metadata = FileMetadata(&quot;/path/to/PKG-INFO&quot;)&#xA;&#xA;This provider rejects all data and metadata requests except for PKG-INFO,&#xA;which is treated as existing, and will be the contents of the file at&#xA;the provided location." ilk="class" line="1521" lineend="1548" name="FileMetadata"><scope attributes="__ctor__" ilk="function" line="1533" lineend="1534" name="__init__" signature="FileMetadata(path)"><variable citdl="FileMetadata" ilk="argument" name="self" /><variable ilk="argument" name="path" /></scope><variable attributes="__instancevar__" line="1534" name="path" /><scope ilk="function" line="1536" lineend="1537" name="has_metadata" returns="bool" signature="has_metadata(name)"><variable citdl="FileMetadata" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="1539" lineend="1545" name="get_metadata" returns="f.read()" signature="get_metadata(name)"><variable citdl="FileMetadata" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable citdl="open()" line="1541" name="f" /><variable citdl="f.read()" line="1542" name="metadata" /></scope><scope ilk="function" line="1547" lineend="1548" name="get_metadata_lines" returns="yield_lines()" signature="get_metadata_lines(name)"><variable citdl="FileMetadata" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope></scope><scope classrefs="DefaultProvider" doc="Metadata provider for egg directories&#xA;&#xA;Usage::&#xA;&#xA;    # Development eggs:&#xA;&#xA;    egg_info = &quot;/path/to/PackageName.egg-info&quot;&#xA;    base_dir = os.path.dirname(egg_info)&#xA;    metadata = PathMetadata(base_dir, egg_info)&#xA;    dist_name = os.path.splitext(os.path.basename(egg_info))[0]&#xA;    dist = Distribution(basedir,project_name=dist_name,metadata=metadata)&#xA;&#xA;    # Unpacked egg directories:&#xA;&#xA;    egg_path = &quot;/path/to/PackageName-ver-pyver-etc.egg&quot;&#xA;    metadata = PathMetadata(egg_path, os.path.join(egg_path,&apos;EGG-INFO&apos;))&#xA;    dist = Distribution.from_filename(egg_path, metadata=metadata)" ilk="class" line="1565" lineend="1587" name="PathMetadata"><scope attributes="__ctor__" ilk="function" line="1585" lineend="1587" name="__init__" signature="PathMetadata(path, egg_info)"><variable citdl="PathMetadata" ilk="argument" name="self" /><variable ilk="argument" name="path" /><variable ilk="argument" name="egg_info" /></scope><variable attributes="__instancevar__" line="1586" name="module_path" /><variable attributes="__instancevar__" line="1587" name="egg_info" /></scope><scope classrefs="ZipProvider" doc="Metadata provider for .egg files" ilk="class" line="1590" lineend="1603" name="EggMetadata"><scope attributes="__ctor__" doc="Create a metadata provider from a zipimporter" ilk="function" line="1593" lineend="1603" name="__init__" signature="EggMetadata(importer)"><variable citdl="EggMetadata" ilk="argument" name="self" /><variable ilk="argument" name="importer" /></scope><variable attributes="__instancevar__" line="1596" name="zipinfo" /><variable attributes="__instancevar__" citdl="importer.archive" line="1597" name="zip_pre" /><variable attributes="__instancevar__" line="1598" name="loader" /><variable attributes="__instancevar__" citdl="importer.archive" line="1600" name="module_path" /></scope><variable citdl="ImpImporter" doc="PEP 302 Importer that wraps Python&apos;s &quot;normal&quot; import algorithm" line="1606" name="ImpWrapper" /><scope doc="PEP 302 Loader that wraps Python&apos;s &quot;normal&quot; import algorithm" ilk="class" line="1627" lineend="1642" name="ImpLoader"><scope attributes="__ctor__" ilk="function" line="1630" lineend="1633" name="__init__" signature="ImpLoader(file, filename, etc)"><variable citdl="ImpLoader" ilk="argument" name="self" /><variable ilk="argument" name="file" /><variable ilk="argument" name="filename" /><variable ilk="argument" name="etc" /></scope><variable attributes="__instancevar__" line="1631" name="file" /><variable attributes="__instancevar__" line="1632" name="filename" /><variable attributes="__instancevar__" line="1633" name="etc" /><scope ilk="function" line="1635" lineend="1642" name="load_module" returns="imp.load_module()" signature="load_module(fullname)"><variable citdl="ImpLoader" ilk="argument" name="self" /><variable ilk="argument" name="fullname" /><variable citdl="imp.load_module()" line="1637" name="mod" /></scope></scope><scope doc="Retrieve a PEP 302 &quot;importer&quot; for the given path item&#xA;&#xA;If there is no importer, this returns a wrapper around the builtin import&#xA;machinery.  The returned importer is only cached if it was created by a&#xA;path hook." ilk="function" line="1647" lineend="1673" name="get_importer" returns="hook()" signature="get_importer(path_item)"><variable ilk="argument" name="path_item" /><variable citdl="ImpWrapper" line="1655" name="importer" /></scope><scope doc="Register `distribution_finder` to find distributions in sys.path items&#xA;&#xA;`importer_type` is the type or class of a PEP 302 &quot;Importer&quot; (sys.path item&#xA;handler), and `distribution_finder` is a callable that, passed a path&#xA;item and the importer instance, yields ``Distribution`` instances found on&#xA;that path item.  See ``pkg_resources.find_on_path`` for an example." ilk="function" line="1690" lineend="1697" name="register_finder" signature="register_finder(importer_type, distribution_finder)"><variable ilk="argument" name="importer_type" /><variable ilk="argument" name="distribution_finder" /></scope><scope doc="Yield distributions accessible via `path_item`" ilk="function" line="1700" lineend="1704" name="find_distributions" returns="find_distributions.finder()" signature="find_distributions(path_item, only=False)"><variable ilk="argument" name="path_item" /><variable citdl="False" ilk="argument" name="only" /><variable citdl="get_importer()" line="1702" name="importer" /><variable citdl="_find_adapter()" line="1703" name="finder" /></scope><scope ilk="function" line="1706" lineend="1716" name="find_in_zip" signature="find_in_zip(importer, path_item, only=False)"><variable ilk="argument" name="importer" /><variable ilk="argument" name="path_item" /><variable citdl="False" ilk="argument" name="only" /><variable citdl="EggMetadata" line="1707" name="metadata" /><variable citdl="os.path.join()" line="1714" name="subpath" /></scope><scope doc="Thunk to load the real StringIO on demand" ilk="function" line="1720" lineend="1727" name="StringIO" returns="StringIO()" signature="StringIO(*args, **kw)"><import line="1724" module="cStringIO" symbol="StringIO" /><import line="1726" module="StringIO" symbol="StringIO" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope ilk="function" line="1729" lineend="1730" name="find_nothing" returns="tuple" signature="find_nothing(importer, path_item, only=False)"><variable ilk="argument" name="importer" /><variable ilk="argument" name="path_item" /><variable citdl="False" ilk="argument" name="only" /></scope><scope doc="Yield distributions accessible on a sys.path directory" ilk="function" line="1733" lineend="1767" name="find_on_path" signature="find_on_path(importer, path_item, only=False)"><variable ilk="argument" name="importer" /><variable citdl="_normalize_cached()" ilk="argument" name="path_item" /><variable citdl="False" ilk="argument" name="only" /><variable citdl="entry.lower()" line="1748" name="lower" /><variable citdl="os.path.join()" line="1750" name="fullpath" /><variable citdl="PathMetadata" line="1753" name="metadata" /></scope><scope doc="Register `namespace_handler` to declare namespace packages&#xA;&#xA;`importer_type` is the type or class of a PEP 302 &quot;Importer&quot; (sys.path item&#xA;handler), and `namespace_handler` is a callable like this::&#xA;&#xA;    def namespace_handler(importer,path_entry,moduleName,module):&#xA;        # return a path_entry to use for child packages&#xA;&#xA;Namespace handlers are only called if the importer object has already&#xA;agreed that it can handle the relevant path item, and they should only&#xA;return a subpath if the module __path__ does not already contain an&#xA;equivalent subpath.  For an example namespace handler, see&#xA;``pkg_resources.file_ns_handler``." ilk="function" line="1782" lineend="1797" name="register_namespace_handler" signature="register_namespace_handler(importer_type, namespace_handler)"><variable ilk="argument" name="importer_type" /><variable ilk="argument" name="namespace_handler" /></scope><scope attributes="protected" doc="Ensure that named package includes a subpath of path_item (if needed)" ilk="function" line="1799" lineend="1818" name="_handle_ns" returns="handler()" signature="_handle_ns(packageName, path_item)"><variable ilk="argument" name="packageName" /><variable ilk="argument" name="path_item" /><variable citdl="get_importer()" line="1801" name="importer" /><variable citdl="importer.find_module()" line="1804" name="loader" /><variable citdl="sys.modules.get()" line="1807" name="module" /><variable citdl="_find_adapter()" line="1813" name="handler" /><variable citdl="handler()" line="1814" name="subpath" /><variable citdl="list" line="1816" name="path" /></scope><scope doc="Declare that package &apos;packageName&apos; is a namespace package" ilk="function" line="1820" lineend="1850" name="declare_namespace" signature="declare_namespace(packageName)"><variable ilk="argument" name="packageName" /><variable citdl="sys.path" line="1828" name="path" /><variable citdl="__builtins__.str.join()" line="1828" name="parent" /></scope><scope doc="Ensure that previously-declared namespace packages include path_item" ilk="function" line="1852" lineend="1860" name="fixup_namespace_packages" signature="fixup_namespace_packages(path_item, parent=None)"><variable ilk="argument" name="path_item" /><variable ilk="argument" name="parent" /><variable citdl="_handle_ns()" line="1857" name="subpath" /></scope><scope doc="Compute an ns-package subpath for a filesystem or zipfile importer" ilk="function" line="1862" lineend="1872" name="file_ns_handler" returns="os.path.join()" signature="file_ns_handler(importer, path_item, packageName, module)"><variable ilk="argument" name="importer" /><variable ilk="argument" name="path_item" /><variable ilk="argument" name="packageName" /><variable ilk="argument" name="module" /><variable citdl="os.path.join()" line="1865" name="subpath" /><variable citdl="_normalize_cached()" line="1866" name="normalized" /></scope><scope ilk="function" line="1886" lineend="1887" name="null_ns_handler" signature="null_ns_handler(importer, path_item, packageName, module)"><variable ilk="argument" name="importer" /><variable ilk="argument" name="path_item" /><variable ilk="argument" name="packageName" /><variable ilk="argument" name="module" /></scope><scope doc="Normalize a file/dir name for comparison purposes" ilk="function" line="1892" lineend="1894" name="normalize_path" returns="os.path.normcase()" signature="normalize_path(filename)"><variable ilk="argument" name="filename" /></scope><scope attributes="protected" ilk="function" line="1896" lineend="1901" name="_normalize_cached" returns="result" signature="_normalize_cached(filename, _cache={})"><variable ilk="argument" name="filename" /><variable citdl="dict" ilk="argument" name="_cache" /></scope><scope attributes="protected" ilk="function" line="1903" lineend="1908" name="_set_parent_ns" signature="_set_parent_ns(packageName)"><variable ilk="argument" name="packageName" /><variable citdl="packageName.split()" line="1904" name="parts" /><variable citdl="parts.pop()" line="1905" name="name" /><variable citdl="__builtins__.str.join()" line="1907" name="parent" /></scope><scope doc="Yield non-empty/non-comment lines of a ``basestring`` or sequence" ilk="function" line="1911" lineend="1921" name="yield_lines" signature="yield_lines(strs)"><variable ilk="argument" name="strs" /><variable citdl="s.strip()" line="1915" name="s" /></scope><variable line="1923" name="LINE_END" /><variable line="1924" name="CONTINUE" /><variable line="1925" name="DISTRO" /><variable line="1926" name="VERSION" /><variable line="1927" name="COMMA" /><variable line="1928" name="OBRACKET" /><variable line="1929" name="CBRACKET" /><variable line="1930" name="MODULE" /><variable line="1931" name="EGG_NAME" /><variable citdl="re.compile()" line="1937" name="component_re" /><variable citdl="{}.get" line="1938" name="replace" /><scope attributes="protected" ilk="function" line="1940" lineend="1950" name="_parse_version_parts" signature="_parse_version_parts(s)"><variable ilk="argument" name="s" /><variable citdl="replace()" line="1942" name="part" /></scope><scope doc="Convert a version string to a chronologically-sortable key&#xA;&#xA;This is a rough cross between distutils&apos; StrictVersion and LooseVersion;&#xA;if you give it versions that would work with StrictVersion, then it behaves&#xA;the same; otherwise it acts like a slightly-smarter LooseVersion. It is&#xA;*possible* to create pathological version coding schemes that will fool&#xA;this parser, but they should be very rare in practice.&#xA;&#xA;The returned value will be a tuple of strings.  Numeric portions of the&#xA;version are padded to 8 digits so they will compare numerically, but&#xA;without relying on how numbers compare relative to strings.  Dots are&#xA;dropped, but dashes are retained.  Trailing zeros between alpha segments&#xA;or dashes are suppressed, so that e.g. &quot;2.4.0&quot; is considered the same as&#xA;&quot;2.4&quot;. Alphanumeric parts are lower-cased.&#xA;&#xA;The algorithm assumes that strings like &quot;-&quot; and any alpha string that&#xA;alphabetically follows &quot;final&quot;  represents a &quot;patch level&quot;.  So, &quot;2.4-1&quot;&#xA;is assumed to be a branch or patch of &quot;2.4&quot;, and therefore &quot;2.4.1&quot; is&#xA;considered newer than &quot;2.4-1&quot;, which in turn is newer than &quot;2.4&quot;.&#xA;&#xA;Strings like &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;candidate&quot; and so on (that&#xA;come before &quot;final&quot; alphabetically) are assumed to be pre-release versions,&#xA;so that the version &quot;2.4&quot; is considered newer than &quot;2.4a1&quot;.&#xA;&#xA;Finally, to handle miscellaneous cases, the strings &quot;pre&quot;, &quot;preview&quot;, and&#xA;&quot;rc&quot; are treated as if they were &quot;c&quot;, i.e. as though they were release&#xA;candidates, and therefore are not as new as a version string that does not&#xA;contain them, and &quot;dev&quot; is replaced with an &apos;@&apos; so that it sorts lower than&#xA;than any other pre-release tag." ilk="function" line="1952" lineend="1990" name="parse_version" returns="tuple()" signature="parse_version(s)"><variable ilk="argument" name="s" /><variable citdl="list" line="1983" name="parts" /></scope><scope classrefs="object" doc="Object representing an advertised importable object" ilk="class" line="1992" lineend="2108" name="EntryPoint"><scope attributes="__ctor__" ilk="function" line="1995" lineend="2002" name="__init__" signature="EntryPoint(name, module_name, attrs=(), extras=(), dist=None)"><variable citdl="EntryPoint" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable ilk="argument" name="module_name" /><variable citdl="tuple" ilk="argument" name="attrs" /><variable citdl="tuple" ilk="argument" name="extras" /><variable ilk="argument" name="dist" /></scope><variable attributes="__instancevar__" line="1998" name="name" /><variable attributes="__instancevar__" line="1999" name="module_name" /><variable attributes="__instancevar__" citdl="tuple()" line="2000" name="attrs" /><variable attributes="__instancevar__" line="2001" name="extras" /><variable attributes="__instancevar__" line="2002" name="dist" /><scope ilk="function" line="2004" lineend="2010" name="__str__" returns="tuple" signature="__str__()"><variable citdl="EntryPoint" ilk="argument" name="self" /><variable citdl="str" line="2005" name="s" /></scope><scope ilk="function" line="2012" lineend="2013" name="__repr__" returns="str" signature="__repr__()"><variable citdl="EntryPoint" ilk="argument" name="self" /></scope><scope ilk="function" line="2015" lineend="2023" name="load" returns="__import__()" signature="load(require=True, env=None, installer=None)"><variable citdl="EntryPoint" ilk="argument" name="self" /><variable citdl="True" ilk="argument" name="require" /><variable ilk="argument" name="env" /><variable ilk="argument" name="installer" /><variable citdl="getattr()" line="2017" name="entry" /></scope><scope ilk="function" line="2025" lineend="2029" name="require" signature="require(env=None, installer=None)"><variable citdl="EntryPoint" ilk="argument" name="self" /><variable ilk="argument" name="env" /><variable ilk="argument" name="installer" /></scope><scope doc="Parse a single entry point from string `src`&#xA;&#xA;Entry point syntax follows the form::&#xA;&#xA;    name = some.module:some.attr [extra1,extra2]&#xA;&#xA;The entry name and module name are required, but the ``:attrs`` and&#xA;``[extras]`` parts are optional" ilk="function" line="2065" lineend="2063" name="parse" returns="EntryPoint.parse.cls()" signature="parse(src, dist=None)"><variable citdl="EntryPoint" ilk="argument" name="cls" /><variable ilk="argument" name="src" /><variable ilk="argument" name="dist" /><variable citdl="tuple" line="2045" name="attrs" /><variable line="2046" name="name" /><variable line="2046" name="value" /><variable citdl="req.extras" line="2048" name="extras" /><variable citdl="Requirement.parse()" line="2049" name="req" /></scope><scope doc="Parse an entry point group" ilk="function" line="2087" lineend="2085" name="parse_group" returns="dict" signature="parse_group(group, lines, dist=None)"><variable citdl="EntryPoint" ilk="argument" name="cls" /><variable ilk="argument" name="group" /><variable ilk="argument" name="lines" /><variable ilk="argument" name="dist" /><variable citdl="dict" line="2079" name="this" /><variable citdl="parse()" line="2081" name="ep" /></scope><scope doc="Parse a map of entry point groups" ilk="function" line="2108" lineend="2106" name="parse_map" returns="dict" signature="parse_map(data, dist=None)"><variable citdl="EntryPoint" ilk="argument" name="cls" /><variable citdl="split_sections()" ilk="argument" name="data" /><variable ilk="argument" name="dist" /><variable citdl="dict" line="2096" name="maps" /><variable citdl="group.strip()" line="2102" name="group" /></scope></scope><scope attributes="protected" ilk="function" line="2111" lineend="2117" name="_remove_md5_fragment" returns="str" signature="_remove_md5_fragment(location)"><variable ilk="argument" name="location" /><variable citdl="urlparse()" line="2114" name="parsed" /></scope><scope classrefs="object" doc="Wrap an actual or potential sys.path entry w/metadata" ilk="class" line="2120" lineend="2445" name="Distribution"><variable citdl="str" line="2122" name="PKG_INFO" /><scope attributes="__ctor__" ilk="function" line="2124" lineend="2135" name="__init__" signature="Distribution(location=None, metadata=None, project_name=None, version=None, py_version=PY_MAJOR, platform=None, precedence=EGG_DIST)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="location" /><variable ilk="argument" name="metadata" /><variable ilk="argument" name="project_name" /><variable ilk="argument" name="version" /><variable citdl="list" ilk="argument" name="py_version" /><variable ilk="argument" name="platform" /><variable citdl="int" ilk="argument" name="precedence" /></scope><variable attributes="__instancevar__" citdl="safe_name()" line="2128" name="project_name" /><variable attributes="protected __instancevar__" citdl="safe_version()" line="2130" name="_version" /><variable attributes="__instancevar__" citdl="list" line="2131" name="py_version" /><variable attributes="__instancevar__" line="2132" name="platform" /><variable attributes="__instancevar__" line="2133" name="location" /><variable attributes="__instancevar__" citdl="int" line="2134" name="precedence" /><variable attributes="protected __instancevar__" citdl="EmptyProvider" line="2135" name="_provider" /><scope ilk="function" line="2153" lineend="2151" name="from_location" returns="Distribution.from_location.cls()" signature="from_location(location, basename, metadata=None, **kw)"><variable citdl="Distribution" ilk="argument" name="cls" /><variable ilk="argument" name="location" /><variable ilk="argument" name="basename" /><variable ilk="argument" name="metadata" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable line="2140" name="ext" /><variable citdl="EGG_NAME()" line="2143" name="match" /><variable line="2145" name="project_name" /><variable line="2145" name="platform" /><variable line="2145" name="version" /><variable line="2145" name="py_version" /></scope><variable citdl="property()" line="2156" name="hashcmp" /><scope ilk="function" line="2166" lineend="2166" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope ilk="function" line="2167" lineend="2168" name="__lt__" returns="bool" signature="__lt__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2169" lineend="2170" name="__le__" returns="bool" signature="__le__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2171" lineend="2172" name="__gt__" returns="bool" signature="__gt__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2173" lineend="2174" name="__ge__" returns="bool" signature="__ge__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2175" lineend="2179" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2180" lineend="2181" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><variable attributes="protected __instancevar__" citdl="self.project_name.lower()" line="2192" name="_key" /><scope ilk="function" line="2194" lineend="2193" name="key" returns="Distribution.key" signature="key()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><variable attributes="protected __instancevar__" citdl="parse_version()" line="2201" name="_parsed_version" /><scope ilk="function" line="2204" lineend="2202" name="parsed_version" returns="self._parsed_version" signature="parsed_version()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope ilk="function" line="2219" lineend="2217" name="version" returns="safe_version()" signature="version()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope attributes="protected" ilk="function" line="2235" lineend="2234" name="_dep_map" returns="self.__dep_map" signature="_dep_map()"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="dict" line="2229" name="dm" /><variable citdl="safe_extra()" line="2232" name="extra" /></scope><scope doc="List of Requirements needed for this distro if `extras` are used" ilk="function" line="2237" lineend="2249" name="requires" returns="list" signature="requires(extras=())"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="tuple" ilk="argument" name="extras" /><variable citdl="Distribution._dep_map" line="2239" name="dm" /><variable citdl="list" line="2240" name="deps" /></scope><scope attributes="protected" ilk="function" line="2251" lineend="2254" name="_get_metadata" signature="_get_metadata(name)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope doc="Ensure distribution is importable on `path` (default=sys.path)" ilk="function" line="2256" lineend="2262" name="activate" signature="activate(path=None)"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="sys.path" ilk="argument" name="path" /></scope><scope doc="Return what this distribution&apos;s standard .egg filename should be" ilk="function" line="2265" lineend="2274" name="egg_name" returns="tuple" signature="egg_name()"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="str" line="2267" name="filename" /></scope><scope ilk="function" line="2276" lineend="2280" name="__repr__" returns="tuple" signature="__repr__()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope ilk="function" line="2282" lineend="2286" name="__str__" returns="tuple" signature="__str__()"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="getattr()" line="2283" name="version" /></scope><scope doc="Delegate all unrecognized public attributes to .metadata provider" ilk="function" line="2288" lineend="2292" name="__getattr__" returns="getattr()" signature="__getattr__(attr)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="attr" /></scope><scope ilk="function" line="2300" lineend="2298" name="from_filename" returns="Distribution.from_location()" signature="from_filename(filename, metadata=None, **kw)"><variable citdl="Distribution" ilk="argument" name="cls" /><variable ilk="argument" name="filename" /><variable ilk="argument" name="metadata" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="Return a ``Requirement`` that matches this distribution exactly" ilk="function" line="2302" lineend="2304" name="as_requirement" returns="Requirement.parse()" signature="as_requirement()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope doc="Return the `name` entry point of `group` or raise ImportError" ilk="function" line="2306" lineend="2311" name="load_entry_point" returns="ep.load()" signature="load_entry_point(group, name)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="group" /><variable ilk="argument" name="name" /><variable citdl="self.get_entry_info()" line="2308" name="ep" /></scope><scope doc="Return the entry point map for `group`, or the full entry map" ilk="function" line="2313" lineend="2323" name="get_entry_map" returns="ep_map.get()" signature="get_entry_map(group=None)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="group" /><variable citdl="self._ep_map" line="2316" name="ep_map" /></scope><scope doc="Return the EntryPoint object for `group`+`name`, or ``None``" ilk="function" line="2325" lineend="2327" name="get_entry_info" signature="get_entry_info(group, name)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="group" /><variable ilk="argument" name="name" /></scope><scope doc="Insert self.location in path before its nearest parent directory" ilk="function" line="2347" name="insert_on" signature="insert_on(path, loc=None)"><variable citdl="Distribution" ilk="argument" name="self" /><variable ilk="argument" name="path" /><variable ilk="argument" name="loc" /><variable citdl="Distribution.version" line="2354" name="version" /><variable citdl="_normalize_cached()" line="2368" name="nloc" /><variable citdl="os.path.dirname()" line="2369" name="bdir" /><variable citdl="map()" line="2370" name="npath" /><variable line="2372" name="bp" /><variable citdl="npath.index()" line="2388" name="np" /><variable citdl="npath.index()" line="2393" name="p" /></scope><scope ilk="function" line="2399" lineend="2418" name="check_version_conflict" signature="check_version_conflict()"><variable citdl="Distribution" ilk="argument" name="self" /><variable citdl="dict.fromkeys()" line="2403" name="nsp" /><variable citdl="normalize_path()" line="2404" name="loc" /><variable citdl="getattr()" line="2412" name="fn" /></scope><scope ilk="function" line="2421" lineend="2427" name="has_version" returns="bool" signature="has_version()"><variable citdl="Distribution" ilk="argument" name="self" /></scope><scope doc="Copy this distribution, substituting in any changed keyword args" ilk="function" line="2429" lineend="2437" name="clone" returns="self.__class__()" signature="clone(**kw)"><variable citdl="Distribution" ilk="argument" name="self" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope ilk="function" line="2445" lineend="2444" name="extras" returns="list" signature="extras()"><variable citdl="Distribution" ilk="argument" name="self" /></scope></scope><scope classrefs="Distribution" doc="Wrap an actual or potential sys.path entry w/metadata, .dist-info style" ilk="class" line="2448" lineend="2516" name="DistInfoDistribution"><variable citdl="str" line="2450" name="PKG_INFO" /><variable citdl="re.compile()" line="2451" name="EQEQ" /><variable attributes="property protected" citdl="self._pkg_info" line="2454" name="_parsed_pkg_info" /><scope attributes="protected __hidden__" doc="Parse and cache metadata" ilk="function" line="2454" lineend="2461" name="_parsed_pkg_info (property getter)" returns="self._pkg_info" signature="_parsed_pkg_info (property getter)()"><import line="2459" module="email.parser" symbol="Parser" /><variable citdl="DistInfoDistribution" ilk="argument" name="self" /></scope><variable attributes="protected __instancevar__" line="2460" name="_pkg_info" /><variable attributes="property protected" citdl="self.__dep_map" line="2464" name="_dep_map" /><scope attributes="protected __hidden__" ilk="function" line="2464" lineend="2469" name="_dep_map (property getter)" returns="self._compute_dependencies()" signature="_dep_map (property getter)()"><variable citdl="DistInfoDistribution" ilk="argument" name="self" /></scope><variable attributes="private __instancevar__" citdl="self._compute_dependencies()" line="2468" name="__dep_map" /><scope attributes="protected" doc="Convert &apos;Foobar (1); baz&apos; to (&apos;Foobar ==1&apos;, &apos;baz&apos;)&#xA;Split environment marker, add == prefix to version specifiers as &#xA;necessary, and remove parenthesis." ilk="function" line="2471" lineend="2481" name="_preparse_requirement" returns="tuple" signature="_preparse_requirement(requires_dist)"><variable citdl="DistInfoDistribution" ilk="argument" name="self" /><variable ilk="argument" name="requires_dist" /><variable citdl="requires_dist.split()" line="2476" name="parts" /><variable citdl="re.sub()" line="2477" name="distvers" /><variable line="2478" name="mark" /></scope><scope attributes="protected" doc="Recompute this distribution&apos;s dependencies." ilk="function" line="2483" lineend="2516" name="_compute_dependencies" returns="dict" signature="_compute_dependencies()"><import line="2491" module="markerlib" symbol="as_function" /><variable citdl="DistInfoDistribution" ilk="argument" name="self" /><scope ilk="function" line="2485" lineend="2489" name="dummy_marker" returns="DistInfoDistribution._compute_dependencies.dummy_marker.marker_fn" signature="dummy_marker(marker)"><variable ilk="argument" name="marker" /><scope ilk="function" line="2486" lineend="2487" name="marker_fn" returns="bool" signature="marker_fn(environment=None, override=None)"><variable ilk="argument" name="environment" /><variable ilk="argument" name="override" /><variable line="2488" name="__doc__" /></scope></scope><variable citdl="DistInfoDistribution._compute_dependencies.dummy_marker" line="2493" name="as_function" /><variable citdl="dict" line="2494" name="dm" /><variable citdl="list" line="2496" name="reqs" /><variable line="2499" name="distvers" /><variable line="2499" name="mark" /><variable line="2500" name="parsed" /><scope ilk="function" line="2504" lineend="2507" name="reqs_for_extra" signature="reqs_for_extra(extra)"><variable ilk="argument" name="extra" /></scope><variable citdl="set()" line="2509" name="common" /><variable citdl="safe_extra()" line="2513" name="extra" /></scope></scope><variable attributes="protected" citdl="dict" line="2519" name="_distributionImpl" /><scope ilk="function" line="2524" lineend="2535" name="issue_warning" signature="issue_warning(*args, **kw)"><import line="2534" module="warnings" symbol="warn" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="int" line="2525" name="level" /><variable citdl="globals()" line="2526" name="g" /></scope><scope doc="Yield ``Requirement`` objects for each specification in `strs`&#xA;&#xA;`strs` must be an instance of ``basestring``, or a (possibly-nested)&#xA;iterable thereof." ilk="function" line="2559" lineend="2617" name="parse_requirements" signature="parse_requirements(strs)"><variable ilk="argument" name="strs" /><variable citdl="iter()" line="2566" name="lines" /><scope ilk="function" line="2568" lineend="2598" name="scan_list" returns="tuple" signature="scan_list(ITEM, TERMINATOR, line, p, groups, item_name)"><variable ilk="argument" name="ITEM" /><variable ilk="argument" name="TERMINATOR" /><variable citdl="lines.next()" ilk="argument" name="line" /><variable citdl="match.end()" ilk="argument" name="p" /><variable ilk="argument" name="groups" /><variable ilk="argument" name="item_name" /><variable citdl="list" line="2570" name="items" /><variable citdl="ITEM()" line="2581" name="match" /></scope><variable citdl="DISTRO()" line="2601" name="match" /><variable citdl="match.group()" line="2604" name="project_name" /><variable citdl="match.end()" line="2605" name="p" /><variable citdl="list" line="2606" name="extras" /><variable line="2611" name="line" /><variable citdl="list" line="2615" name="specs" /></scope><scope attributes="protected" ilk="function" line="2620" lineend="2623" name="_sort_dists" signature="_sort_dists(dists)"><variable ilk="argument" name="dists" /><variable citdl="list" line="2621" name="tmp" /></scope><scope ilk="class" line="2641" lineend="2708" name="Requirement"><scope attributes="__ctor__" doc="DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!" ilk="function" line="2642" lineend="2654" name="__init__" signature="Requirement(project_name, specs, extras)"><variable citdl="Requirement" ilk="argument" name="self" /><variable citdl="safe_name()" ilk="argument" name="project_name" /><variable ilk="argument" name="specs" /><variable ilk="argument" name="extras" /><variable citdl="list" line="2646" name="index" /></scope><variable attributes="__instancevar__" line="2644" name="unsafe_name" /><variable attributes="__instancevar__" citdl="safe_name()" line="2645" name="project_name" /><variable attributes="__instancevar__" citdl="project_name.lower()" line="2645" name="key" /><variable attributes="__instancevar__" citdl="list" line="2648" name="specs" /><variable attributes="__instancevar__" citdl="list" line="2649" name="index" /><variable attributes="__instancevar__" citdl="tuple()" line="2649" name="extras" /><variable attributes="__instancevar__" citdl="tuple" line="2650" name="hashCmp" /><variable attributes="private __instancevar__" citdl="hash()" line="2654" name="__hash" /><scope ilk="function" line="2656" lineend="2660" name="__str__" returns="tuple" signature="__str__()"><variable citdl="Requirement" ilk="argument" name="self" /><variable citdl="__builtins__.str.join()" line="2657" name="specs" /><variable citdl="__builtins__.str.join()" line="2658" name="extras" /></scope><scope ilk="function" line="2662" lineend="2663" name="__eq__" returns="isinstance()" signature="__eq__(other)"><variable citdl="Requirement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2665" lineend="2680" name="__contains__" returns="bool" signature="__contains__(item)"><variable citdl="Requirement" ilk="argument" name="self" /><variable citdl="parse_version()" ilk="argument" name="item" /><variable citdl="True" line="2671" name="last" /><variable line="2672" name="compare" /><variable line="2674" name="action" /></scope><scope ilk="function" line="2683" lineend="2684" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="Requirement" ilk="argument" name="self" /></scope><scope ilk="function" line="2686" lineend="2686" name="__repr__" returns="str" signature="__repr__()"><variable citdl="Requirement" ilk="argument" name="self" /></scope><scope ilk="function" line="2708" lineend="2706" name="parse" signature="parse(replacement=True)"><variable citdl="Requirement" ilk="argument" name="s" /><variable citdl="True" ilk="argument" name="replacement" /><variable citdl="list()" line="2690" name="reqs" /><variable line="2693" name="founded_req" /><variable citdl="list()" line="2698" name="distribute" /></scope></scope><variable citdl="dict" line="2710" name="state_machine" /><scope attributes="protected" doc="Return True when distribute wants to override a setuptools dependency.&#xA;&#xA;We want to override when the requirement is setuptools and the version is&#xA;a variant of 0.6.&#xA;" ilk="function" line="2721" lineend="2738" name="_override_setuptools" returns="bool" signature="_override_setuptools(req)"><variable ilk="argument" name="req" /></scope><scope attributes="protected" doc="Get an mro for a type or classic class" ilk="function" line="2741" lineend="2746" name="_get_mro" returns="cls.__mro__" signature="_get_mro(cls)"><variable ilk="argument" name="cls" /></scope><scope attributes="protected" doc="Return an adapter factory for `ob` from `registry`" ilk="function" line="2748" lineend="2752" name="_find_adapter" signature="_find_adapter(registry, ob)"><variable ilk="argument" name="registry" /><variable ilk="argument" name="ob" /></scope><scope doc="Ensure that the parent directory of `path` exists" ilk="function" line="2755" lineend="2759" name="ensure_directory" signature="ensure_directory(path)"><variable ilk="argument" name="path" /><variable citdl="os.path.dirname()" line="2757" name="dirname" /></scope><scope doc="Split a string or iterable thereof into (section,content) pairs&#xA;&#xA;Each ``section`` is a stripped version of the section header (&quot;[section]&quot;)&#xA;and each ``content`` is a list of stripped lines excluding blank lines and&#xA;comment-only lines.  If there are any such lines before the first section&#xA;header, they&apos;re returned in a first ``section`` of ``None``." ilk="function" line="2761" lineend="2784" name="split_sections" signature="split_sections(s)"><variable ilk="argument" name="s" /><variable line="2769" name="section" /><variable citdl="list" line="2770" name="content" /></scope><scope attributes="protected" ilk="function" line="2786" lineend="2793" name="_mkstemp" returns="mkstemp()" signature="_mkstemp(*args, **kw)"><import line="2787" module="tempfile" symbol="mkstemp" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="os.open" line="2788" name="old_open" /></scope><variable attributes="protected" citdl="ResourceManager" line="2797" name="_manager" /><scope attributes="protected" ilk="function" line="2798" lineend="2801" name="_initialize" signature="_initialize(g)"><variable ilk="argument" name="g" /></scope><variable citdl="WorkingSet" line="2817" name="working_set" /><variable citdl="working_set.require" line="2827" name="require" /><variable citdl="working_set.iter_entry_points" line="2828" name="iter_entry_points" /><variable citdl="working_set.subscribe" line="2829" name="add_activation_listener" /></scope>