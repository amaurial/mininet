<scope ilk="blob" lang="Python" name="pyparsing" src="/usr/lib/python2.7/dist-packages/pyparsing.py"><import line="65" module="string" /><import alias="wkref" line="66" module="weakref" symbol="ref" /><import line="67" module="copy" /><import line="68" module="sys" /><import line="69" module="warnings" /><import line="70" module="re" /><import line="71" module="sre_constants" /><import line="142" module="__builtin__" /><variable citdl="str" line="26" name="__doc__" /><variable citdl="str" line="61" name="__version__" /><variable citdl="str" line="62" name="__versionTime__" /><variable citdl="str" line="63" name="__author__" /><variable citdl="list" line="74" name="__all__" /><variable attributes="protected" citdl="bool" line="98" name="_PY3K" /><variable attributes="protected" citdl="sys.maxsize" line="100" name="_MAX_INT" /><variable citdl="str" line="101" name="basestring" /><variable citdl="chr" line="102" name="unichr" /><variable citdl="string.uppercase" line="104" name="alphas" /><variable citdl="xrange" line="107" name="range" /><variable line="108" name="set" /><scope attributes="protected" doc="Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries&#xA;str(obj). If that fails with a UnicodeEncodeError, then it tries unicode(obj). It&#xA;then &lt; returns the unicode object | encodes it with the default encoding | ... &gt;." ilk="function" line="111" lineend="130" name="_ustr" returns="unicode()" signature="_ustr(obj)"><variable ilk="argument" name="obj" /></scope><variable citdl="list" line="141" name="singleArgBuiltins" /><scope attributes="protected" doc="Escape &amp;, &lt;, &gt;, &quot;, &apos;, etc. in a string of data." ilk="function" line="149" lineend="157" name="_xml_escape" returns="data.replace()" signature="_xml_escape(data)"><variable citdl="data.replace()" ilk="argument" name="data" /><variable citdl="str" line="153" name="from_symbols" /><variable citdl="list" line="154" name="to_symbols" /></scope><scope attributes="protected" classrefs="object" ilk="class" line="159" lineend="160" name="_Constants" /><variable citdl="string.digits" line="162" name="nums" /><variable citdl="string.digits" line="163" name="hexnums" /><variable citdl="string.digits" line="164" name="alphanums" /><variable attributes="protected" citdl="chr()" line="165" name="_bslash" /><variable citdl="__builtins__.str.join()" line="166" name="printables" /><scope classrefs="Exception" doc="base exception class for all parsing runtime exceptions" ilk="class" line="168" lineend="213" name="ParseBaseException"><scope attributes="__ctor__" ilk="function" line="172" lineend="180" name="__init__" signature="ParseBaseException(pstr, loc=0, msg=None, elem=None)"><variable citdl="ParseBaseException" ilk="argument" name="self" /><variable ilk="argument" name="pstr" /><variable citdl="int" ilk="argument" name="loc" /><variable ilk="argument" name="msg" /><variable ilk="argument" name="elem" /></scope><variable attributes="__instancevar__" citdl="int" line="173" name="loc" /><variable attributes="__instancevar__" line="175" name="msg" /><variable attributes="__instancevar__" citdl="str" line="176" name="pstr" /><variable attributes="__instancevar__" line="180" name="parserElement" /><scope doc="supported attributes by name are:&#xA;- lineno - returns the line number of the exception text&#xA;- col - returns the column number of the exception text&#xA;- line - returns the line containing the exception text" ilk="function" line="182" lineend="195" name="__getattr__" returns="col()" signature="__getattr__(aname)"><variable citdl="ParseBaseException" ilk="argument" name="self" /><variable ilk="argument" name="aname" /></scope><scope ilk="function" line="197" lineend="199" name="__str__" returns="tuple" signature="__str__()"><variable citdl="ParseBaseException" ilk="argument" name="self" /></scope><scope ilk="function" line="200" lineend="201" name="__repr__" returns="_ustr()" signature="__repr__()"><variable citdl="ParseBaseException" ilk="argument" name="self" /></scope><scope doc="Extracts the exception line from the input string, and marks&#xA;the location of the exception with a special symbol." ilk="function" line="202" lineend="211" name="markInputline" returns="line_str.strip()" signature="markInputline(markerString=&apos;&gt;!&lt;&apos;)"><variable citdl="ParseBaseException" ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="markerString" /><variable citdl="self.line" line="206" name="line_str" /><variable citdl="self.column" line="207" name="line_column" /></scope><scope ilk="function" line="212" lineend="213" name="__dir__" returns="__builtins__.str.split()" signature="__dir__()"><variable citdl="ParseBaseException" ilk="argument" name="self" /></scope></scope><scope classrefs="ParseBaseException" doc="exception thrown when parse expressions don&apos;t match class;&#xA;supported attributes by name are:&#xA; - lineno - returns the line number of the exception text&#xA; - col - returns the column number of the exception text&#xA; - line - returns the line containing the exception text" ilk="class" line="216" lineend="223" name="ParseException" /><scope classrefs="ParseBaseException" doc="user-throwable exception thrown when inconsistent parse content&#xA;is found; stops all parsing immediately" ilk="class" line="225" lineend="228" name="ParseFatalException" /><scope classrefs="ParseFatalException" doc="just like C{ParseFatalException}, but thrown internally when an&#xA;C{ErrorStop} (&apos;-&apos; operator) indicates that parsing is to stop immediately because&#xA;an unbacktrackable syntax error has been found" ilk="class" line="230" lineend="236" name="ParseSyntaxException"><scope attributes="__ctor__" ilk="function" line="234" lineend="236" name="__init__" signature="ParseSyntaxException(pe)"><variable citdl="ParseSyntaxException" ilk="argument" name="self" /><variable ilk="argument" name="pe" /></scope></scope><scope classrefs="Exception" doc="exception thrown by C{validate()} if the grammar could be improperly recursive" ilk="class" line="251" lineend="257" name="RecursiveGrammarException"><scope attributes="__ctor__" ilk="function" line="253" lineend="254" name="__init__" signature="RecursiveGrammarException(parseElementList)"><variable citdl="RecursiveGrammarException" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /></scope><variable attributes="__instancevar__" line="254" name="parseElementTrace" /><scope ilk="function" line="256" lineend="257" name="__str__" returns="str" signature="__str__()"><variable citdl="RecursiveGrammarException" ilk="argument" name="self" /></scope></scope><scope attributes="protected" classrefs="object" ilk="class" line="259" lineend="267" name="_ParseResultsWithOffset"><scope attributes="__ctor__" ilk="function" line="260" lineend="261" name="__init__" signature="_ParseResultsWithOffset(p1, p2)"><variable citdl="_ParseResultsWithOffset" ilk="argument" name="self" /><variable ilk="argument" name="p1" /><variable ilk="argument" name="p2" /></scope><variable attributes="__instancevar__" citdl="tuple" line="261" name="tup" /><scope ilk="function" line="262" lineend="263" name="__getitem__" signature="__getitem__(i)"><variable citdl="_ParseResultsWithOffset" ilk="argument" name="self" /><variable ilk="argument" name="i" /></scope><scope ilk="function" line="264" lineend="265" name="__repr__" returns="repr()" signature="__repr__()"><variable citdl="_ParseResultsWithOffset" ilk="argument" name="self" /></scope><scope ilk="function" line="266" lineend="267" name="setOffset" signature="setOffset(i)"><variable citdl="_ParseResultsWithOffset" ilk="argument" name="self" /><variable ilk="argument" name="i" /></scope></scope><scope classrefs="object" doc="Structured parse results, to provide multiple means of access to the parsed data:&#xA;- as a list (C{len(results)})&#xA;- by list index (C{results[0], results[1]}, etc.)&#xA;- by attribute (C{results.&lt;resultsName&gt;})" ilk="class" line="269" lineend="619" name="ParseResults"><scope ilk="function" line="276" lineend="281" name="__new__" returns="object.__new__()" signature="__new__(toklist, name=None, asList=True, modal=True)"><variable citdl="ParseResults" ilk="argument" name="cls" /><variable ilk="argument" name="toklist" /><variable ilk="argument" name="name" /><variable citdl="True" ilk="argument" name="asList" /><variable citdl="True" ilk="argument" name="modal" /><variable citdl="object.__new__()" line="279" name="retobj" /></scope><scope attributes="__ctor__" ilk="function" line="285" lineend="316" name="__init__" signature="ParseResults(toklist, name=None, asList=True, modal=True, isinstance=isinstance)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="toklist" /><variable citdl="_ustr()" ilk="argument" name="name" /><variable citdl="True" ilk="argument" name="asList" /><variable citdl="True" ilk="argument" name="modal" /><variable citdl="isinstance" ilk="argument" name="isinstance" /></scope><variable attributes="private __instancevar__" citdl="False" line="287" name="__doinit" /><variable attributes="private __instancevar__" citdl="_ustr()" line="288" name="__name" /><variable attributes="private __instancevar__" citdl="wkref()" line="289" name="__parent" /><variable attributes="private __instancevar__" citdl="dict" line="290" name="__accumNames" /><variable attributes="private __instancevar__" citdl="list" line="292" name="__toklist" /><variable attributes="private __instancevar__" citdl="dict()" line="295" name="__tokdict" /><scope ilk="function" line="318" lineend="325" name="__getitem__" returns="ParseResults" signature="__getitem__(i)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="i" /></scope><scope ilk="function" line="327" lineend="338" name="__setitem__" signature="__setitem__(k, v, isinstance=isinstance)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="k" /><variable ilk="argument" name="v" /><variable citdl="isinstance" ilk="argument" name="isinstance" /><variable line="330" name="sub" /></scope><scope ilk="function" line="340" lineend="360" name="__delitem__" signature="__delitem__(i)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="slice()" ilk="argument" name="i" /><variable citdl="len()" line="342" name="mylen" /><variable citdl="list()" line="351" name="removed" /><variable line="355" name="occurrences" /></scope><scope ilk="function" line="362" lineend="363" name="__contains__" returns="bool" signature="__contains__(k)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="k" /></scope><scope ilk="function" line="365" lineend="365" name="__len__" returns="len()" signature="__len__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope ilk="function" line="366" lineend="366" name="__bool__" returns="bool" signature="__bool__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><variable citdl="ParseResults.__bool__" line="367" name="__nonzero__" /><scope ilk="function" line="368" lineend="368" name="__iter__" returns="iter()" signature="__iter__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope ilk="function" line="369" lineend="369" name="__reversed__" returns="iter()" signature="__reversed__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope doc="Returns all named result keys." ilk="function" line="370" lineend="372" name="keys" returns="self.__tokdict.keys()" signature="keys()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope doc="Removes and returns item at specified index (default=last).&#xA;Will work with either numeric indices or dict-key indicies." ilk="function" line="374" lineend="379" name="pop" signature="pop(index=-1)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="int" ilk="argument" name="index" /><variable line="377" name="ret" /></scope><scope doc="Returns named result matching the given key, or if there is no&#xA;such name, then returns the given C{defaultValue} or C{None} if no&#xA;C{defaultValue} is specified." ilk="function" line="381" lineend="388" name="get" signature="get(key, defaultValue=None)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="key" /><variable ilk="argument" name="defaultValue" /></scope><scope doc="Inserts new element at location index in the list of parsed tokens." ilk="function" line="390" lineend="397" name="insert" signature="insert(index, insStr)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="index" /><variable ilk="argument" name="insStr" /><variable line="395" name="occurrences" /></scope><scope doc="Returns all named result keys and values as a list of tuples." ilk="function" line="399" lineend="401" name="items" returns="list" signature="items()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope doc="Returns all named result values." ilk="function" line="403" lineend="405" name="values" returns="list" signature="values()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope ilk="function" line="407" lineend="416" name="__getattr__" returns="str" signature="__getattr__(name)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope ilk="function" line="418" lineend="421" name="__add__" returns="self.copy()" signature="__add__(other)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="other" /><variable citdl="self.copy()" line="419" name="ret" /></scope><scope ilk="function" line="423" lineend="437" name="__iadd__" returns="ParseResults" signature="__iadd__(other)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="other" /><variable citdl="len()" line="425" name="offset" /><variable line="426" name="addoffset" /><variable citdl="other.__tokdict.items()" line="427" name="otheritems" /><variable citdl="list" line="428" name="otherdictitems" /></scope><scope ilk="function" line="439" lineend="441" name="__radd__" returns="self.copy()" signature="__radd__(other)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="443" lineend="444" name="__repr__" returns="tuple" signature="__repr__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope ilk="function" line="446" lineend="456" name="__str__" returns="str" signature="__str__()"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="str" line="447" name="out" /><variable citdl="str" line="448" name="sep" /></scope><scope attributes="protected" ilk="function" line="458" lineend="467" name="_asStringList" returns="list" signature="_asStringList(sep=&apos;&apos;)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="sep" /><variable citdl="list" line="459" name="out" /></scope><scope doc="Returns the parse results as a nested list of matching tokens, all converted to strings." ilk="function" line="469" lineend="477" name="asList" returns="list" signature="asList()"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="list" line="471" name="out" /></scope><scope doc="Returns the named parse results as dictionary." ilk="function" line="479" lineend="481" name="asDict" returns="dict()" signature="asDict()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope doc="Returns a new copy of a C{ParseResults} object." ilk="function" line="483" lineend="490" name="copy" signature="copy()"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="" line="485" name="ret" /></scope><scope doc="Returns the parse results as XML. Tags are created for tokens and lists that have defined results names." ilk="function" line="492" lineend="550" name="asXML" returns="str" signature="asXML(doctag=None, namedItemsOnly=False, indent=&apos;&apos;, formatted=True)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="doctag" /><variable citdl="False" ilk="argument" name="namedItemsOnly" /><variable citdl="str" ilk="argument" name="indent" /><variable citdl="True" ilk="argument" name="formatted" /><variable citdl="str" line="494" name="nl" /><variable citdl="list" line="495" name="out" /><variable citdl="dict()" line="496" name="namedItems" /><variable citdl="str" line="498" name="nextLevelIndent" /><variable citdl="_ustr()" line="506" name="selfTag" /><variable citdl="list" line="521" name="worklist" /><variable citdl="str" line="536" name="resTag" /><variable citdl="_xml_escape()" line="544" name="xmlBodyText" /></scope><scope attributes="private" ilk="function" line="552" lineend="557" name="__lookup" returns="k" signature="__lookup(sub)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="sub" /></scope><scope doc="Returns the results name for this token expression." ilk="function" line="559" lineend="574" name="getName" returns="par.__lookup()" signature="getName()"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="__parent()" line="564" name="par" /></scope><scope doc="Diagnostic method for listing out the contents of a C{ParseResults}.&#xA;Accepts an optional C{indent} argument so that this string can be embedded&#xA;in a nested display of other data." ilk="function" line="576" lineend="595" name="dump" returns="__builtins__.str.join()" signature="dump(indent=&apos;&apos;, depth=0)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="indent" /><variable citdl="int" ilk="argument" name="depth" /><variable citdl="list" line="580" name="out" /><variable citdl="items()" line="582" name="keys" /></scope><scope ilk="function" line="598" lineend="603" name="__getstate__" returns="tuple" signature="__getstate__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope><scope ilk="function" line="605" lineend="616" name="__setstate__" signature="__setstate__(state)"><variable citdl="ParseResults" ilk="argument" name="self" /><variable ilk="argument" name="state" /></scope><scope ilk="function" line="618" lineend="619" name="__dir__" returns="ParseResults.keys()" signature="__dir__()"><variable citdl="ParseResults" ilk="argument" name="self" /></scope></scope><scope doc="Returns current column within a string, counting newlines as line separators.&#xA;The first column is number 1.&#xA;&#xA;Note: the default parsing behavior is to expand tabs in the input string&#xA;before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information&#xA;on parsing strings containing &lt;TAB&gt;s, and suggested methods to maintain a&#xA;consistent view of the parsed string, the parse location, and line and column&#xA;positions within the parsed string." ilk="function" line="621" lineend="631" name="col" returns="bool" signature="col(loc, strg)"><variable ilk="argument" name="loc" /><variable ilk="argument" name="strg" /></scope><scope doc="Returns current line number within a string, counting newlines as line separators.&#xA;The first line is number 1.&#xA;&#xA;Note: the default parsing behavior is to expand tabs in the input string&#xA;before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information&#xA;on parsing strings containing &lt;TAB&gt;s, and suggested methods to maintain a&#xA;consistent view of the parsed string, the parse location, and line and column&#xA;positions within the parsed string." ilk="function" line="633" lineend="643" name="lineno" returns="strg.count()" signature="lineno(loc, strg)"><variable ilk="argument" name="loc" /><variable ilk="argument" name="strg" /></scope><scope doc="Returns the line of text containing loc within a string, counting newlines as line separators.&#xA;       " ilk="function" line="645" lineend="653" name="line" returns="list" signature="line(loc, strg)"><variable ilk="argument" name="loc" /><variable ilk="argument" name="strg" /><variable citdl="strg.rfind()" line="648" name="lastCR" /><variable citdl="strg.find()" line="649" name="nextCR" /></scope><scope attributes="protected" ilk="function" line="655" lineend="656" name="_defaultStartDebugAction" signature="_defaultStartDebugAction(instring, loc, expr)"><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="expr" /></scope><scope attributes="protected" ilk="function" line="658" lineend="659" name="_defaultSuccessDebugAction" signature="_defaultSuccessDebugAction(instring, startloc, endloc, expr, toks)"><variable ilk="argument" name="instring" /><variable ilk="argument" name="startloc" /><variable ilk="argument" name="endloc" /><variable ilk="argument" name="expr" /><variable ilk="argument" name="toks" /></scope><scope attributes="protected" ilk="function" line="661" lineend="662" name="_defaultExceptionDebugAction" signature="_defaultExceptionDebugAction(instring, loc, expr, exc)"><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="expr" /><variable ilk="argument" name="exc" /></scope><scope doc="&apos;Do-nothing&apos; debug action, to suppress debugging output during parsing." ilk="function" line="664" lineend="666" name="nullDebugAction" signature="nullDebugAction(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope attributes="protected" ilk="function" line="683" lineend="695" name="_trim_arity" returns="_trim_arity.wrapper" signature="_trim_arity(func, maxargs=2)"><variable ilk="argument" name="func" /><variable citdl="int" ilk="argument" name="maxargs" /><variable citdl="int" line="684" name="limit" /><scope ilk="function" line="685" lineend="694" name="wrapper" returns="_trim_arity.func()" signature="wrapper(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope></scope><scope classrefs="object" doc="Abstract base level parser element class." ilk="class" line="697" lineend="1448" name="ParserElement"><variable citdl="ParserElement" line="699" name="DEFAULT_WHITE_CHARS" /><variable citdl="False" line="700" name="verbose_stacktrace" /><scope doc="Overrides the default whitespace chars&#xA;        " ilk="function" line="706" lineend="705" name="setDefaultWhitespaceChars" signature="setDefaultWhitespaceChars()"><variable citdl="ParserElement" ilk="argument" name="chars" /></scope><scope attributes="__ctor__" ilk="function" line="708" lineend="729" name="__init__" signature="ParserElement(savelist=False)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="list()" line="709" name="parseAction" /><variable attributes="__instancevar__" line="710" name="failAction" /><variable attributes="__instancevar__" line="712" name="strRepr" /><variable attributes="__instancevar__" line="713" name="resultsName" /><variable attributes="__instancevar__" citdl="False" line="714" name="saveAsList" /><variable attributes="__instancevar__" citdl="True" line="715" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="716" name="whiteChars" /><variable attributes="__instancevar__" citdl="False" line="717" name="copyDefaultWhiteChars" /><variable attributes="__instancevar__" citdl="False" line="718" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="True" line="719" name="keepTabs" /><variable attributes="__instancevar__" citdl="list()" line="720" name="ignoreExprs" /><variable attributes="__instancevar__" citdl="True" line="721" name="debug" /><variable attributes="__instancevar__" citdl="True" line="722" name="streamlined" /><variable attributes="__instancevar__" citdl="True" line="723" name="mayIndexError" /><variable attributes="__instancevar__" citdl="str" line="724" name="errmsg" /><variable attributes="__instancevar__" citdl="True" line="725" name="modalResults" /><variable attributes="__instancevar__" citdl="tuple" line="726" name="debugActions" /><variable attributes="__instancevar__" line="727" name="re" /><variable attributes="__instancevar__" citdl="True" line="728" name="callPreparse" /><variable attributes="__instancevar__" citdl="False" line="729" name="callDuringTry" /><scope doc="Make a copy of this C{ParserElement}.  Useful for defining different parse actions&#xA;for the same parsing pattern, using copies of the original parse element." ilk="function" line="731" lineend="739" name="copy" returns="copy.copy()" signature="copy()"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="copy.copy()" line="734" name="cpy" /></scope><scope doc="Define name for this expression, for use in debugging." ilk="function" line="741" lineend="747" name="setName" returns="ParserElement" signature="setName(name)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><variable attributes="__instancevar__" line="743" name="name" /><scope doc="Define name for referencing matching tokens as a nested attribute&#xA;of the returned parse results.&#xA;NOTE: this returns a *copy* of the original C{ParserElement} object;&#xA;this is so that the client can define a basic element, such as an&#xA;integer, and reference it in multiple places with different names.&#xA;&#xA;You can also set results names using the abbreviated syntax,&#xA;C{expr(&quot;name&quot;)} in place of C{expr.setResultsName(&quot;name&quot;)} - &#xA;see L{I{__call__}&lt;__call__&gt;}." ilk="function" line="749" lineend="766" name="setResultsName" returns="copy()" signature="setResultsName(name, listAllMatches=False)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="name" /><variable citdl="False" ilk="argument" name="listAllMatches" /><variable citdl="copy()" line="760" name="newself" /></scope><scope doc="Method to invoke the Python pdb debugger when this element is&#xA;about to be parsed. Set C{breakFlag} to True to enable, False to&#xA;disable." ilk="function" line="768" lineend="784" name="setBreak" returns="ParserElement" signature="setBreak(breakFlag=True)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="True" ilk="argument" name="breakFlag" /><variable attributes="protected" citdl="self._parse" line="774" name="_parseMethod" /><scope ilk="function" line="775" lineend="778" name="breaker" returns="ParserElement.setBreak._parseMethod()" signature="breaker(instring, loc, doActions=True, callPreParse=True)"><import line="776" module="pdb" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="True" ilk="argument" name="callPreParse" /><variable attributes="protected" citdl="self._parse" line="779" name="_originalParseMethod" /></scope></scope><scope doc="Define action to perform when successfully matching parse element definition.&#xA;Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},&#xA;C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:&#xA; - s   = the original string being parsed (see note below)&#xA; - loc = the location of the matching substring&#xA; - toks = a list of the matched tokens, packaged as a ParseResults object&#xA;If the functions in fns modify the tokens, they can return them as the return&#xA;value from fn, and the modified list of tokens will replace the original.&#xA;Otherwise, fn does not need to return any value.&#xA;&#xA;Note: the default parsing behavior is to expand tabs in the input string&#xA;before starting the parsing process.  See L{I{parseString}&lt;parseString&gt;} for more information&#xA;on parsing strings containing &lt;TAB&gt;s, and suggested methods to maintain a&#xA;consistent view of the parsed string, the parse location, and line and column&#xA;positions within the parsed string." ilk="function" line="786" lineend="805" name="setParseAction" returns="ParserElement" signature="setParseAction(*fns, **kwargs)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="fns" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><scope doc="Add parse action to expression&apos;s list of parse actions. See L{I{setParseAction}&lt;setParseAction&gt;}." ilk="function" line="807" lineend="811" name="addParseAction" returns="ParserElement" signature="addParseAction(*fns, **kwargs)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="fns" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><scope doc="Define action to perform if parsing fails at this expression.&#xA;Fail acton fn is a callable function that takes the arguments&#xA;C{fn(s,loc,expr,err)} where:&#xA; - s = string being parsed&#xA; - loc = location where expression match was attempted and failed&#xA; - expr = the parse expression that failed&#xA; - err = the exception thrown&#xA;The function returns no value.  It may throw C{ParseFatalException}&#xA;if it is desired to stop parsing immediately." ilk="function" line="813" lineend="824" name="setFailAction" returns="ParserElement" signature="setFailAction(fn)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="fn" /></scope><scope attributes="protected" ilk="function" line="826" lineend="837" name="_skipIgnorables" signature="_skipIgnorables(instring, loc)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" line="827" name="exprsFound" /><variable line="833" name="dummy" /></scope><scope ilk="function" line="839" lineend="849" name="preParse" returns="_skipIgnorables()" signature="preParse(instring, loc)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="_skipIgnorables()" ilk="argument" name="loc" /><variable citdl="ParserElement" line="844" name="wt" /><variable citdl="len()" line="845" name="instrlen" /></scope><scope ilk="function" line="851" lineend="852" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /></scope><scope ilk="function" line="854" lineend="855" name="postParse" signature="postParse(instring, loc, tokenlist)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /></scope><scope attributes="protected" ilk="function" line="858" lineend="933" name="_parseNoCache" returns="tuple" signature="_parseNoCache(instring, loc, doActions=True, callPreParse=True)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="True" ilk="argument" name="callPreParse" /><variable citdl="False" line="859" name="debugging" /><variable citdl="preParse()" line="866" name="preloc" /><variable citdl="preParse()" line="869" name="tokensStart" /><variable citdl="fn()" line="872" name="tokens" /><variable line="877" name="err" /><variable citdl="ParseResults" line="902" name="retTokens" /></scope><scope ilk="function" line="935" lineend="939" name="tryParse" signature="tryParse(instring, loc)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /></scope><scope attributes="protected" ilk="function" line="943" lineend="958" name="_parseCache" returns="tuple" signature="_parseCache(instring, loc, doActions=True, callPreParse=True)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="True" ilk="argument" name="callPreParse" /><variable citdl="tuple" line="944" name="lookup" /><variable citdl="_parseNoCache()" line="946" name="value" /><variable line="956" name="pe" /></scope><variable attributes="protected" citdl="ParserElement.setBreak.breaker" line="960" name="_parse" /><variable attributes="protected" citdl="dict" line="963" name="_exprArgCache" /><scope ilk="function" line="966" lineend="965" name="resetCache" signature="resetCache()" /><variable attributes="protected" citdl="False" line="968" name="_packratEnabled" /><scope doc="Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic.&#xA;Repeated parse attempts at the same string location (which happens&#xA;often in many complex grammars) can immediately return a cached value,&#xA;instead of re-executing parsing/validating code.  Memoizing is done of&#xA;both valid results and parsing exceptions.&#xA;&#xA;This speedup may break existing programs that use parse actions that&#xA;have side-effects.  For this reason, packrat parsing is disabled when&#xA;you first import pyparsing.  To activate the packrat feature, your&#xA;program must call the class method C{ParserElement.enablePackrat()}.  If&#xA;your program uses C{psyco} to &quot;compile as you go&quot;, you must call&#xA;C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,&#xA;Python will crash.  For best results, call C{enablePackrat()} immediately&#xA;after importing pyparsing." ilk="function" line="988" lineend="987" name="enablePackrat" signature="enablePackrat()" /><scope doc="Execute the parse expression with the given string.&#xA;This is the main interface to the client code, once the complete&#xA;expression has been built.&#xA;&#xA;If you want the grammar to require that the entire input string be&#xA;successfully parsed, then set C{parseAll} to True (equivalent to ending&#xA;the grammar with C{StringEnd()}).&#xA;&#xA;Note: C{parseString} implicitly calls C{expandtabs()} on the input string,&#xA;in order to report proper column numbers in parse actions.&#xA;If the input string contains tabs and&#xA;the grammar uses parse actions that use the C{loc} argument to index into the&#xA;string being parsed, you can ensure you have a consistent view of the input&#xA;string by:&#xA; - calling C{parseWithTabs} on your grammar before calling C{parseString}&#xA;   (see L{I{parseWithTabs}&lt;parseWithTabs&gt;})&#xA; - define your parse action using the full C{(s,loc,toks)} signature, and&#xA;   reference the input string using the parse action&apos;s C{s} argument&#xA; - explictly expand the tabs in your input string before calling&#xA;   C{parseString}" ilk="function" line="990" lineend="1034" name="parseString" signature="parseString(instring, parseAll=False)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="instring.expandtabs()" ilk="argument" name="instring" /><variable citdl="False" ilk="argument" name="parseAll" /><variable line="1021" name="tokens" /><variable citdl="preParse()" line="1021" name="loc" /><variable citdl="StringEnd()" line="1024" name="se" /><variable line="1031" name="exc" /></scope><scope doc="Scan the input string for expression matches.  Each match will return the&#xA;matching tokens, start location, and end location.  May be called with optional&#xA;C{maxMatches} argument, to clip scanning after &apos;n&apos; matches are found.  If&#xA;C{overlap} is specified, then overlapping matches will be reported.&#xA;&#xA;Note that the start and end locations are reported relative to the string&#xA;being parsed.  See L{I{parseString}&lt;parseString&gt;} for more information on parsing&#xA;strings with embedded tabs." ilk="function" line="1036" lineend="1085" name="scanString" signature="scanString(instring, maxMatches=_MAX_INT, overlap=False)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="sys.maxsize" ilk="argument" name="maxMatches" /><variable citdl="False" ilk="argument" name="overlap" /><variable citdl="len()" line="1052" name="instrlen" /><variable citdl="preparseFn()" line="1053" name="loc" /><variable citdl="ParserElement.preParse" line="1054" name="preparseFn" /><variable citdl="ParserElement.setBreak.breaker" line="1055" name="parseFn" /><variable citdl="int" line="1057" name="matches" /><variable citdl="preparseFn()" line="1061" name="preloc" /><variable line="1062" name="nextLoc" /><variable line="1062" name="tokens" /><variable citdl="preparseFn()" line="1070" name="nextloc" /><variable line="1084" name="exc" /></scope><scope doc="Extension to C{scanString}, to modify matching text with modified tokens that may&#xA;be returned from a parse action.  To use C{transformString}, define a grammar and&#xA;attach a parse action to it that modifies the returned token list.&#xA;Invoking C{transformString()} on a target string will then scan for matches,&#xA;and replace the matched text patterns according to the logic in the parse&#xA;action.  C{transformString()} returns the resulting transformed string." ilk="function" line="1087" lineend="1119" name="transformString" returns="__builtins__.str.join()" signature="transformString(instring)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="list" line="1094" name="out" /><variable citdl="int" line="1095" name="lastE" /><variable line="1118" name="exc" /></scope><scope doc="Another extension to C{scanString}, simplifying the access to the tokens found&#xA;to match the given parse expression.  May be called with optional&#xA;C{maxMatches} argument, to clip searching after &apos;n&apos; matches are found." ilk="function" line="1121" lineend="1134" name="searchString" returns="ParseResults" signature="searchString(instring, maxMatches=_MAX_INT)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="sys.maxsize" ilk="argument" name="maxMatches" /><variable line="1133" name="exc" /></scope><scope doc="Implementation of + operator - returns And" ilk="function" line="1136" lineend="1144" name="__add__" returns="And()" signature="__add__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of + operator when left operand is not a C{ParserElement}" ilk="function" line="1146" lineend="1154" name="__radd__" returns="ParserElement" signature="__radd__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of - operator, returns C{And} with error stop" ilk="function" line="1156" lineend="1164" name="__sub__" returns="And()" signature="__sub__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of - operator when left operand is not a C{ParserElement}" ilk="function" line="1166" lineend="1174" name="__rsub__" returns="ParserElement" signature="__rsub__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of * operator, allows use of C{expr * 3} in place of&#xA;C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer&#xA;tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples&#xA;may also include C{None} as in:&#xA; - C{expr*(n,None)} or C{expr*(n,)} is equivalent&#xA;   to C{expr*n + ZeroOrMore(expr)}&#xA;   (read as &quot;at least n instances of C{expr}&quot;)&#xA; - C{expr*(None,n)} is equivalent to C{expr*(0,n)}&#xA;   (read as &quot;0 to n instances of C{expr}&quot;)&#xA; - C{expr*(None,None)} is equivalent to C{ZeroOrMore(expr)}&#xA; - C{expr*(1,None)} is equivalent to C{OneOrMore(expr)}&#xA;&#xA;Note that C{expr*(None,n)} does not raise an exception if&#xA;more than n exprs exist in the input stream; that is,&#xA;C{expr*(None,n)} does not enforce a maximum number of expr&#xA;occurrences.  If this behavior is desired, then write&#xA;C{expr*(None,n) + ~expr}&#xA;" ilk="function" line="1176" lineend="1242" name="__mul__" returns="makeOptionalList()" signature="__mul__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="other" /><variable citdl="int" line="1197" name="optElements" /><variable line="1197" name="minElements" /><scope ilk="function" line="1225" lineend="1229" name="makeOptionalList" returns="Optional()" signature="makeOptionalList(n)"><variable ilk="argument" name="n" /></scope><variable citdl="And()" line="1232" name="ret" /></scope><scope ilk="function" line="1244" lineend="1245" name="__rmul__" returns="ParserElement.__mul__()" signature="__rmul__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope doc="Implementation of | operator - returns C{MatchFirst}" ilk="function" line="1247" lineend="1255" name="__or__" returns="MatchFirst()" signature="__or__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of | operator when left operand is not a C{ParserElement}" ilk="function" line="1257" lineend="1265" name="__ror__" returns="int" signature="__ror__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of ^ operator - returns C{Or}" ilk="function" line="1267" lineend="1275" name="__xor__" returns="Or()" signature="__xor__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of ^ operator when left operand is not a C{ParserElement}" ilk="function" line="1277" lineend="1285" name="__rxor__" returns="int" signature="__rxor__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of &amp; operator - returns C{Each}" ilk="function" line="1287" lineend="1295" name="__and__" returns="Each()" signature="__and__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of &amp; operator when left operand is not a C{ParserElement}" ilk="function" line="1297" lineend="1305" name="__rand__" returns="int" signature="__rand__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="Literal()" ilk="argument" name="other" /></scope><scope doc="Implementation of ~ operator - returns C{NotAny}" ilk="function" line="1307" lineend="1309" name="__invert__" returns="NotAny()" signature="__invert__()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope doc="Shortcut for C{setResultsName}, with C{listAllMatches=default}::&#xA;  userdata = Word(alphas).setResultsName(&quot;name&quot;) + Word(nums+&quot;-&quot;).setResultsName(&quot;socsecno&quot;)&#xA;could be written as::&#xA;  userdata = Word(alphas)(&quot;name&quot;) + Word(nums+&quot;-&quot;)(&quot;socsecno&quot;)&#xA;  &#xA;If C{name} is given with a trailing C{&apos;*&apos;} character, then C{listAllMatches} will be&#xA;passed as C{True}." ilk="function" line="1311" lineend="1320" name="__call__" returns="ParserElement.setResultsName()" signature="__call__(name)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope doc="Suppresses the output of this C{ParserElement}; useful to keep punctuation from&#xA;cluttering up returned output." ilk="function" line="1322" lineend="1326" name="suppress" returns="Suppress()" signature="suppress()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope doc="Disables the skipping of whitespace before matching the characters in the&#xA;C{ParserElement}&apos;s defined pattern.  This is normally only used internally by&#xA;the pyparsing module, but may be needed in some whitespace-sensitive grammars." ilk="function" line="1328" lineend="1334" name="leaveWhitespace" returns="ParserElement" signature="leaveWhitespace()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope doc="Overrides the default whitespace chars&#xA;        " ilk="function" line="1336" lineend="1342" name="setWhitespaceChars" returns="ParserElement" signature="setWhitespaceChars(chars)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="chars" /></scope><scope doc="Overrides default behavior to expand C{&lt;TAB&gt;}s to spaces before parsing the input string.&#xA;Must be called before C{parseString} when the input grammar contains elements that&#xA;match C{&lt;TAB&gt;} characters." ilk="function" line="1344" lineend="1349" name="parseWithTabs" returns="ParserElement" signature="parseWithTabs()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope doc="Define expression to be ignored (e.g., comments) while doing pattern&#xA;matching; may be called repeatedly, to define multiple comment or other&#xA;ignorable patterns." ilk="function" line="1351" lineend="1361" name="ignore" returns="ParserElement" signature="ignore(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope doc="Enable display of debugging messages while doing pattern matching." ilk="function" line="1363" lineend="1369" name="setDebugActions" returns="ParserElement" signature="setDebugActions(startAction, successAction, exceptionAction)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="startAction" /><variable ilk="argument" name="successAction" /><variable ilk="argument" name="exceptionAction" /></scope><scope doc="Enable display of debugging messages while doing pattern matching.&#xA;Set C{flag} to True to enable, False to disable." ilk="function" line="1371" lineend="1378" name="setDebug" returns="ParserElement" signature="setDebug(flag=True)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="True" ilk="argument" name="flag" /></scope><scope ilk="function" line="1380" lineend="1381" name="__str__" signature="__str__()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope ilk="function" line="1383" lineend="1384" name="__repr__" returns="_ustr()" signature="__repr__()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope ilk="function" line="1386" lineend="1389" name="streamline" returns="ParserElement" signature="streamline()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope ilk="function" line="1391" lineend="1392" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /></scope><scope doc="Check defined expressions for valid structure, check for infinite recursive definitions." ilk="function" line="1394" lineend="1396" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParserElement" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="validateTrace" /></scope><scope doc="Execute the parse expression on the given file or filename.&#xA;If a filename is specified (instead of a file object),&#xA;the entire file is opened, read, and closed before parsing." ilk="function" line="1398" lineend="1414" name="parseFile" returns="ParserElement.parseString()" signature="parseFile(file_or_filename, parseAll=False)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="file_or_filename" /><variable citdl="False" ilk="argument" name="parseAll" /><variable citdl="f.read()" line="1404" name="file_contents" /><variable citdl="open()" line="1406" name="f" /><variable line="1413" name="exc" /></scope><scope ilk="function" line="1416" lineend="1417" name="getException" returns="ParseException" signature="getException()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope ilk="function" line="1419" lineend="1424" name="__getattr__" returns="ret" signature="__getattr__(aname)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="aname" /></scope><variable attributes="__instancevar__" citdl="getException()" line="1421" name="myException" /><scope ilk="function" line="1426" lineend="1436" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="1438" lineend="1439" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="1441" lineend="1442" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="ParserElement" ilk="argument" name="self" /></scope><scope ilk="function" line="1444" lineend="1445" name="__req__" returns="bool" signature="__req__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="1447" lineend="1448" name="__rne__" returns="bool" signature="__rne__(other)"><variable citdl="ParserElement" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope></scope><scope classrefs="ParserElement" doc="Abstract C{ParserElement} subclass, for defining atomic matching patterns." ilk="class" line="1451" lineend="1459" name="Token"><scope attributes="__ctor__" ilk="function" line="1453" lineend="1454" name="__init__" signature="Token()"><variable citdl="Token" ilk="argument" name="self" /></scope><scope ilk="function" line="1456" lineend="1459" name="setName" signature="setName(name)"><variable citdl="Token" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable line="1457" name="s" /></scope><variable attributes="__instancevar__" citdl="self.name" line="1458" name="errmsg" /></scope><scope classrefs="Token" doc="An empty token, will always match." ilk="class" line="1462" lineend="1468" name="Empty"><scope attributes="__ctor__" ilk="function" line="1464" lineend="1468" name="__init__" signature="Empty()"><variable citdl="Empty" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1466" name="name" /><variable attributes="__instancevar__" citdl="True" line="1467" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1468" name="mayIndexError" /></scope><scope classrefs="Token" doc="A token that will never match." ilk="class" line="1471" lineend="1484" name="NoMatch"><scope attributes="__ctor__" ilk="function" line="1473" lineend="1478" name="__init__" signature="NoMatch()"><variable citdl="NoMatch" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1475" name="name" /><variable attributes="__instancevar__" citdl="True" line="1476" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1477" name="mayIndexError" /><variable attributes="__instancevar__" citdl="str" line="1478" name="errmsg" /><scope ilk="function" line="1480" lineend="1484" name="parseImpl" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="NoMatch" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1481" name="exc" /></scope></scope><scope classrefs="Token" doc="Token to exactly match a specified string." ilk="class" line="1487" lineend="1516" name="Literal"><scope attributes="__ctor__" ilk="function" line="1489" lineend="1502" name="__init__" signature="Literal(matchString)"><variable citdl="Literal" ilk="argument" name="self" /><variable ilk="argument" name="matchString" /></scope><variable attributes="__instancevar__" line="1491" name="match" /><variable attributes="__instancevar__" citdl="len()" line="1492" name="matchLen" /><variable attributes="__instancevar__" line="1494" name="firstMatchChar" /><variable attributes="__instancevar__" citdl="Empty" line="1498" name="__class__" /><variable attributes="__instancevar__" citdl="_ustr()" line="1499" name="name" /><variable attributes="__instancevar__" citdl="str" line="1500" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1501" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1502" name="mayIndexError" /><scope ilk="function" line="1508" lineend="1516" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Literal" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1513" name="exc" /></scope></scope><variable attributes="protected" citdl="Literal" line="1517" name="_L" /><scope classrefs="Token" doc="Token to exactly match a specified string as a keyword, that is, it must be&#xA;immediately followed by a non-keyword character.  Compare with C{Literal}::&#xA;  Literal(&quot;if&quot;) will match the leading C{&apos;if&apos;} in C{&apos;ifAndOnlyIf&apos;}.&#xA;  Keyword(&quot;if&quot;) will not; it will only match the leading C{&apos;if&apos;} in C{&apos;if x=1&apos;}, or C{&apos;if(y==2)&apos;}&#xA;Accepts two optional constructor arguments in addition to the keyword string:&#xA;C{identChars} is a string of characters that would be valid identifier characters,&#xA;defaulting to all alphanumerics + &quot;_&quot; and &quot;$&quot;; C{caseless} allows case-insensitive&#xA;matching, default is C{False}." ilk="class" line="1519" lineend="1577" name="Keyword"><variable citdl="string.lowercase" line="1529" name="DEFAULT_KEYWORD_CHARS" /><scope attributes="__ctor__" ilk="function" line="1531" lineend="1548" name="__init__" signature="Keyword(matchString, identChars=DEFAULT_KEYWORD_CHARS, caseless=False)"><variable citdl="Keyword" ilk="argument" name="self" /><variable ilk="argument" name="matchString" /><variable citdl="string.lowercase" ilk="argument" name="identChars" /><variable citdl="False" ilk="argument" name="caseless" /></scope><variable attributes="__instancevar__" line="1533" name="match" /><variable attributes="__instancevar__" citdl="len()" line="1534" name="matchLen" /><variable attributes="__instancevar__" line="1536" name="firstMatchChar" /><variable attributes="__instancevar__" citdl="str" line="1540" name="name" /><variable attributes="__instancevar__" citdl="str" line="1541" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1542" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1543" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="1544" name="caseless" /><variable attributes="__instancevar__" citdl="matchString.upper()" line="1546" name="caselessmatch" /><variable attributes="__instancevar__" citdl="set()" line="1548" name="identChars" /><scope ilk="function" line="1550" lineend="1566" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Keyword" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1563" name="exc" /></scope><scope ilk="function" line="1568" lineend="1571" name="copy" signature="copy()"><variable citdl="Keyword" ilk="argument" name="self" /><variable line="1569" name="c" /></scope><scope doc="Overrides the default Keyword chars&#xA;        " ilk="function" line="1577" lineend="1576" name="setDefaultKeywordChars" signature="setDefaultKeywordChars()"><variable citdl="Keyword" ilk="argument" name="chars" /></scope></scope><scope classrefs="Literal" doc="Token to match a specified string, ignoring case of letters.&#xA;Note: the matched results will always be in the case of the given&#xA;match string, NOT the case of the input text." ilk="class" line="1579" lineend="1598" name="CaselessLiteral"><scope attributes="__ctor__" ilk="function" line="1584" lineend="1589" name="__init__" signature="CaselessLiteral(matchString)"><variable citdl="CaselessLiteral" ilk="argument" name="self" /><variable ilk="argument" name="matchString" /></scope><variable attributes="__instancevar__" line="1587" name="returnString" /><variable attributes="__instancevar__" citdl="str" line="1588" name="name" /><variable attributes="__instancevar__" citdl="str" line="1589" name="errmsg" /><scope ilk="function" line="1591" lineend="1598" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CaselessLiteral" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1595" name="exc" /></scope></scope><scope classrefs="Keyword" ilk="class" line="1600" lineend="1612" name="CaselessKeyword"><scope attributes="__ctor__" ilk="function" line="1601" lineend="1602" name="__init__" signature="CaselessKeyword(matchString, identChars=Keyword.DEFAULT_KEYWORD_CHARS)"><variable citdl="CaselessKeyword" ilk="argument" name="self" /><variable ilk="argument" name="matchString" /><variable citdl="string.lowercase" ilk="argument" name="identChars" /></scope><scope ilk="function" line="1604" lineend="1612" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CaselessKeyword" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1609" name="exc" /></scope></scope><scope classrefs="Token" doc="Token for matching words composed of allowed character sets.&#xA;Defined with string containing all allowed initial characters,&#xA;an optional string containing allowed body characters (if omitted,&#xA;defaults to the initial character set), and an optional minimum,&#xA;maximum, and/or exact length.  The default value for C{min} is 1 (a&#xA;minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}&#xA;are 0, meaning no maximum or exact length restriction. An optional&#xA;C{exclude} parameter can list characters that might be found in &#xA;the input C{bodyChars} string; useful to define a word of all printables&#xA;except for one or two characters, for instance." ilk="class" line="1614" lineend="1745" name="Word"><scope attributes="__ctor__" ilk="function" line="1626" lineend="1678" name="__init__" signature="Word(initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None)"><variable citdl="Word" ilk="argument" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" name="initChars" /><variable citdl="__builtins__.str.join()" ilk="argument" name="bodyChars" /><variable citdl="int" ilk="argument" name="min" /><variable citdl="int" ilk="argument" name="max" /><variable citdl="int" ilk="argument" name="exact" /><variable citdl="False" ilk="argument" name="asKeyword" /><variable ilk="argument" name="excludeChars" /></scope><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1632" name="initCharsOrig" /><variable attributes="__instancevar__" citdl="set()" line="1633" name="initChars" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1635" name="bodyCharsOrig" /><variable attributes="__instancevar__" citdl="set()" line="1636" name="bodyChars" /><variable attributes="__instancevar__" citdl="bool" line="1641" name="maxSpecified" /><variable attributes="__instancevar__" citdl="int" line="1646" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="1649" name="maxLen" /><variable attributes="__instancevar__" citdl="_ustr()" line="1657" name="name" /><variable attributes="__instancevar__" citdl="_ustr()" line="1658" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1659" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="1660" name="asKeyword" /><variable attributes="__instancevar__" citdl="str" line="1664" name="reString" /><variable attributes="__instancevar__" citdl="re.compile()" line="1676" name="re" /><scope ilk="function" line="1680" lineend="1723" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Word" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="result.end()" ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.re.match()" line="1682" name="result" /><variable citdl="self.myException" line="1684" name="exc" /><variable citdl="result.end()" line="1698" name="start" /><variable citdl="len()" line="1700" name="instrlen" /><variable citdl="set()" line="1701" name="bodychars" /><variable citdl="result.end()" line="1702" name="maxloc" /><variable citdl="True" line="1707" name="throwException" /></scope><scope ilk="function" line="1725" lineend="1745" name="__str__" returns="Word.__str__.charsAsStr()" signature="__str__()"><variable citdl="Word" ilk="argument" name="self" /><scope ilk="function" line="1734" lineend="1738" name="charsAsStr" returns="str" signature="charsAsStr(s)"><variable ilk="argument" name="s" /></scope></scope><variable attributes="__instancevar__" citdl="str" line="1741" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching strings that match a given regular expression.&#xA;Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module." ilk="class" line="1748" lineend="1812" name="Regex"><variable citdl="type()" line="1752" name="compiledREtype" /><scope attributes="__ctor__" doc="The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags." ilk="function" line="1753" lineend="1785" name="__init__" signature="Regex(pattern, flags=0)"><variable citdl="Regex" ilk="argument" name="self" /><variable ilk="argument" name="pattern" /><variable citdl="int" ilk="argument" name="flags" /></scope><variable attributes="__instancevar__" citdl="str()" line="1762" name="pattern" /><variable attributes="__instancevar__" citdl="int" line="1763" name="flags" /><variable attributes="__instancevar__" citdl="re.compile()" line="1766" name="re" /><variable attributes="__instancevar__" line="1767" name="reString" /><variable attributes="__instancevar__" citdl="_ustr()" line="1782" name="name" /><variable attributes="__instancevar__" citdl="_ustr()" line="1783" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1784" name="mayIndexError" /><variable attributes="__instancevar__" citdl="True" line="1785" name="mayReturnEmpty" /><scope ilk="function" line="1787" lineend="1801" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Regex" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="result.end()" ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.re.match()" line="1788" name="result" /><variable citdl="self.myException" line="1790" name="exc" /><variable citdl="result.groupdict()" line="1796" name="d" /><variable citdl="ParseResults" line="1797" name="ret" /></scope><scope ilk="function" line="1803" lineend="1812" name="__str__" returns="repr()" signature="__str__()"><variable citdl="Regex" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="repr()" line="1810" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching strings that are delimited by quoting characters.&#xA;    " ilk="class" line="1815" lineend="1928" name="QuotedString"><scope attributes="__ctor__" doc="Defined with the following parameters:&#xA; - quoteChar - string of one or more characters defining the quote delimiting string&#xA; - escChar - character to escape quotes, typically backslash (default=None)&#xA; - escQuote - special quote sequence to escape an embedded quote string (such as SQL&apos;s &quot;&quot; to escape an embedded &quot;) (default=None)&#xA; - multiline - boolean indicating whether quotes can span multiple lines (default=False)&#xA; - unquoteResults - boolean indicating whether the matched text should be unquoted (default=True)&#xA; - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=None =&gt; same as quoteChar)" ilk="function" line="1818" lineend="1890" name="__init__" signature="QuotedString(quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None)"><variable citdl="QuotedString" ilk="argument" name="self" /><variable citdl="quoteChar.strip()" ilk="argument" name="quoteChar" /><variable ilk="argument" name="escChar" /><variable ilk="argument" name="escQuote" /><variable citdl="False" ilk="argument" name="multiline" /><variable citdl="True" ilk="argument" name="unquoteResults" /><variable citdl="quoteChar.strip()" ilk="argument" name="endQuoteChar" /><variable line="1875" name="charset" /></scope><variable attributes="__instancevar__" citdl="quoteChar.strip()" line="1844" name="quoteChar" /><variable attributes="__instancevar__" citdl="len()" line="1845" name="quoteCharLen" /><variable attributes="__instancevar__" line="1846" name="firstQuoteChar" /><variable attributes="__instancevar__" citdl="quoteChar.strip()" line="1847" name="endQuoteChar" /><variable attributes="__instancevar__" citdl="len()" line="1848" name="endQuoteCharLen" /><variable attributes="__instancevar__" line="1849" name="escChar" /><variable attributes="__instancevar__" line="1850" name="escQuote" /><variable attributes="__instancevar__" citdl="True" line="1851" name="unquoteResults" /><variable attributes="__instancevar__" citdl="int" line="1854" name="flags" /><variable attributes="__instancevar__" citdl="str" line="1855" name="pattern" /><variable attributes="__instancevar__" citdl="str" line="1876" name="escCharReplacePattern" /><variable attributes="__instancevar__" citdl="re.compile()" line="1880" name="re" /><variable attributes="__instancevar__" citdl="str" line="1881" name="reString" /><variable attributes="__instancevar__" citdl="_ustr()" line="1887" name="name" /><variable attributes="__instancevar__" citdl="_ustr()" line="1888" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1889" name="mayIndexError" /><variable attributes="__instancevar__" citdl="True" line="1890" name="mayReturnEmpty" /><scope ilk="function" line="1892" lineend="1917" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="QuotedString" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="result.end()" ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.re.match()" line="1893" name="result" /><variable citdl="self.myException" line="1895" name="exc" /><variable citdl="list" line="1901" name="ret" /></scope><scope ilk="function" line="1919" lineend="1928" name="__str__" returns="tuple" signature="__str__()"><variable citdl="QuotedString" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1926" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching words composed of characters *not* in a given set.&#xA;Defined with string containing all disallowed characters, and an optional&#xA;minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a&#xA;minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}&#xA;are 0, meaning no maximum or exact length restriction." ilk="class" line="1931" lineend="1999" name="CharsNotIn"><scope attributes="__ctor__" ilk="function" line="1938" lineend="1960" name="__init__" signature="CharsNotIn(notChars, min=1, max=0, exact=0)"><variable citdl="CharsNotIn" ilk="argument" name="self" /><variable ilk="argument" name="notChars" /><variable citdl="int" ilk="argument" name="min" /><variable citdl="int" ilk="argument" name="max" /><variable citdl="int" ilk="argument" name="exact" /></scope><variable attributes="__instancevar__" citdl="False" line="1940" name="skipWhitespace" /><variable attributes="__instancevar__" line="1941" name="notChars" /><variable attributes="__instancevar__" citdl="int" line="1946" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="1949" name="maxLen" /><variable attributes="__instancevar__" citdl="_ustr()" line="1957" name="name" /><variable attributes="__instancevar__" citdl="_ustr()" line="1958" name="errmsg" /><variable attributes="__instancevar__" citdl="bool" line="1959" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1960" name="mayIndexError" /><scope ilk="function" line="1962" lineend="1985" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CharsNotIn" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="1965" name="exc" /><variable line="1970" name="start" /><variable line="1972" name="notchars" /><variable citdl="min()" line="1973" name="maxlen" /></scope><scope ilk="function" line="1987" lineend="1999" name="__str__" returns="str" signature="__str__()"><variable citdl="CharsNotIn" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1995" name="strRepr" /></scope><scope classrefs="Token" doc="Special matching class for matching whitespace.  Normally, whitespace is ignored&#xA;by pyparsing grammars.  This class is included when some whitespace structures&#xA;are significant.  Define with a string containing the whitespace characters to be&#xA;matched; default is C{&quot; \t\r\n&quot;}.  Also takes optional C{min}, C{max}, and C{exact} arguments,&#xA;as defined for the C{Word} class." ilk="class" line="2001" lineend="2055" name="White"><variable citdl="dict" line="2007" name="whiteStrs" /><scope attributes="__ctor__" ilk="function" line="2014" lineend="2032" name="__init__" signature="White(ws=&apos; \t\r\n&apos;, min=1, max=0, exact=0)"><variable citdl="White" ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="ws" /><variable citdl="int" ilk="argument" name="min" /><variable citdl="int" ilk="argument" name="max" /><variable citdl="int" ilk="argument" name="exact" /></scope><variable attributes="__instancevar__" citdl="str" line="2016" name="matchWhite" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="2019" name="name" /><variable attributes="__instancevar__" citdl="True" line="2020" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="2021" name="errmsg" /><variable attributes="__instancevar__" citdl="int" line="2023" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="2026" name="maxLen" /><scope ilk="function" line="2034" lineend="2055" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="White" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2037" name="exc" /><variable line="2041" name="start" /><variable citdl="sys.maxsize" line="2043" name="maxloc" /></scope></scope><scope attributes="protected" classrefs="Token" ilk="class" line="2058" lineend="2063" name="_PositionToken"><scope attributes="__ctor__" ilk="function" line="2059" lineend="2063" name="__init__" signature="_PositionToken()"><variable citdl="_PositionToken" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="self.__class__.__name__" line="2061" name="name" /><variable attributes="__instancevar__" citdl="True" line="2062" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2063" name="mayIndexError" /></scope><scope classrefs="_PositionToken" doc="Token to advance to a specific column of input text; useful for tabular report scraping." ilk="class" line="2065" lineend="2086" name="GoToColumn"><scope attributes="__ctor__" ilk="function" line="2067" lineend="2069" name="__init__" signature="GoToColumn(colno)"><variable citdl="GoToColumn" ilk="argument" name="self" /><variable ilk="argument" name="colno" /></scope><variable attributes="__instancevar__" line="2069" name="col" /><scope ilk="function" line="2071" lineend="2078" name="preParse" returns="self._skipIgnorables()" signature="preParse(instring, loc)"><variable citdl="GoToColumn" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="self._skipIgnorables()" ilk="argument" name="loc" /><variable citdl="len()" line="2073" name="instrlen" /></scope><scope ilk="function" line="2080" lineend="2086" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="GoToColumn" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="col()" line="2081" name="thiscol" /><variable citdl="col()" line="2084" name="newloc" /><variable citdl="list" line="2085" name="ret" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the beginning of a line within the parse string" ilk="class" line="2088" lineend="2110" name="LineStart"><scope attributes="__ctor__" ilk="function" line="2090" lineend="2093" name="__init__" signature="LineStart()"><variable citdl="LineStart" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2093" name="errmsg" /><scope ilk="function" line="2095" lineend="2099" name="preParse" signature="preParse(instring, loc)"><variable citdl="LineStart" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable line="2096" name="preloc" /></scope><scope ilk="function" line="2101" lineend="2110" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="LineStart" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2106" name="exc" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the end of a line within the parse string" ilk="class" line="2112" lineend="2135" name="LineEnd"><scope attributes="__ctor__" ilk="function" line="2114" lineend="2117" name="__init__" signature="LineEnd()"><variable citdl="LineEnd" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2117" name="errmsg" /><scope ilk="function" line="2119" lineend="2135" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="LineEnd" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2125" name="exc" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the beginning of the parse string" ilk="class" line="2137" lineend="2152" name="StringStart"><scope attributes="__ctor__" ilk="function" line="2139" lineend="2141" name="__init__" signature="StringStart()"><variable citdl="StringStart" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2141" name="errmsg" /><scope ilk="function" line="2143" lineend="2152" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="StringStart" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2148" name="exc" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the end of the parse string" ilk="class" line="2154" lineend="2175" name="StringEnd"><scope attributes="__ctor__" ilk="function" line="2156" lineend="2158" name="__init__" signature="StringEnd()"><variable citdl="StringEnd" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2158" name="errmsg" /><scope ilk="function" line="2160" lineend="2175" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="StringEnd" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2163" name="exc" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if the current position is at the beginning of a Word, and&#xA;is not preceded by any character in a given set of C{wordChars}&#xA;(default=C{printables}). To emulate the C{&amp;#8;} behavior of regular expressions,&#xA;use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of&#xA;the string being parsed, or at the beginning of a line." ilk="class" line="2177" lineend="2197" name="WordStart"><scope attributes="__ctor__" ilk="function" line="2184" lineend="2187" name="__init__" signature="WordStart(wordChars=printables)"><variable citdl="WordStart" ilk="argument" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" name="wordChars" /></scope><variable attributes="__instancevar__" citdl="set()" line="2186" name="wordChars" /><variable attributes="__instancevar__" citdl="str" line="2187" name="errmsg" /><scope ilk="function" line="2189" lineend="2197" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="WordStart" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2193" name="exc" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if the current position is at the end of a Word, and&#xA;is not followed by any character in a given set of C{wordChars}&#xA;(default=C{printables}). To emulate the C{&amp;#8;} behavior of regular expressions,&#xA;use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of&#xA;the string being parsed, or at the end of a line." ilk="class" line="2199" lineend="2222" name="WordEnd"><scope attributes="__ctor__" ilk="function" line="2206" lineend="2210" name="__init__" signature="WordEnd(wordChars=printables)"><variable citdl="WordEnd" ilk="argument" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" name="wordChars" /></scope><variable attributes="__instancevar__" citdl="set()" line="2208" name="wordChars" /><variable attributes="__instancevar__" citdl="False" line="2209" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="2210" name="errmsg" /><scope ilk="function" line="2212" lineend="2222" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="WordEnd" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="len()" line="2213" name="instrlen" /><variable citdl="self.myException" line="2218" name="exc" /></scope></scope><scope classrefs="ParserElement" doc="Abstract subclass of ParserElement, for combining and post-processing parsed tokens." ilk="class" line="2225" lineend="2324" name="ParseExpression"><scope attributes="__ctor__" ilk="function" line="2227" lineend="2238" name="__init__" signature="ParseExpression(exprs, savelist=False)"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="list" line="2230" name="exprs" /><variable attributes="__instancevar__" citdl="False" line="2238" name="callPreparse" /><scope ilk="function" line="2240" lineend="2241" name="__getitem__" signature="__getitem__(i)"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable ilk="argument" name="i" /></scope><scope ilk="function" line="2243" lineend="2246" name="append" returns="ParseExpression" signature="append(other)"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><variable attributes="__instancevar__" citdl="str" line="2245" name="strRepr" /><scope doc="Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on&#xA;all contained expressions." ilk="function" line="2248" lineend="2255" name="leaveWhitespace" returns="ParseExpression" signature="leaveWhitespace()"><variable citdl="ParseExpression" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="False" line="2251" name="skipWhitespace" /><scope ilk="function" line="2257" lineend="2267" name="ignore" returns="ParseExpression" signature="ignore(other)"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2269" lineend="2277" name="__str__" returns="tuple" signature="__str__()"><variable citdl="ParseExpression" ilk="argument" name="self" /></scope><scope ilk="function" line="2279" lineend="2309" name="streamline" returns="ParseExpression" signature="streamline()"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable line="2289" name="other" /></scope><scope ilk="function" line="2311" lineend="2313" name="setResultsName" signature="setResultsName(name, listAllMatches=False)"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable citdl="False" ilk="argument" name="listAllMatches" /><variable line="2312" name="ret" /></scope><scope ilk="function" line="2315" lineend="2319" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="validateTrace" /><variable citdl="list" line="2316" name="tmp" /></scope><scope ilk="function" line="2321" lineend="2324" name="copy" signature="copy()"><variable citdl="ParseExpression" ilk="argument" name="self" /><variable line="2322" name="ret" /></scope></scope><scope classrefs="ParseExpression" doc="Requires all given C{ParseExpression}s to be found in the given order.&#xA;Expressions may be separated by whitespace.&#xA;May be constructed using the C{&apos;+&apos;} operator." ilk="class" line="2326" lineend="2392" name="And"><scope attributes="protected" classrefs="Empty" ilk="class" line="2332" lineend="2335" name="_ErrorStop"><scope attributes="__ctor__" ilk="function" line="2333" lineend="2335" name="__init__" signature="_ErrorStop(*args, **kwargs)"><variable citdl="_ErrorStop" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope></scope><scope attributes="__ctor__" ilk="function" line="2337" lineend="2346" name="__init__" signature="And(exprs, savelist=True)"><variable citdl="And" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="True" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="True" line="2339" name="mayReturnEmpty" /><variable attributes="__instancevar__" line="2345" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="True" line="2346" name="callPreparse" /><scope ilk="function" line="2348" lineend="2371" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="And" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable line="2351" name="resultlist" /><variable citdl="True" line="2352" name="errorStop" /><variable line="2359" name="exprtokens" /><variable line="2363" name="pe" /></scope><scope ilk="function" line="2373" lineend="2376" name="__iadd__" returns="self.append()" signature="__iadd__(other)"><variable citdl="And" ilk="argument" name="self" /><variable citdl="Literal" ilk="argument" name="other" /></scope><scope ilk="function" line="2378" lineend="2383" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="And" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /><variable citdl="list" line="2379" name="subRecCheckList" /></scope><scope ilk="function" line="2385" lineend="2392" name="__str__" returns="str" signature="__str__()"><variable citdl="And" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2390" name="strRepr" /></scope><scope classrefs="ParseExpression" doc="Requires that at least one C{ParseExpression} is found.&#xA;If two expressions match, the expression that matches the longest string will be used.&#xA;May be constructed using the C{&apos;^&apos;} operator." ilk="class" line="2395" lineend="2454" name="Or"><scope attributes="__ctor__" ilk="function" line="2400" lineend="2406" name="__init__" signature="Or(exprs, savelist=False)"><variable citdl="Or" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="False" line="2402" name="mayReturnEmpty" /><scope ilk="function" line="2408" lineend="2435" name="parseImpl" returns="maxMatchExp._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Or" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="int" line="2409" name="maxExcLoc" /><variable citdl="int" line="2410" name="maxMatchLoc" /><variable citdl="ParseException" line="2411" name="maxException" /><variable citdl="e.tryParse()" line="2414" name="loc2" /><variable line="2416" name="err" /><variable citdl="e" line="2427" name="maxMatchExp" /></scope><scope ilk="function" line="2437" lineend="2440" name="__ixor__" returns="self.append()" signature="__ixor__(other)"><variable citdl="Or" ilk="argument" name="self" /><variable citdl="Literal" ilk="argument" name="other" /></scope><scope ilk="function" line="2442" lineend="2449" name="__str__" returns="str" signature="__str__()"><variable citdl="Or" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2447" name="strRepr" /><scope ilk="function" line="2451" lineend="2454" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="Or" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /><variable citdl="list" line="2452" name="subRecCheckList" /></scope></scope><scope classrefs="ParseExpression" doc="Requires that at least one C{ParseExpression} is found.&#xA;If two expressions match, the first one listed is the one that will match.&#xA;May be constructed using the C{&apos;|&apos;} operator." ilk="class" line="2457" lineend="2513" name="MatchFirst"><scope attributes="__ctor__" ilk="function" line="2462" lineend="2471" name="__init__" signature="MatchFirst(exprs, savelist=False)"><variable citdl="MatchFirst" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="True" line="2465" name="mayReturnEmpty" /><scope ilk="function" line="2473" lineend="2494" name="parseImpl" returns="e._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="MatchFirst" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="int" line="2474" name="maxExcLoc" /><variable citdl="ParseException" line="2475" name="maxException" /><variable citdl="e._parse()" line="2478" name="ret" /></scope><scope ilk="function" line="2496" lineend="2499" name="__ior__" returns="self.append()" signature="__ior__(other)"><variable citdl="MatchFirst" ilk="argument" name="self" /><variable citdl="Literal" ilk="argument" name="other" /></scope><scope ilk="function" line="2501" lineend="2508" name="__str__" returns="str" signature="__str__()"><variable citdl="MatchFirst" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2506" name="strRepr" /><scope ilk="function" line="2510" lineend="2513" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="MatchFirst" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /><variable citdl="list" line="2511" name="subRecCheckList" /></scope></scope><scope classrefs="ParseExpression" doc="Requires all given C{ParseExpression}s to be found, but in any order.&#xA;Expressions may be separated by whitespace.&#xA;May be constructed using the C{&apos;&amp;&apos;} operator." ilk="class" line="2516" lineend="2601" name="Each"><scope attributes="__ctor__" ilk="function" line="2521" lineend="2529" name="__init__" signature="Each(exprs, savelist=True)"><variable citdl="Each" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="True" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="True" line="2523" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="True" line="2528" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="True" line="2529" name="initExprGroups" /><scope ilk="function" line="2531" lineend="2587" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Each" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="list" line="2533" name="opt1" /><variable citdl="list" line="2534" name="opt2" /><variable citdl="e.tryParse()" line="2541" name="tmpLoc" /><variable citdl="list" line="2542" name="tmpReqd" /><variable citdl="list" line="2543" name="tmpOpt" /><variable citdl="list" line="2544" name="matchOrder" /><variable citdl="True" line="2546" name="keepMatching" /><variable citdl="list" line="2548" name="tmpExprs" /><variable citdl="list" line="2549" name="failed" /><variable citdl="__builtins__.str.join()" line="2565" name="missing" /><variable citdl="list" line="2571" name="resultlist" /><variable line="2573" name="results" /><variable citdl="ParseResults" line="2576" name="finalResults" /><variable citdl="dict" line="2578" name="dups" /><variable citdl="ParseResults" line="2581" name="tmp" /></scope><variable attributes="__instancevar__" citdl="list" line="2535" name="optionals" /><variable attributes="__instancevar__" citdl="list" line="2536" name="multioptionals" /><variable attributes="__instancevar__" citdl="list" line="2537" name="multirequired" /><variable attributes="__instancevar__" citdl="list" line="2538" name="required" /><scope ilk="function" line="2589" lineend="2596" name="__str__" returns="str" signature="__str__()"><variable citdl="Each" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2594" name="strRepr" /><scope ilk="function" line="2598" lineend="2601" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="Each" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /><variable citdl="list" line="2599" name="subRecCheckList" /></scope></scope><scope classrefs="ParserElement" doc="Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens." ilk="class" line="2604" lineend="2673" name="ParseElementEnhance"><scope attributes="__ctor__" ilk="function" line="2606" lineend="2619" name="__init__" signature="ParseElementEnhance(expr, savelist=False)"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /><variable citdl="Literal" ilk="argument" name="expr" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="self.expr.copy()" line="2610" name="expr" /><variable attributes="__instancevar__" citdl="str" line="2611" name="strRepr" /><variable attributes="__instancevar__" citdl="expr.mayIndexError" line="2613" name="mayIndexError" /><variable attributes="__instancevar__" citdl="expr.mayReturnEmpty" line="2614" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="expr.skipWhitespace" line="2616" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="expr.saveAsList" line="2617" name="saveAsList" /><variable attributes="__instancevar__" citdl="expr.callPreparse" line="2618" name="callPreparse" /><scope ilk="function" line="2621" lineend="2625" name="parseImpl" returns="self.expr._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /></scope><scope ilk="function" line="2627" lineend="2632" name="leaveWhitespace" returns="ParseElementEnhance" signature="leaveWhitespace()"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /></scope><scope ilk="function" line="2634" lineend="2644" name="ignore" returns="ParseElementEnhance" signature="ignore(other)"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2646" lineend="2650" name="streamline" returns="ParseElementEnhance" signature="streamline()"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /></scope><scope ilk="function" line="2652" lineend="2657" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /><variable ilk="argument" name="parseElementList" /><variable citdl="list" line="2655" name="subRecCheckList" /></scope><scope ilk="function" line="2659" lineend="2663" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="validateTrace" /><variable citdl="list" line="2660" name="tmp" /></scope><scope ilk="function" line="2665" lineend="2673" name="__str__" returns="tuple" signature="__str__()"><variable citdl="ParseElementEnhance" ilk="argument" name="self" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Lookahead matching of the given parse expression.  C{FollowedBy}&#xA;does *not* advance the parsing position within the input string, it only&#xA;verifies that the specified parse expression matches at the current&#xA;position.  C{FollowedBy} always returns a null token list." ilk="class" line="2676" lineend="2687" name="FollowedBy"><scope attributes="__ctor__" ilk="function" line="2681" lineend="2683" name="__init__" signature="FollowedBy(expr)"><variable citdl="FollowedBy" ilk="argument" name="self" /><variable ilk="argument" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="2683" name="mayReturnEmpty" /><scope ilk="function" line="2685" lineend="2687" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="FollowedBy" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Lookahead to disallow matching with the given parse expression.  C{NotAny}&#xA;does *not* advance the parsing position within the input string, it only&#xA;verifies that the specified parse expression does *not* match at the current&#xA;position.  Also, C{NotAny} does *not* skip over leading whitespace. C{NotAny}&#xA;always returns a null token list.  May be constructed using the &apos;~&apos; operator." ilk="class" line="2690" lineend="2723" name="NotAny"><scope attributes="__ctor__" ilk="function" line="2696" lineend="2701" name="__init__" signature="NotAny(expr)"><variable citdl="NotAny" ilk="argument" name="self" /><variable ilk="argument" name="expr" /></scope><variable attributes="__instancevar__" citdl="False" line="2699" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="True" line="2700" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="_ustr()" line="2701" name="errmsg" /><scope ilk="function" line="2703" lineend="2714" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="NotAny" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="self.myException" line="2710" name="exc" /></scope><scope ilk="function" line="2716" lineend="2723" name="__str__" returns="str" signature="__str__()"><variable citdl="NotAny" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2721" name="strRepr" /></scope><scope classrefs="ParseElementEnhance" doc="Optional repetition of zero or more of the given expression." ilk="class" line="2726" lineend="2762" name="ZeroOrMore"><scope attributes="__ctor__" ilk="function" line="2728" lineend="2730" name="__init__" signature="ZeroOrMore(expr)"><variable citdl="ZeroOrMore" ilk="argument" name="self" /><variable ilk="argument" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="2730" name="mayReturnEmpty" /><scope ilk="function" line="2732" lineend="2748" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ZeroOrMore" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="list" line="2733" name="tokens" /><variable citdl="bool" line="2736" name="hasIgnoreExprs" /><variable citdl="self._skipIgnorables()" line="2739" name="preloc" /><variable line="2742" name="tmptokens" /></scope><scope ilk="function" line="2750" lineend="2757" name="__str__" returns="str" signature="__str__()"><variable citdl="ZeroOrMore" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2755" name="strRepr" /><scope ilk="function" line="2759" lineend="2762" name="setResultsName" signature="setResultsName(name, listAllMatches=False)"><variable citdl="ZeroOrMore" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable citdl="False" ilk="argument" name="listAllMatches" /><variable line="2760" name="ret" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Repetition of one or more of the given expression." ilk="class" line="2765" lineend="2797" name="OneOrMore"><scope ilk="function" line="2767" lineend="2783" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="OneOrMore" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable line="2769" name="tokens" /><variable citdl="bool" line="2771" name="hasIgnoreExprs" /><variable citdl="self._skipIgnorables()" line="2774" name="preloc" /><variable line="2777" name="tmptokens" /></scope><scope ilk="function" line="2785" lineend="2792" name="__str__" returns="str" signature="__str__()"><variable citdl="OneOrMore" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2790" name="strRepr" /><scope ilk="function" line="2794" lineend="2797" name="setResultsName" signature="setResultsName(name, listAllMatches=False)"><variable citdl="OneOrMore" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable citdl="False" ilk="argument" name="listAllMatches" /><variable line="2795" name="ret" /></scope></scope><scope attributes="protected" classrefs="object" ilk="class" line="2799" lineend="2804" name="_NullToken"><scope ilk="function" line="2800" lineend="2801" name="__bool__" returns="bool" signature="__bool__()"><variable citdl="_NullToken" ilk="argument" name="self" /></scope><variable citdl="_NullToken.__bool__" line="2802" name="__nonzero__" /><scope ilk="function" line="2803" lineend="2804" name="__str__" returns="str" signature="__str__()"><variable citdl="_NullToken" ilk="argument" name="self" /></scope></scope><variable attributes="protected" citdl="_NullToken" line="2806" name="_optionalNotMatched" /><scope classrefs="ParseElementEnhance" doc="Optional matching of the given expression.&#xA;A default return string can also be specified, if the optional expression&#xA;is not found." ilk="class" line="2807" lineend="2838" name="Optional"><scope attributes="__ctor__" ilk="function" line="2812" lineend="2815" name="__init__" signature="Optional(exprs, default=_optionalNotMatched)"><variable citdl="Optional" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /><variable citdl="_NullToken" ilk="argument" name="default" /></scope><variable attributes="__instancevar__" citdl="_NullToken" line="2814" name="defaultValue" /><variable attributes="__instancevar__" citdl="True" line="2815" name="mayReturnEmpty" /><scope ilk="function" line="2817" lineend="2829" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Optional" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable citdl="list" line="2819" name="tokens" /></scope><scope ilk="function" line="2831" lineend="2838" name="__str__" returns="str" signature="__str__()"><variable citdl="Optional" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2836" name="strRepr" /></scope><scope classrefs="ParseElementEnhance" doc="Token for skipping over all undefined text until the matched expression is found.&#xA;If C{include} is set to true, the matched expression is also parsed (the skipped text&#xA;and matched expression are returned as a 2-element list).  The C{ignore}&#xA;argument is used to define grammars (typically quoted strings and comments) that&#xA;might contain false matches." ilk="class" line="2841" lineend="2904" name="SkipTo"><scope attributes="__ctor__" ilk="function" line="2848" lineend="2859" name="__init__" signature="SkipTo(other, include=False, ignore=None, failOn=None)"><variable citdl="SkipTo" ilk="argument" name="self" /><variable ilk="argument" name="other" /><variable citdl="False" ilk="argument" name="include" /><variable ilk="argument" name="ignore" /><variable ilk="argument" name="failOn" /></scope><variable attributes="__instancevar__" line="2850" name="ignoreExpr" /><variable attributes="__instancevar__" citdl="True" line="2851" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2852" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="2853" name="includeMatch" /><variable attributes="__instancevar__" citdl="False" line="2854" name="asList" /><variable attributes="__instancevar__" citdl="Literal" line="2856" name="failOn" /><variable attributes="__instancevar__" citdl="_ustr()" line="2859" name="errmsg" /><scope ilk="function" line="2861" lineend="2904" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="SkipTo" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable citdl="self.ignoreExpr.tryParse()" ilk="argument" name="loc" /><variable citdl="True" ilk="argument" name="doActions" /><variable line="2862" name="startLoc" /><variable citdl="len()" line="2863" name="instrlen" /><variable citdl="self.expr" line="2864" name="expr" /><variable citdl="False" line="2865" name="failParse" /><variable citdl="list" line="2885" name="skipText" /><variable line="2887" name="mat" /><variable citdl="ParseResults" line="2889" name="skipRes" /><variable citdl="self.myException" line="2901" name="exc" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Forward declaration of an expression to be defined later -&#xA;used for recursive grammars, such as algebraic infix notation.&#xA;When the expression is known, it is assigned to the C{Forward} variable using the &apos;&lt;&lt;&apos; operator.&#xA;&#xA;Note: take care when assigning to C{Forward} not to overlook precedence of operators.&#xA;Specifically, &apos;|&apos; has a lower precedence than &apos;&lt;&lt;&apos;, so that::&#xA;   fwdExpr &lt;&lt; a | b | c&#xA;will actually be evaluated as::&#xA;   (fwdExpr &lt;&lt; a) | b | c&#xA;thereby leaving b and c out as parseable alternatives.  It is recommended that you&#xA;explicitly group the values inserted into the C{Forward}::&#xA;   fwdExpr &lt;&lt; (a | b | c)" ilk="class" line="2906" lineend="2976" name="Forward"><scope attributes="__ctor__" ilk="function" line="2920" lineend="2921" name="__init__" signature="Forward(other=None)"><variable citdl="Forward" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="2923" lineend="2935" name="__lshift__" signature="__lshift__(other)"><variable citdl="Forward" ilk="argument" name="self" /><variable citdl="Literal" ilk="argument" name="other" /></scope><variable attributes="__instancevar__" citdl="Literal" line="2926" name="expr" /><variable attributes="__instancevar__" citdl="other.mayReturnEmpty" line="2927" name="mayReturnEmpty" /><variable attributes="__instancevar__" line="2928" name="strRepr" /><variable attributes="__instancevar__" citdl="self.expr.mayIndexError" line="2929" name="mayIndexError" /><variable attributes="__instancevar__" citdl="self.expr.skipWhitespace" line="2932" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="self.expr.saveAsList" line="2933" name="saveAsList" /><scope ilk="function" line="2937" lineend="2939" name="leaveWhitespace" returns="Forward" signature="leaveWhitespace()"><variable citdl="Forward" ilk="argument" name="self" /></scope><scope ilk="function" line="2941" lineend="2946" name="streamline" returns="Forward" signature="streamline()"><variable citdl="Forward" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="True" line="2943" name="streamlined" /><scope ilk="function" line="2948" lineend="2953" name="validate" signature="validate(validateTrace=[])"><variable citdl="Forward" ilk="argument" name="self" /><variable citdl="list" ilk="argument" name="validateTrace" /><variable citdl="list" line="2950" name="tmp" /></scope><scope ilk="function" line="2955" lineend="2968" name="__str__" returns="str" signature="__str__()"><variable citdl="Forward" ilk="argument" name="self" /><variable citdl="_ustr()" line="2963" name="retString" /></scope><variable attributes="protected __instancevar__" citdl="self.__class__" line="2959" name="_revertClass" /><variable attributes="__instancevar__" citdl="self.__class__" line="2960" name="__class__" /><scope ilk="function" line="2970" lineend="2976" name="copy" signature="copy()"><variable citdl="Forward" ilk="argument" name="self" /><variable citdl="" line="2974" name="ret" /></scope></scope><scope attributes="protected" classrefs="Forward" ilk="class" line="2978" lineend="2980" name="_ForwardNoRecurse"><scope ilk="function" line="2979" lineend="2980" name="__str__" returns="str" signature="__str__()"><variable citdl="_ForwardNoRecurse" ilk="argument" name="self" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Abstract subclass of C{ParseExpression}, for converting parsed results." ilk="class" line="2982" lineend="2986" name="TokenConverter"><scope attributes="__ctor__" ilk="function" line="2984" lineend="2986" name="__init__" signature="TokenConverter(expr, savelist=False)"><variable citdl="TokenConverter" ilk="argument" name="self" /><variable ilk="argument" name="expr" /><variable citdl="False" ilk="argument" name="savelist" /></scope><variable attributes="__instancevar__" citdl="False" line="2986" name="saveAsList" /></scope><scope classrefs="TokenConverter" doc="Converter to upper case all matching tokens." ilk="class" line="2988" lineend="2996" name="Upcase"><scope attributes="__ctor__" ilk="function" line="2990" lineend="2993" name="__init__" signature="Upcase(*args)"><variable citdl="Upcase" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><scope ilk="function" line="2995" lineend="2996" name="postParse" returns="list()" signature="postParse(instring, loc, tokenlist)"><variable citdl="Upcase" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /></scope></scope><scope classrefs="TokenConverter" doc="Converter to concatenate all matching tokens to a single string.&#xA;By default, the matching patterns must also be contiguous in the input string;&#xA;this can be disabled by specifying C{&apos;adjacent=False&apos;} in the constructor." ilk="class" line="2999" lineend="3029" name="Combine"><scope attributes="__ctor__" ilk="function" line="3004" lineend="3012" name="__init__" signature="Combine(expr, joinString=&apos;&apos;, adjacent=True)"><variable citdl="Combine" ilk="argument" name="self" /><variable ilk="argument" name="expr" /><variable citdl="str" ilk="argument" name="joinString" /><variable citdl="True" ilk="argument" name="adjacent" /></scope><variable attributes="__instancevar__" citdl="True" line="3009" name="adjacent" /><variable attributes="__instancevar__" citdl="True" line="3010" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="3011" name="joinString" /><variable attributes="__instancevar__" citdl="True" line="3012" name="callPreparse" /><scope ilk="function" line="3014" lineend="3019" name="ignore" returns="Combine" signature="ignore(other)"><variable citdl="Combine" ilk="argument" name="self" /><variable ilk="argument" name="other" /></scope><scope ilk="function" line="3021" lineend="3029" name="postParse" returns="tokenlist.copy()" signature="postParse(instring, loc, tokenlist)"><variable citdl="Combine" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /><variable citdl="tokenlist.copy()" line="3022" name="retToks" /></scope></scope><scope classrefs="TokenConverter" doc="Converter to return the matched tokens as a list - useful for returning tokens of C{ZeroOrMore} and C{OneOrMore} expressions." ilk="class" line="3031" lineend="3038" name="Group"><scope attributes="__ctor__" ilk="function" line="3033" lineend="3035" name="__init__" signature="Group(expr)"><variable citdl="Group" ilk="argument" name="self" /><variable ilk="argument" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="3035" name="saveAsList" /><scope ilk="function" line="3037" lineend="3038" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Group" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /></scope></scope><scope classrefs="TokenConverter" doc="Converter to return a repetitive expression as a list, but also as a dictionary.&#xA;Each element can also be referenced using the first token in the expression as its key.&#xA;Useful for tabular report scraping when the first column can be used as a item key." ilk="class" line="3040" lineend="3071" name="Dict"><scope attributes="__ctor__" ilk="function" line="3045" lineend="3047" name="__init__" signature="Dict(exprs)"><variable citdl="Dict" ilk="argument" name="self" /><variable ilk="argument" name="exprs" /></scope><variable attributes="__instancevar__" citdl="True" line="3047" name="saveAsList" /><scope ilk="function" line="3049" lineend="3071" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Dict" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /><variable line="3053" name="ikey" /><variable citdl="tok.copy()" line="3061" name="dictvalue" /></scope></scope><scope classrefs="TokenConverter" doc="Converter for ignoring the results of a parsed expression." ilk="class" line="3074" lineend="3080" name="Suppress"><scope ilk="function" line="3076" lineend="3077" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Suppress" ilk="argument" name="self" /><variable ilk="argument" name="instring" /><variable ilk="argument" name="loc" /><variable ilk="argument" name="tokenlist" /></scope><scope ilk="function" line="3079" lineend="3080" name="suppress" returns="Suppress" signature="suppress()"><variable citdl="Suppress" ilk="argument" name="self" /></scope></scope><scope classrefs="object" doc="Wrapper for parse actions, to ensure they are only called once." ilk="class" line="3083" lineend="3095" name="OnlyOnce"><scope attributes="__ctor__" ilk="function" line="3085" lineend="3087" name="__init__" signature="OnlyOnce(methodCall)"><variable citdl="OnlyOnce" ilk="argument" name="self" /><variable ilk="argument" name="methodCall" /></scope><variable attributes="__instancevar__" citdl="_trim_arity()" line="3086" name="callable" /><variable attributes="__instancevar__" citdl="False" line="3087" name="called" /><scope ilk="function" line="3088" lineend="3093" name="__call__" returns="callable()" signature="__call__(s, l, t)"><variable citdl="OnlyOnce" ilk="argument" name="self" /><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="callable()" line="3090" name="results" /></scope><scope ilk="function" line="3094" lineend="3095" name="reset" signature="reset()"><variable citdl="OnlyOnce" ilk="argument" name="self" /></scope></scope><scope doc="Decorator for debugging parse actions." ilk="function" line="3097" lineend="3118" name="traceParseAction" returns="traceParseAction.z" signature="traceParseAction(f)"><variable citdl="_trim_arity()" ilk="argument" name="f" /><scope ilk="function" line="3100" lineend="3113" name="z" returns="f()" signature="z(*paArgs)"><variable attributes="varargs" ilk="argument" name="paArgs" /><variable citdl="f.func_name" line="3101" name="thisFunc" /><variable citdl="f()" line="3107" name="ret" /><variable line="3109" name="exc" /><variable citdl="f.__name__" line="3115" name="__name__" /></scope></scope><scope doc="Helper to define a delimited list of expressions - the delimiter defaults to &apos;,&apos;.&#xA;By default, the list elements and delimiters can have intervening whitespace, and&#xA;comments, but this can be overridden by passing C{combine=True} in the constructor.&#xA;If C{combine} is set to True, the matching tokens are returned as a single token&#xA;string, with the delimiters included; otherwise, the matching tokens are returned&#xA;as a list of tokens, with the delimiters suppressed." ilk="function" line="3123" lineend="3135" name="delimitedList" signature="delimitedList(expr, delim=&apos;,&apos;, combine=False)"><variable ilk="argument" name="expr" /><variable citdl="str" ilk="argument" name="delim" /><variable citdl="False" ilk="argument" name="combine" /><variable citdl="_ustr()" line="3131" name="dlName" /></scope><scope doc="Helper to define a counted list of expressions.&#xA;This helper defines a pattern of the form::&#xA;    integer expr expr expr...&#xA;where the leading integer tells how many expr expressions follow.&#xA;The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed." ilk="function" line="3137" lineend="3155" name="countedArray" returns="intExpr.copy()" signature="countedArray(expr, intExpr=None)"><variable ilk="argument" name="expr" /><variable citdl="intExpr.copy()" ilk="argument" name="intExpr" /><variable citdl="Forward" line="3144" name="arrayExpr" /><scope ilk="function" line="3145" lineend="3148" name="countFieldParseAction" returns="list" signature="countFieldParseAction(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable line="3146" name="n" /></scope></scope><scope attributes="protected" ilk="function" line="3157" lineend="3164" name="_flatten" returns="list" signature="_flatten(L)"><variable ilk="argument" name="L" /><variable citdl="list" line="3158" name="ret" /></scope><scope doc="Helper to define an expression that is indirectly defined from&#xA;the tokens matched in a previous expression, that is, it looks&#xA;for a &apos;repeat&apos; of a previous expression.  For example::&#xA;    first = Word(nums)&#xA;    second = matchPreviousLiteral(first)&#xA;    matchExpr = first + &quot;:&quot; + second&#xA;will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches a&#xA;previous literal, will also match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;}.&#xA;If this is not desired, use C{matchPreviousExpr}.&#xA;Do *not* use with packrat parsing enabled." ilk="function" line="3166" lineend="3190" name="matchPreviousLiteral" returns="Forward" signature="matchPreviousLiteral(expr)"><variable ilk="argument" name="expr" /><variable citdl="Forward" line="3178" name="rep" /><scope ilk="function" line="3179" lineend="3188" name="copyTokenToRepeater" signature="copyTokenToRepeater(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="_flatten()" line="3185" name="tflat" /></scope></scope><scope doc="Helper to define an expression that is indirectly defined from&#xA;the tokens matched in a previous expression, that is, it looks&#xA;for a &apos;repeat&apos; of a previous expression.  For example::&#xA;    first = Word(nums)&#xA;    second = matchPreviousExpr(first)&#xA;    matchExpr = first + &quot;:&quot; + second&#xA;will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches by&#xA;expressions, will *not* match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;};&#xA;the expressions are evaluated first, and then compared, so&#xA;C{&quot;1&quot;} is compared with C{&quot;10&quot;}.&#xA;Do *not* use with packrat parsing enabled." ilk="function" line="3192" lineend="3216" name="matchPreviousExpr" returns="Forward" signature="matchPreviousExpr(expr)"><variable ilk="argument" name="expr" /><variable citdl="Forward" line="3205" name="rep" /><variable citdl="expr.copy()" line="3206" name="e2" /><scope ilk="function" line="3208" lineend="3214" name="copyTokenToRepeater" signature="copyTokenToRepeater(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="_flatten()" line="3209" name="matchTokens" /><scope ilk="function" line="3210" lineend="3213" name="mustMatchTheseTokens" signature="mustMatchTheseTokens(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="_flatten()" line="3211" name="theseTokens" /></scope></scope></scope><scope attributes="protected" ilk="function" line="3218" lineend="3224" name="_escapeRegexRangeChars" returns="_ustr()" signature="_escapeRegexRangeChars(s)"><variable citdl="s.replace()" ilk="argument" name="s" /></scope><scope doc="Helper to quickly define a set of alternative Literals, and makes sure to do&#xA;longest-first testing when there is a conflict, regardless of the input order,&#xA;but returns a C{MatchFirst} for best performance.&#xA;&#xA;Parameters:&#xA; - strs - a string of space-delimited literals, or a list of string literals&#xA; - caseless - (default=False) - treat all literals as caseless&#xA; - useRegex - (default=True) - as an optimization, will generate a Regex&#xA;   object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or&#xA;   if creating a C{Regex} raises an exception)" ilk="function" line="3226" lineend="3283" name="oneOf" returns="MatchFirst" signature="oneOf(strs, caseless=False, useRegex=True)"><variable ilk="argument" name="strs" /><variable citdl="False" ilk="argument" name="caseless" /><variable citdl="True" ilk="argument" name="useRegex" /><variable line="3239" name="isequal" /><variable line="3240" name="masks" /><variable citdl="Literal" line="3241" name="parseElementClass" /><variable citdl="strs.split()" line="3248" name="symbols" /><variable citdl="int" line="3255" name="i" /><variable citdl="other" line="3257" name="cur" /></scope><scope doc="Helper to easily and clearly define a dictionary by specifying the respective patterns&#xA;for the key and value.  Takes care of defining the C{Dict}, C{ZeroOrMore}, and C{Group} tokens&#xA;in the proper order.  The key pattern can include delimiting markers or punctuation,&#xA;as long as they are suppressed, thereby leaving the significant key text.  The value&#xA;pattern can include named results, so that the C{Dict} results can include named token&#xA;fields." ilk="function" line="3285" lineend="3293" name="dictOf" returns="Dict" signature="dictOf(key, value)"><variable ilk="argument" name="key" /><variable ilk="argument" name="value" /></scope><scope doc="Helper to return the original, untokenized text for a given expression.  Useful to&#xA;restore the parsed fields of an HTML start tag into the raw tag text itself, or to&#xA;revert separate tokens with intervening whitespace back to the original matching&#xA;input text. Simpler to use than the parse action C{L{keepOriginalText}}, and does not&#xA;require the inspect module to chase up the call stack.  By default, returns a &#xA;string containing the original parsed text.  &#xA;&#xA;If the optional C{asString} argument is passed as C{False}, then the return value is a &#xA;C{ParseResults} containing any results names that were originally matched, and a &#xA;single token containing the original matched text from the input string.  So if &#xA;the expression passed to C{L{originalTextFor}} contains expressions with defined&#xA;results names, you must set C{asString} to C{False} if you want to preserve those&#xA;results name values." ilk="function" line="3295" lineend="3322" name="originalTextFor" returns="originalTextFor.locMarker()" signature="originalTextFor(expr, asString=True)"><variable ilk="argument" name="expr" /><variable citdl="True" ilk="argument" name="asString" /><variable line="3309" name="locMarker" /><variable citdl="locMarker.copy()" line="3310" name="endlocMarker" /><variable citdl="originalTextFor.endlocMarker()" line="3312" name="matchExpr" /><scope ilk="function" line="3316" lineend="3320" name="extractText" signature="extractText(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /></scope></scope><scope doc="Helper to undo pyparsing&apos;s default grouping of And expressions, even&#xA;if all but one are non-empty." ilk="function" line="3324" lineend="3327" name="ungroup" signature="ungroup(expr)"><variable ilk="argument" name="expr" /></scope><variable line="3330" name="empty" /><variable line="3331" name="lineStart" /><variable line="3332" name="lineEnd" /><variable line="3333" name="stringStart" /><variable line="3334" name="stringEnd" /><variable attributes="protected" line="3336" name="_escapedPunc" /><variable attributes="protected" citdl="__builtins__.str.join()" line="3337" name="_printables_less_backslash" /><variable attributes="protected" line="3338" name="_escapedHexChar" /><variable attributes="protected" line="3339" name="_escapedOctChar" /><variable attributes="protected" citdl="int" line="3340" name="_singleChar" /><variable attributes="protected" citdl="Group" line="3341" name="_charRange" /><variable attributes="protected" citdl="Literal" line="3342" name="_reBracketExpr" /><variable attributes="protected" line="3344" name="_expanded" /><scope doc="Helper to easily define string ranges for use in Word construction.  Borrows&#xA;syntax from regexp &apos;[]&apos; string range definitions::&#xA;   srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot;&#xA;   srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;&#xA;   srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;&#xA;The input string must be enclosed in []&apos;s, and the returned string is the expanded&#xA;character set joined into a single string.&#xA;The values enclosed in the []&apos;s may be::&#xA;   a single character&#xA;   an escaped character with a leading backslash (such as \- or \])&#xA;   an escaped hex character with a leading &apos;\x&apos; (\x21, which is a &apos;!&apos; character) &#xA;     (\0x## is also supported for backwards compatibility) &#xA;   an escaped octal character with a leading &apos;\0&apos; (\041, which is a &apos;!&apos; character)&#xA;   a range of any of the above, separated by a dash (&apos;a-z&apos;, etc.)&#xA;   any combination of the above (&apos;aeiouy&apos;, &apos;a-zA-Z0-9_$&apos;, etc.)" ilk="function" line="3346" lineend="3366" name="srange" returns="str" signature="srange(s)"><variable ilk="argument" name="s" /></scope><scope doc="Helper method for defining parse actions that require matching at a specific&#xA;column in the input text." ilk="function" line="3368" lineend="3375" name="matchOnlyAtCol" returns="matchOnlyAtCol.verifyCol" signature="matchOnlyAtCol(n)"><variable ilk="argument" name="n" /><scope ilk="function" line="3372" lineend="3374" name="verifyCol" signature="verifyCol(strg, locn, toks)"><variable ilk="argument" name="strg" /><variable ilk="argument" name="locn" /><variable ilk="argument" name="toks" /></scope></scope><scope doc="Helper method for common parse actions that simply return a literal value.  Especially&#xA;useful when used with C{transformString()}." ilk="function" line="3377" lineend="3383" name="replaceWith" returns="replaceWith._replFunc" signature="replaceWith(replStr)"><variable ilk="argument" name="replStr" /><scope attributes="protected" ilk="function" line="3381" lineend="3382" name="_replFunc" returns="list" signature="_replFunc(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope></scope><scope doc="Helper parse action for removing quotation marks from parsed quoted strings.&#xA;To use, add this parse action to quoted string using::&#xA;  quotedString.setParseAction( removeQuotes )" ilk="function" line="3385" lineend="3390" name="removeQuotes" returns="list" signature="removeQuotes(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /></scope><scope doc="Helper parse action to convert tokens to upper case." ilk="function" line="3392" lineend="3394" name="upcaseTokens" returns="list" signature="upcaseTokens(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /></scope><scope doc="Helper parse action to convert tokens to lower case." ilk="function" line="3396" lineend="3398" name="downcaseTokens" returns="list" signature="downcaseTokens(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /></scope><scope doc="DEPRECATED - use new helper method C{originalTextFor}.&#xA;Helper parse action to preserve original parsed text,&#xA;overriding any nested parse actions." ilk="function" line="3400" lineend="3410" name="keepOriginalText" signature="keepOriginalText(s, startLoc, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="startLoc" /><variable ilk="argument" name="t" /><variable citdl="getTokensEndLoc()" line="3405" name="endloc" /></scope><scope doc="Method to be called from within a parse action to determine the end&#xA;location of the parsed tokens." ilk="function" line="3412" lineend="3426" name="getTokensEndLoc" signature="getTokensEndLoc()"><import line="3415" module="inspect" /><variable citdl="inspect.stack()" line="3416" name="fstack" /><variable line="3421" name="endloc" /></scope><scope attributes="protected" doc="Internal helper to construct opening and closing tag expressions, given a tag name" ilk="function" line="3428" lineend="3455" name="_makeTags" returns="tuple" signature="_makeTags(tagStr, xml)"><variable citdl="Keyword" ilk="argument" name="tagStr" /><variable ilk="argument" name="xml" /><variable citdl="tagStr.name" line="3431" name="resname" /><variable citdl="Word" line="3436" name="tagAttrName" /><variable citdl="int" line="3438" name="tagAttrValue" /><variable citdl="Suppress" line="3439" name="openTag" /><variable citdl="__builtins__.str.join()" line="3443" name="printablesLessRAbrack" /><variable citdl="Combine" line="3449" name="closeTag" /></scope><scope doc="Helper to construct opening and closing tag expressions for HTML, given a tag name" ilk="function" line="3457" lineend="3459" name="makeHTMLTags" returns="_makeTags()" signature="makeHTMLTags(tagStr)"><variable ilk="argument" name="tagStr" /></scope><scope doc="Helper to construct opening and closing tag expressions for XML, given a tag name" ilk="function" line="3461" lineend="3463" name="makeXMLTags" returns="_makeTags()" signature="makeXMLTags(tagStr)"><variable ilk="argument" name="tagStr" /></scope><scope doc="Helper to create a validating parse action to be used with start tags created&#xA;with C{makeXMLTags} or C{makeHTMLTags}. Use C{withAttribute} to qualify a starting tag&#xA;with a required attribute value, to avoid false matches on common tags such as&#xA;C{&lt;TD&gt;} or C{&lt;DIV&gt;}.&#xA;&#xA;Call C{withAttribute} with a series of attribute names and values. Specify the list&#xA;of filter attributes names and values as:&#xA; - keyword arguments, as in C{(align=&quot;right&quot;)}, or&#xA; - as an explicit dict with C{**} operator, when an attribute name is also a Python&#xA;   reserved word, as in C{**{&quot;class&quot;:&quot;Customer&quot;, &quot;align&quot;:&quot;right&quot;}}&#xA; - a list of name-value tuples, as in ( (&quot;ns1:class&quot;, &quot;Customer&quot;), (&quot;ns2:align&quot;,&quot;right&quot;) )&#xA;For attribute names with a namespace prefix, you must use the second form.  Attribute&#xA;names are matched insensitive to upper/lower case.&#xA;&#xA;To verify that the attribute exists, but without specifying a value, pass&#xA;C{withAttribute.ANY_VALUE} as the value." ilk="function" line="3465" lineend="3495" name="withAttribute" returns="withAttribute.pa" signature="withAttribute(*args, **attrDict)"><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="attrDict" /><variable citdl="list" line="3484" name="attrs" /><scope ilk="function" line="3488" lineend="3494" name="pa" signature="pa(s, l, tokens)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="tokens" /></scope><variable citdl="object()" line="3496" name="ANY_VALUE" /></scope><variable citdl="_Constants" line="3498" name="opAssoc" /><scope doc="Helper method for constructing grammars of expressions made up of&#xA;operators working in a precedence hierarchy.  Operators may be unary or&#xA;binary, left- or right-associative.  Parse actions can also be attached&#xA;to operator expressions.&#xA;&#xA;Parameters:&#xA; - baseExpr - expression representing the most basic element for the nested&#xA; - opList - list of tuples, one for each operator precedence level in the&#xA;   expression grammar; each tuple is of the form&#xA;   (opExpr, numTerms, rightLeftAssoc, parseAction), where:&#xA;    - opExpr is the pyparsing expression for the operator;&#xA;       may also be a string, which will be converted to a Literal;&#xA;       if numTerms is 3, opExpr is a tuple of two expressions, for the&#xA;       two operators separating the 3 terms&#xA;    - numTerms is the number of terms for this operator (must&#xA;       be 1, 2, or 3)&#xA;    - rightLeftAssoc is the indicator whether the operator is&#xA;       right or left associative, using the pyparsing-defined&#xA;       constants opAssoc.RIGHT and opAssoc.LEFT.&#xA;    - parseAction is the parse action to be associated with&#xA;       expressions matching this operator expression (the&#xA;       parse action tuple member may be omitted)" ilk="function" line="3502" lineend="3571" name="operatorPrecedence" returns="Forward" signature="operatorPrecedence(baseExpr, opList)"><variable ilk="argument" name="baseExpr" /><variable ilk="argument" name="opList" /><variable citdl="Forward" line="3526" name="ret" /><variable citdl="int" line="3527" name="lastExpr" /><variable citdl="Forward" line="3534" name="thisExpr" /><variable citdl="FollowedBy" line="3537" name="matchExpr" /><variable citdl="Optional" line="3552" name="opExpr" /></scope><variable line="3573" name="dblQuotedString" /><variable line="3574" name="sglQuotedString" /><variable line="3575" name="quotedString" /><variable citdl="Combine" line="3576" name="unicodeString" /><scope doc="Helper method for defining nested lists enclosed in opening and closing&#xA;delimiters (&quot;(&quot; and &quot;)&quot; are the default).&#xA;&#xA;Parameters:&#xA; - opener - opening character for a nested list (default=&quot;(&quot;); can also be a pyparsing expression&#xA; - closer - closing character for a nested list (default=&quot;)&quot;); can also be a pyparsing expression&#xA; - content - expression for items within the nested lists (default=None)&#xA; - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString)&#xA;&#xA;If an expression is not provided for the content argument, the nested&#xA;expression will capture all whitespace-delimited content between delimiters&#xA;as a list of separate values.&#xA;&#xA;Use the C{ignoreExpr} argument to define expressions that may contain&#xA;opening or closing characters that should not be treated as opening&#xA;or closing characters for nesting, such as quotedString or a comment&#xA;expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.&#xA;The default is L{quotedString}, but if no expressions are to be ignored,&#xA;then pass C{None} for this argument." ilk="function" line="3578" lineend="3628" name="nestedExpr" returns="Forward" signature="nestedExpr(opener=&apos;(&apos;, closer=&apos;)&apos;, content=None, ignoreExpr=quotedString.copy())"><variable citdl="str" ilk="argument" name="opener" /><variable citdl="str" ilk="argument" name="closer" /><variable citdl="empty.copy()" ilk="argument" name="content" /><variable citdl="quotedString.copy()" ilk="argument" name="ignoreExpr" /><variable citdl="Forward" line="3623" name="ret" /></scope><scope doc="Helper method for defining space-delimited indentation blocks, such as&#xA;those used to define block statements in Python source code.&#xA;&#xA;Parameters:&#xA; - blockStatementExpr - expression defining syntax of statement that&#xA;     is repeated within the indented block&#xA; - indentStack - list created by caller to manage indentation stack&#xA;     (multiple statementWithIndentedBlock expressions within a single grammar&#xA;     should share a common indentStack)&#xA; - indent - boolean indicating whether block must be indented beyond the&#xA;     the current level; set to False for block of left-most statements&#xA;     (default=True)&#xA;&#xA;A valid block must contain at least one C{blockStatement}." ilk="function" line="3630" lineend="3680" name="indentedBlock" returns="Group" signature="indentedBlock(blockStatementExpr, indentStack, indent=True)"><variable ilk="argument" name="blockStatementExpr" /><variable ilk="argument" name="indentStack" /><variable citdl="True" ilk="argument" name="indent" /><scope ilk="function" line="3646" lineend="3652" name="checkPeerIndent" signature="checkPeerIndent(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="col()" line="3648" name="curCol" /></scope><scope ilk="function" line="3654" lineend="3659" name="checkSubIndent" signature="checkSubIndent(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="col()" line="3655" name="curCol" /></scope><scope ilk="function" line="3661" lineend="3666" name="checkUnindent" signature="checkUnindent(s, l, t)"><variable ilk="argument" name="s" /><variable ilk="argument" name="l" /><variable ilk="argument" name="t" /><variable citdl="col()" line="3663" name="curCol" /></scope><variable citdl="OneOrMore" line="3668" name="NL" /><variable citdl="Empty" line="3669" name="INDENT" /><variable line="3670" name="PEER" /><variable line="3671" name="UNDENT" /><variable citdl="Group" line="3673" name="smExpr" /></scope><variable citdl="srange()" line="3682" name="alphas8bit" /><variable citdl="srange()" line="3683" name="punc8bit" /><variable line="3685" name="anyCloseTag" /><variable line="3685" name="anyOpenTag" /><variable line="3686" name="commonHTMLEntity" /><variable attributes="protected" citdl="dict()" line="3687" name="_htmlEntityMap" /><variable line="3688" name="replaceHTMLEntity" /><variable line="3691" name="cStyleComment" /><variable citdl="Regex" line="3693" name="htmlComment" /><variable line="3694" name="restOfLine" /><variable line="3695" name="dblSlashComment" /><variable line="3696" name="cppStyleComment" /><variable line="3698" name="javaStyleComment" /><variable line="3699" name="pythonStyleComment" /><variable attributes="protected" citdl="__builtins__.str.join()" line="3700" name="_noncomma" /><variable attributes="protected" line="3701" name="_commasepitem" /><variable line="3704" name="commaSeparatedList" /><scope ilk="function" line="3709" lineend="3724" name="test" signature="test(teststring)"><variable ilk="argument" name="teststring" /><variable citdl="simpleSQL.parseString()" line="3711" name="tokens" /><variable citdl="tokens.asList()" line="3712" name="tokenlist" /><variable line="3719" name="err" /></scope><variable citdl="CaselessLiteral" line="3726" name="selectToken" /><variable citdl="CaselessLiteral" line="3727" name="fromToken" /><variable citdl="Word" line="3729" name="ident" /><variable line="3730" name="columnName" /><variable citdl="Group" line="3731" name="columnNameList" /><variable line="3732" name="tableName" /><variable citdl="Group" line="3733" name="tableNameList" /><variable citdl="CaselessLiteral" line="3734" name="simpleSQL" /></scope>