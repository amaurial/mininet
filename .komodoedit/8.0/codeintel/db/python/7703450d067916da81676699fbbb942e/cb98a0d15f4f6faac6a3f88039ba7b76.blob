<scope doc="Xapian is a highly adaptable toolkit which allows developers&#xA;to easily add advanced indexing and search facilities to&#xA;their own applications." ilk="blob" lang="Python" name="__init__" src="/usr/lib/python2.7/dist-packages/xapian/__init__.py"><import line="22" module="sys" symbol="version_info" /><import alias="new_instancemethod" line="26" module="new" symbol="instancemethod" /><import line="46" module="_xapian" /><import line="98" module="weakref" /><variable line="24" name="new_instancemethod" /><scope ilk="function" line="28" lineend="42" name="swig_import_helper" returns="_xapian" signature="swig_import_helper()"><import line="29" module="os.path" symbol="dirname" /><import line="30" module="imp" /><import line="35" module="_xapian" /><variable line="31" name="fp" /><variable line="33" name="pathname" /><variable line="33" name="description" /><variable attributes="protected" citdl="imp.load_module()" line="39" name="_mod" /></scope><variable attributes="protected" citdl="swig_import_helper()" line="43" name="_xapian" /><variable attributes="protected" citdl="property" line="49" name="_swig_property" /><scope attributes="protected" ilk="function" line="52" lineend="63" name="_swig_setattr_nondynamic" returns="_swig_setattr_nondynamic.method()" signature="_swig_setattr_nondynamic(self, class_type, name, value, static=1)"><variable ilk="argument" name="self" /><variable ilk="argument" name="class_type" /><variable ilk="argument" name="name" /><variable ilk="argument" name="value" /><variable citdl="int" ilk="argument" name="static" /><variable citdl="class_type.__swig_setmethods__.get()" line="58" name="method" /></scope><scope attributes="protected" ilk="function" line="65" lineend="66" name="_swig_setattr" returns="_swig_setattr_nondynamic()" signature="_swig_setattr(self, class_type, name, value)"><variable ilk="argument" name="self" /><variable ilk="argument" name="class_type" /><variable ilk="argument" name="name" /><variable ilk="argument" name="value" /></scope><scope attributes="protected" ilk="function" line="68" lineend="72" name="_swig_getattr" returns="_swig_getattr.method()" signature="_swig_getattr(self, class_type, name)"><variable ilk="argument" name="self" /><variable ilk="argument" name="class_type" /><variable ilk="argument" name="name" /><variable citdl="class_type.__swig_getmethods__.get()" line="70" name="method" /></scope><scope attributes="protected" ilk="function" line="74" lineend="77" name="_swig_repr" returns="tuple" signature="_swig_repr(self)"><variable ilk="argument" name="self" /><variable citdl="str" line="75" name="strthis" /></scope><variable attributes="protected" citdl="int" line="81" name="_newclass" /><scope attributes="protected" ilk="class" line="83" lineend="83" name="_object" /><scope attributes="protected" ilk="function" line="87" lineend="94" name="_swig_setattr_nondynamic_method" returns="_swig_setattr_nondynamic_method.set_attr" signature="_swig_setattr_nondynamic_method(set)"><variable ilk="argument" name="set" /><scope ilk="function" line="88" lineend="93" name="set_attr" returns="self.this.own()" signature="set_attr(self, name, value)"><variable ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable ilk="argument" name="value" /></scope></scope><variable citdl="weakref.proxy" line="99" name="weakref_proxy" /><scope classrefs="object" ilk="class" line="104" lineend="109" name="SwigPyIterator"><variable citdl="_swig_property()" line="105" name="thisown" /><scope attributes="__ctor__" ilk="function" line="106" lineend="106" name="__init__" signature="SwigPyIterator(*args, **kwargs)"><variable citdl="SwigPyIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="107" name="__repr__" /><variable citdl="_xapian.delete_SwigPyIterator" line="108" name="__swig_destroy__" /><scope ilk="function" line="109" lineend="109" name="__iter__" returns="SwigPyIterator" signature="__iter__()"><variable citdl="SwigPyIterator" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="110" name="value" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="111" name="incr" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="112" name="decr" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="113" name="distance" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="114" name="equal" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="115" name="copy" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="116" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="117" name="__next__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="118" name="previous" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="119" name="advance" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="120" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="121" name="__ne__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="122" name="__iadd__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="123" name="__isub__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="124" name="__add__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="125" name="__sub__" /></scope><variable citdl="_xapian.SwigPyIterator_swigregister" line="126" name="SwigPyIterator_swigregister" /><variable citdl="_xapian.BAD_VALUENO" line="129" name="BAD_VALUENO" /><variable citdl="_xapian.MSET_DID" line="130" name="MSET_DID" /><variable citdl="_xapian.MSET_WT" line="131" name="MSET_WT" /><variable citdl="_xapian.MSET_RANK" line="132" name="MSET_RANK" /><variable citdl="_xapian.MSET_PERCENT" line="133" name="MSET_PERCENT" /><variable citdl="_xapian.MSET_DOCUMENT" line="134" name="MSET_DOCUMENT" /><variable citdl="_xapian.ESET_TNAME" line="135" name="ESET_TNAME" /><variable citdl="_xapian.ESET_WT" line="136" name="ESET_WT" /><scope classrefs="Exception" doc="All exceptions thrown by Xapian are subclasses of Xapian::Error.&#xA;&#xA;This class can not be instantiated directly - instead a subclass&#xA;should be used. " ilk="class" line="137" lineend="192" name="Error"><variable citdl="dict" line="144" name="__swig_setmethods__" /><variable line="145" name="__setattr__" /><variable citdl="dict" line="146" name="__swig_getmethods__" /><variable line="147" name="__getattr__" /><scope attributes="__ctor__" ilk="function" line="148" lineend="148" name="__init__" signature="Error(*args, **kwargs)"><variable citdl="Error" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="149" name="__repr__" /><variable attributes="__instancevar__" citdl="function" doc="The type of this error (e.g. &quot;DocNotFoundError&quot;.).&#xA;&#xA;const char* Xapian::Error::get_type() const " line="150" name="get_type" /><variable attributes="__instancevar__" citdl="function" doc="Message giving details of the error, intended for human consumption.&#xA;&#xA;const std::string&amp; Xapian::Error::get_msg() const " line="158" name="get_msg" /><variable attributes="__instancevar__" citdl="function" doc="Optional context information.&#xA;&#xA;const std::string&amp; Xapian::Error::get_context() const&#xA;&#xA;This context is intended for use by Xapian::ErrorHandler (for example&#xA;so it can know which remote server is unreliable and report the&#xA;problem and remove that server from those being searched). But it&apos;s&#xA;typically a plain-text string, and so also fit for human consumption.&#xA;" line="166" name="get_context" /><variable attributes="__instancevar__" citdl="function" doc="Returns any system error string associated with this exception.&#xA;&#xA;const char* Xapian::Error::get_error_string() const&#xA;&#xA;The system error string may come from errno, h_errno (on UNIX), or&#xA;GetLastError() (on MS Windows). If there is no associated system error&#xA;string, NULL is returned. " line="180" name="get_error_string" /><variable citdl="_xapian.delete_Error" line="192" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="197" name="__str__" /></scope><variable citdl="_xapian.Error_swigregister" line="198" name="Error_swigregister" /><scope classrefs="Error" doc="The base class for exceptions indicating errors in the program logic.&#xA;&#xA;A subclass of LogicError will be thrown if Xapian detects a violation&#xA;of a class invariant or a logical precondition or postcondition, etc.&#xA;" ilk="class" line="201" lineend="217" name="LogicError"><variable citdl="dict" line="209" name="__swig_setmethods__" /><variable line="211" name="__setattr__" /><variable citdl="dict" line="212" name="__swig_getmethods__" /><variable line="214" name="__getattr__" /><scope attributes="__ctor__" ilk="function" line="215" lineend="215" name="__init__" signature="LogicError(*args, **kwargs)"><variable citdl="LogicError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="216" name="__repr__" /><variable citdl="_xapian.delete_LogicError" line="217" name="__swig_destroy__" /></scope><variable citdl="_xapian.LogicError_swigregister" line="218" name="LogicError_swigregister" /><scope classrefs="Error" doc="The base class for exceptions indicating errors only detectable at&#xA;runtime.&#xA;&#xA;A subclass of RuntimeError will be thrown if Xapian detects an error&#xA;which is exception derived from RuntimeError is thrown when an error&#xA;is caused by problems with the data or environment rather than a&#xA;programming mistake. " ilk="class" line="221" lineend="239" name="RuntimeError"><variable citdl="dict" line="231" name="__swig_setmethods__" /><variable line="233" name="__setattr__" /><variable citdl="dict" line="234" name="__swig_getmethods__" /><variable line="236" name="__getattr__" /><scope attributes="__ctor__" ilk="function" line="237" lineend="237" name="__init__" signature="RuntimeError(*args, **kwargs)"><variable citdl="RuntimeError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="238" name="__repr__" /><variable citdl="_xapian.delete_RuntimeError" line="239" name="__swig_destroy__" /></scope><variable citdl="_xapian.RuntimeError_swigregister" line="240" name="RuntimeError_swigregister" /><scope classrefs="LogicError" doc="AssertionError is thrown if a logical assertion inside Xapian fails.&#xA;&#xA;In a debug build of Xapian, a failed assertion in the core library&#xA;code will cause AssertionError to be thrown.&#xA;&#xA;This represents a bug in Xapian (either an invariant, precondition,&#xA;etc has been violated, or the assertion is incorrect!) " ilk="class" line="243" lineend="276" name="AssertionError"><variable citdl="dict" line="253" name="__swig_setmethods__" /><variable line="255" name="__setattr__" /><variable citdl="dict" line="256" name="__swig_getmethods__" /><variable line="258" name="__getattr__" /><variable citdl="_swig_repr" line="259" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::AssertionError::AssertionError(const std::string &amp;msg_, int&#xA;errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="260" lineend="275" name="__init__" signature="AssertionError(*args)"><variable citdl="AssertionError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_AssertionError" line="276" name="__swig_destroy__" /></scope><variable citdl="_xapian.AssertionError_swigregister" line="277" name="AssertionError_swigregister" /><scope classrefs="LogicError" doc="InvalidArgumentError indicates an invalid parameter value was passed&#xA;to the API. " ilk="class" line="280" lineend="308" name="InvalidArgumentError"><variable citdl="dict" line="285" name="__swig_setmethods__" /><variable line="287" name="__setattr__" /><variable citdl="dict" line="288" name="__swig_getmethods__" /><variable line="290" name="__getattr__" /><variable citdl="_swig_repr" line="291" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::InvalidArgumentError::InvalidArgumentError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="292" lineend="307" name="__init__" signature="InvalidArgumentError(*args)"><variable citdl="InvalidArgumentError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_InvalidArgumentError" line="308" name="__swig_destroy__" /></scope><variable citdl="_xapian.InvalidArgumentError_swigregister" line="309" name="InvalidArgumentError_swigregister" /><scope classrefs="LogicError" doc="InvalidOperationError indicates the API was used in an invalid way. " ilk="class" line="312" lineend="339" name="InvalidOperationError"><variable citdl="dict" line="316" name="__swig_setmethods__" /><variable line="318" name="__setattr__" /><variable citdl="dict" line="319" name="__swig_getmethods__" /><variable line="321" name="__getattr__" /><variable citdl="_swig_repr" line="322" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::InvalidOperationError::InvalidOperationError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="323" lineend="338" name="__init__" signature="InvalidOperationError(*args)"><variable citdl="InvalidOperationError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_InvalidOperationError" line="339" name="__swig_destroy__" /></scope><variable citdl="_xapian.InvalidOperationError_swigregister" line="340" name="InvalidOperationError_swigregister" /><scope classrefs="LogicError" doc="UnimplementedError indicates an attempt to use an unimplemented&#xA;feature. " ilk="class" line="343" lineend="371" name="UnimplementedError"><variable citdl="dict" line="348" name="__swig_setmethods__" /><variable line="350" name="__setattr__" /><variable citdl="dict" line="351" name="__swig_getmethods__" /><variable line="353" name="__getattr__" /><variable citdl="_swig_repr" line="354" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::UnimplementedError::UnimplementedError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="355" lineend="370" name="__init__" signature="UnimplementedError(*args)"><variable citdl="UnimplementedError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_UnimplementedError" line="371" name="__swig_destroy__" /></scope><variable citdl="_xapian.UnimplementedError_swigregister" line="372" name="UnimplementedError_swigregister" /><scope classrefs="RuntimeError" doc="DatabaseError indicates some sort of database related error. " ilk="class" line="375" lineend="402" name="DatabaseError"><variable citdl="dict" line="379" name="__swig_setmethods__" /><variable line="381" name="__setattr__" /><variable citdl="dict" line="382" name="__swig_getmethods__" /><variable line="384" name="__getattr__" /><variable citdl="_swig_repr" line="385" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseError::DatabaseError(const std::string &amp;msg_, int&#xA;errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="386" lineend="401" name="__init__" signature="DatabaseError(*args)"><variable citdl="DatabaseError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseError" line="402" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseError_swigregister" line="403" name="DatabaseError_swigregister" /><scope classrefs="DatabaseError" doc="DatabaseCorruptError indicates database corruption was detected. " ilk="class" line="406" lineend="433" name="DatabaseCorruptError"><variable citdl="dict" line="410" name="__swig_setmethods__" /><variable line="412" name="__setattr__" /><variable citdl="dict" line="413" name="__swig_getmethods__" /><variable line="415" name="__getattr__" /><variable citdl="_swig_repr" line="416" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseCorruptError::DatabaseCorruptError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="417" lineend="432" name="__init__" signature="DatabaseCorruptError(*args)"><variable citdl="DatabaseCorruptError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseCorruptError" line="433" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseCorruptError_swigregister" line="434" name="DatabaseCorruptError_swigregister" /><scope classrefs="DatabaseError" doc="DatabaseCreateError indicates a failure to create a database. " ilk="class" line="437" lineend="464" name="DatabaseCreateError"><variable citdl="dict" line="441" name="__swig_setmethods__" /><variable line="443" name="__setattr__" /><variable citdl="dict" line="444" name="__swig_getmethods__" /><variable line="446" name="__getattr__" /><variable citdl="_swig_repr" line="447" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseCreateError::DatabaseCreateError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="448" lineend="463" name="__init__" signature="DatabaseCreateError(*args)"><variable citdl="DatabaseCreateError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseCreateError" line="464" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseCreateError_swigregister" line="465" name="DatabaseCreateError_swigregister" /><scope classrefs="DatabaseError" doc="DatabaseLockError indicates failure to lock a database. " ilk="class" line="468" lineend="495" name="DatabaseLockError"><variable citdl="dict" line="472" name="__swig_setmethods__" /><variable line="474" name="__setattr__" /><variable citdl="dict" line="475" name="__swig_getmethods__" /><variable line="477" name="__getattr__" /><variable citdl="_swig_repr" line="478" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseLockError::DatabaseLockError(const std::string &amp;msg_,&#xA;int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="479" lineend="494" name="__init__" signature="DatabaseLockError(*args)"><variable citdl="DatabaseLockError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseLockError" line="495" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseLockError_swigregister" line="496" name="DatabaseLockError_swigregister" /><scope classrefs="DatabaseError" doc="DatabaseModifiedError indicates a database was modified.&#xA;&#xA;To recover after catching this error, you need to call&#xA;Xapian::Database::reopen() on the Database and repeat the operation&#xA;which failed. " ilk="class" line="499" lineend="530" name="DatabaseModifiedError"><variable citdl="dict" line="507" name="__swig_setmethods__" /><variable line="509" name="__setattr__" /><variable citdl="dict" line="510" name="__swig_getmethods__" /><variable line="512" name="__getattr__" /><variable citdl="_swig_repr" line="513" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseModifiedError::DatabaseModifiedError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="514" lineend="529" name="__init__" signature="DatabaseModifiedError(*args)"><variable citdl="DatabaseModifiedError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseModifiedError" line="530" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseModifiedError_swigregister" line="531" name="DatabaseModifiedError_swigregister" /><scope classrefs="DatabaseError" doc="DatabaseOpeningError indicates failure to open a database. " ilk="class" line="534" lineend="561" name="DatabaseOpeningError"><variable citdl="dict" line="538" name="__swig_setmethods__" /><variable line="540" name="__setattr__" /><variable citdl="dict" line="541" name="__swig_getmethods__" /><variable line="543" name="__getattr__" /><variable citdl="_swig_repr" line="544" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseOpeningError::DatabaseOpeningError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="545" lineend="560" name="__init__" signature="DatabaseOpeningError(*args)"><variable citdl="DatabaseOpeningError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseOpeningError" line="561" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseOpeningError_swigregister" line="562" name="DatabaseOpeningError_swigregister" /><scope classrefs="DatabaseOpeningError" doc="DatabaseVersionError indicates that a database is in an unsupported&#xA;format.&#xA;&#xA;From time to time, new versions of Xapian will require the database&#xA;format to be changed, to allow new information to be stored or new&#xA;optimisations to be performed. Backwards compatibility will sometimes&#xA;be maintained, so that new versions of Xapian can open old databases,&#xA;but in some cases Xapian will be unable to open a database because it&#xA;is in too old (or new) a format. This can be resolved either be&#xA;upgrading or downgrading the version of Xapian in use, or by&#xA;rebuilding the database from scratch with the current version of&#xA;Xapian. " ilk="class" line="565" lineend="603" name="DatabaseVersionError"><variable citdl="dict" line="580" name="__swig_setmethods__" /><variable line="582" name="__setattr__" /><variable citdl="dict" line="583" name="__swig_getmethods__" /><variable line="585" name="__getattr__" /><variable citdl="_swig_repr" line="586" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DatabaseVersionError::DatabaseVersionError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="587" lineend="602" name="__init__" signature="DatabaseVersionError(*args)"><variable citdl="DatabaseVersionError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DatabaseVersionError" line="603" name="__swig_destroy__" /></scope><variable citdl="_xapian.DatabaseVersionError_swigregister" line="604" name="DatabaseVersionError_swigregister" /><scope classrefs="RuntimeError" doc="Indicates an attempt to access a document not present in the database.&#xA;" ilk="class" line="607" lineend="635" name="DocNotFoundError"><variable citdl="dict" line="612" name="__swig_setmethods__" /><variable line="614" name="__setattr__" /><variable citdl="dict" line="615" name="__swig_getmethods__" /><variable line="617" name="__getattr__" /><variable citdl="_swig_repr" line="618" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::DocNotFoundError::DocNotFoundError(const std::string &amp;msg_,&#xA;int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="619" lineend="634" name="__init__" signature="DocNotFoundError(*args)"><variable citdl="DocNotFoundError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DocNotFoundError" line="635" name="__swig_destroy__" /></scope><variable citdl="_xapian.DocNotFoundError_swigregister" line="636" name="DocNotFoundError_swigregister" /><scope classrefs="RuntimeError" doc="Indicates an attempt to use a feature which is unavailable.&#xA;&#xA;Typically a feature is unavailable because it wasn&apos;t compiled in, or&#xA;because it requires other software or facilities which aren&apos;t&#xA;available. " ilk="class" line="639" lineend="670" name="FeatureUnavailableError"><variable citdl="dict" line="647" name="__swig_setmethods__" /><variable line="649" name="__setattr__" /><variable citdl="dict" line="650" name="__swig_getmethods__" /><variable line="652" name="__getattr__" /><variable citdl="_swig_repr" line="653" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::FeatureUnavailableError::FeatureUnavailableError(const&#xA;std::string &amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="654" lineend="669" name="__init__" signature="FeatureUnavailableError(*args)"><variable citdl="FeatureUnavailableError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_FeatureUnavailableError" line="670" name="__swig_destroy__" /></scope><variable citdl="_xapian.FeatureUnavailableError_swigregister" line="671" name="FeatureUnavailableError_swigregister" /><scope classrefs="RuntimeError" doc="InternalError indicates a runtime problem of some sort. " ilk="class" line="674" lineend="701" name="InternalError"><variable citdl="dict" line="678" name="__swig_setmethods__" /><variable line="680" name="__setattr__" /><variable citdl="dict" line="681" name="__swig_getmethods__" /><variable line="683" name="__getattr__" /><variable citdl="_swig_repr" line="684" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::InternalError::InternalError(const std::string &amp;msg_, int&#xA;errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="685" lineend="700" name="__init__" signature="InternalError(*args)"><variable citdl="InternalError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_InternalError" line="701" name="__swig_destroy__" /></scope><variable citdl="_xapian.InternalError_swigregister" line="702" name="InternalError_swigregister" /><scope classrefs="RuntimeError" doc="Indicates a problem communicating with a remote database. " ilk="class" line="705" lineend="732" name="NetworkError"><variable citdl="dict" line="709" name="__swig_setmethods__" /><variable line="711" name="__setattr__" /><variable citdl="dict" line="712" name="__swig_getmethods__" /><variable line="714" name="__getattr__" /><variable citdl="_swig_repr" line="715" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::NetworkError::NetworkError(const std::string &amp;msg_, int&#xA;errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="716" lineend="731" name="__init__" signature="NetworkError(*args)"><variable citdl="NetworkError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_NetworkError" line="732" name="__swig_destroy__" /></scope><variable citdl="_xapian.NetworkError_swigregister" line="733" name="NetworkError_swigregister" /><scope classrefs="NetworkError" doc="Indicates a timeout expired while communicating with a remote&#xA;database. " ilk="class" line="736" lineend="764" name="NetworkTimeoutError"><variable citdl="dict" line="741" name="__swig_setmethods__" /><variable line="743" name="__setattr__" /><variable citdl="dict" line="744" name="__swig_getmethods__" /><variable line="746" name="__getattr__" /><variable citdl="_swig_repr" line="747" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::NetworkTimeoutError::NetworkTimeoutError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="748" lineend="763" name="__init__" signature="NetworkTimeoutError(*args)"><variable citdl="NetworkTimeoutError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_NetworkTimeoutError" line="764" name="__swig_destroy__" /></scope><variable citdl="_xapian.NetworkTimeoutError_swigregister" line="765" name="NetworkTimeoutError_swigregister" /><scope classrefs="RuntimeError" doc="Indicates a query string can&apos;t be parsed. " ilk="class" line="768" lineend="795" name="QueryParserError"><variable citdl="dict" line="772" name="__swig_setmethods__" /><variable line="774" name="__setattr__" /><variable citdl="dict" line="775" name="__swig_getmethods__" /><variable line="777" name="__getattr__" /><variable citdl="_swig_repr" line="778" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::QueryParserError::QueryParserError(const std::string &amp;msg_,&#xA;int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="779" lineend="794" name="__init__" signature="QueryParserError(*args)"><variable citdl="QueryParserError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_QueryParserError" line="795" name="__swig_destroy__" /></scope><variable citdl="_xapian.QueryParserError_swigregister" line="796" name="QueryParserError_swigregister" /><scope classrefs="RuntimeError" doc="Indicates an error in the std::string serialisation of an object. " ilk="class" line="799" lineend="826" name="SerialisationError"><variable citdl="dict" line="803" name="__swig_setmethods__" /><variable line="805" name="__setattr__" /><variable citdl="dict" line="806" name="__swig_getmethods__" /><variable line="808" name="__getattr__" /><variable citdl="_swig_repr" line="809" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::SerialisationError::SerialisationError(const std::string&#xA;&amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="810" lineend="825" name="__init__" signature="SerialisationError(*args)"><variable citdl="SerialisationError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_SerialisationError" line="826" name="__swig_destroy__" /></scope><variable citdl="_xapian.SerialisationError_swigregister" line="827" name="SerialisationError_swigregister" /><scope classrefs="RuntimeError" doc="RangeError indicates an attempt to access outside the bounds of a&#xA;container. " ilk="class" line="830" lineend="857" name="RangeError"><variable citdl="dict" line="835" name="__swig_setmethods__" /><variable line="837" name="__setattr__" /><variable citdl="dict" line="838" name="__swig_getmethods__" /><variable line="840" name="__getattr__" /><variable citdl="_swig_repr" line="841" name="__repr__" /><scope attributes="__ctor__" doc="Construct from message and errno value.&#xA;&#xA;Xapian::RangeError::RangeError(const std::string &amp;msg_, int errno_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;msg_:  Message giving details of the error, intended for human&#xA;consumption.&#xA;&#xA;errno_:  Optional errno value associated with this error. " ilk="function" line="842" lineend="856" name="__init__" signature="RangeError(*args)"><variable citdl="RangeError" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_RangeError" line="857" name="__swig_destroy__" /></scope><variable citdl="_xapian.RangeError_swigregister" line="858" name="RangeError_swigregister" /><variable citdl="function" line="862" name="version_string" /><variable citdl="function" line="866" name="major_version" /><variable citdl="function" line="870" name="minor_version" /><variable citdl="function" line="874" name="revision" /><scope classrefs="object" doc="An iterator pointing to items in a list of positions. " ilk="class" line="877" lineend="911" name="PositionIterator"><variable citdl="_swig_property()" line="881" name="thisown" /><variable citdl="_swig_repr" line="882" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed.&#xA;&#xA;Xapian::PositionIterator::PositionIterator(const PositionIterator &amp;o)&#xA;&#xA;The internals are reference counted, so copying is also cheap. " ilk="function" line="883" lineend="891" name="__init__" signature="PositionIterator(*args)"><variable citdl="PositionIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_PositionIterator" line="892" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Advance the iterator to the specified termpos.&#xA;&#xA;void Xapian::PositionIterator::skip_to(Xapian::termpos pos)&#xA;&#xA;If the specified termpos isn&apos;t in the list, position ourselves on the&#xA;first termpos after it (or at_end() if no greater term positions are&#xA;present). " line="893" name="skip_to" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::PositionIterator::get_description() const " line="905" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="913" name="get_termpos" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="914" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="915" name="equals" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="918" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="919" name="__ne__" /><variable attributes="__instancevar__" line="7519" name="__next__" /></scope><variable citdl="_xapian.PositionIterator_swigregister" line="920" name="PositionIterator_swigregister" /><scope classrefs="object" doc="An iterator pointing to items in a list of postings. " ilk="class" line="923" lineend="999" name="PostingIterator"><variable citdl="_swig_property()" line="927" name="thisown" /><variable citdl="_swig_repr" line="928" name="__repr__" /><variable citdl="_xapian.delete_PostingIterator" line="929" name="__swig_destroy__" /><scope attributes="__ctor__" doc="Copying is allowed.&#xA;&#xA;Xapian::PostingIterator::PostingIterator(const PostingIterator &amp;other)&#xA;&#xA;The internals are reference counted, so copying is also cheap. " ilk="function" line="930" lineend="938" name="__init__" signature="PostingIterator(*args)"><variable citdl="PostingIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Advance the iterator to the specified docid.&#xA;&#xA;void Xapian::PostingIterator::skip_to(Xapian::docid did)&#xA;&#xA;If the specified docid isn&apos;t in the list, position ourselves on the&#xA;first document after it (or at_end() if no greater docids are&#xA;present). " line="939" name="skip_to" /><variable attributes="__instancevar__" citdl="function" doc="Get the length of the document at the current position in the&#xA;postlist.&#xA;&#xA;Xapian::termcount Xapian::PostingIterator::get_doclength() const&#xA;&#xA;This information may be stored in the postlist, in which case this&#xA;lookup should be extremely fast (indeed, not require further disk&#xA;access). If the information is not present in the postlist, it will be&#xA;retrieved from the database, at a greater performance cost. " line="951" name="get_doclength" /><variable attributes="__instancevar__" citdl="function" doc="Get the within document frequency of the document at the current&#xA;position in the postlist.&#xA;&#xA;Xapian::termcount Xapian::PostingIterator::get_wdf() const " line="965" name="get_wdf" /><variable attributes="__instancevar__" citdl="function" doc="Return PositionIterator pointing to start of positionlist for current&#xA;document.&#xA;&#xA;PositionIterator Xapian::PostingIterator::positionlist_begin() const&#xA;" line="974" name="positionlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Return PositionIterator pointing to end of positionlist for current&#xA;document.&#xA;&#xA;PositionIterator Xapian::PostingIterator::positionlist_end() const " line="984" name="positionlist_end" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::PostingIterator::get_description() const " line="993" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1007" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1008" name="__ne__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1009" name="get_docid" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1010" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1011" name="equals" /><variable attributes="__instancevar__" line="7518" name="__next__" /></scope><variable citdl="_xapian.PostingIterator_swigregister" line="1012" name="PostingIterator_swigregister" /><variable citdl="function" line="1016" name="__eq__" /><variable citdl="function" line="1020" name="__ne__" /><scope classrefs="object" doc="An iterator pointing to items in a list of terms. " ilk="class" line="1023" lineend="1103" name="TermIterator"><variable citdl="_swig_property()" line="1027" name="thisown" /><variable citdl="_swig_repr" line="1028" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed.&#xA;&#xA;Xapian::TermIterator::TermIterator(const TermIterator &amp;other)&#xA;&#xA;The internals are reference counted, so copying is also cheap. " ilk="function" line="1029" lineend="1037" name="__init__" signature="TermIterator(*args)"><variable citdl="TermIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_TermIterator" line="1038" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Advance the iterator to the specified term.&#xA;&#xA;void Xapian::TermIterator::skip_to(const std::string &amp;tname)&#xA;&#xA;If the specified term isn&apos;t in the list, position ourselves on the&#xA;first term after it (or at_end() if no greater terms are present). " line="1039" name="skip_to" /><variable attributes="__instancevar__" citdl="function" doc="Return the wdf of the current term (if meaningful).&#xA;&#xA;Xapian::termcount Xapian::TermIterator::get_wdf() const&#xA;&#xA;The wdf (within document frequency) is the number of occurrences of a&#xA;term in a particular document. " line="1050" name="get_wdf" /><variable attributes="__instancevar__" citdl="function" doc="Return the term frequency of the current term (if meaningful).&#xA;&#xA;Xapian::doccount Xapian::TermIterator::get_termfreq() const&#xA;&#xA;The term frequency is the number of documents which a term indexes. " line="1061" name="get_termfreq" /><variable attributes="__instancevar__" citdl="function" doc="Return length of positionlist for current term.&#xA;&#xA;Xapian::termcount Xapian::TermIterator::positionlist_count() const " line="1071" name="positionlist_count" /><variable attributes="__instancevar__" citdl="function" doc="Return PositionIterator pointing to start of positionlist for current&#xA;term.&#xA;&#xA;PositionIterator Xapian::TermIterator::positionlist_begin() const " line="1079" name="positionlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Return PositionIterator pointing to end of positionlist for current&#xA;term.&#xA;&#xA;PositionIterator Xapian::TermIterator::positionlist_end() const " line="1088" name="positionlist_end" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::TermIterator::get_description() const " line="1097" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1105" name="get_term" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1106" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1107" name="equals" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1115" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1116" name="__ne__" /><variable attributes="__instancevar__" line="7520" name="__next__" /></scope><variable citdl="_xapian.TermIterator_swigregister" line="1117" name="TermIterator_swigregister" /><scope classrefs="object" doc="Class for iterating over document values. " ilk="class" line="1120" lineend="1226" name="ValueIterator"><variable citdl="_swig_property()" line="1124" name="thisown" /><variable citdl="_swig_repr" line="1125" name="__repr__" /><scope attributes="__ctor__" doc="Default constructor.&#xA;&#xA;Xapian::ValueIterator::ValueIterator()&#xA;&#xA;Creates an uninitialised iterator, which can&apos;t be used before being&#xA;assigned to, but is sometimes syntactically convenient. " ilk="function" line="1126" lineend="1135" name="__init__" signature="ValueIterator(*args)"><variable citdl="ValueIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_ValueIterator" line="1136" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return the docid at the current position.&#xA;&#xA;Xapian::docid Xapian::ValueIterator::get_docid() const&#xA;&#xA;If we&apos;re iterating over values of a document, this method will throw&#xA;Xapian::InvalidOperationError. " line="1137" name="get_docid" /><variable attributes="__instancevar__" citdl="function" doc="Return the value slot number for the current position.&#xA;&#xA;Xapian::valueno Xapian::ValueIterator::get_valueno() const&#xA;&#xA;If the iterator is over all values in a slot, this returns that slot&apos;s&#xA;number. If the iterator is over the values in a particular document,&#xA;it returns the number of each slot in turn. " line="1148" name="get_valueno" /><variable attributes="__instancevar__" citdl="function" doc="Advance the iterator to document id or value slot docid_or_slot.&#xA;&#xA;void Xapian::ValueIterator::skip_to(Xapian::docid docid_or_slot)&#xA;&#xA;If this iterator is over values in a document, then this method&#xA;advances the iterator to value slot docid_or_slot, or the first slot&#xA;after it if there is no value in slot slot.&#xA;&#xA;If this iterator is over values in a particular slot, then this method&#xA;advances the iterator to document id docid_or_slot, or the first&#xA;document id after it if there is no value in the slot we&apos;re iterating&#xA;over for document docid_or_slot.&#xA;&#xA;Note: The &quot;two-faced&quot; nature of this method is due to how C++&#xA;overloading works. Xapian::docid and Xapian::valueno are both typedefs&#xA;for the same unsigned integer type, so overloading can&apos;t distinguish&#xA;them.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;docid_or_slot:  The docid/slot to advance to. " line="1160" name="skip_to" /><variable attributes="__instancevar__" citdl="function" doc="Check if the specified docid occurs.&#xA;&#xA;bool Xapian::ValueIterator::check(Xapian::docid docid)&#xA;&#xA;The caller is required to ensure that the specified document id did&#xA;actually exists in the database.&#xA;&#xA;This method acts like skip_to() if that can be done at little extra&#xA;cost, in which case it then returns true. This is how brass and chert&#xA;databases behave because they store values in streams which allow for&#xA;an efficient implementation of skip_to().&#xA;&#xA;Otherwise it simply checks if a particular docid is present. If it is,&#xA;it returns true. If it isn&apos;t, it returns false, and leaves the&#xA;position unspecified (and hence the result of calling methods which&#xA;depends on the current position, such as get_docid(), are also&#xA;unspecified). In this state, next() will advance to the first matching&#xA;position after document did, and skip_to() will act as it would if the&#xA;position was the first matching position after document did.&#xA;&#xA;Currently the inmemory, flint, and remote backends behave in the&#xA;latter way because they don&apos;t support streamed values and so skip_to()&#xA;must check each document it skips over which is significantly slower.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;docid:  The document id to check. " line="1187" name="check" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::ValueIterator::get_description() const " line="1220" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1228" name="get_value" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1229" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1230" name="equals" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1236" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="1237" name="__ne__" /><variable attributes="__instancevar__" line="7521" name="__next__" /></scope><variable citdl="_xapian.ValueIterator_swigregister" line="1238" name="ValueIterator_swigregister" /><scope classrefs="object" doc="A handle representing a document in a Xapian database.&#xA;&#xA;The Document class fetches information from the database lazily.&#xA;Usually this behaviour isn&apos;t visible to users (except for the speed&#xA;benefits), but if the document in the database is modified or deleted,&#xA;then preexisting Document objects may return the old or new versions&#xA;of data (or throw Xapian::DocNotFoundError in the case of deletion).&#xA;&#xA;Since Database objects work on a snapshot of the database&apos;s state, the&#xA;situation above can only happen with a WritableDatabase object, or if&#xA;you call Database::reopen() on a Database object.&#xA;&#xA;We recommend you avoid designs where this behaviour is an issue, but&#xA;if you need a way to make a non-lazy version of a Document object, you&#xA;can do this like so:&#xA;&#xA;doc = Xapian::Document::unserialise(doc.serialise()); " ilk="class" line="1241" lineend="1567" name="Document"><variable citdl="_swig_property()" line="1261" name="thisown" /><variable citdl="_swig_repr" line="1262" name="__repr__" /><scope attributes="__ctor__" doc="Make a new empty Document.&#xA;&#xA;Xapian::Document::Document() " ilk="function" line="1263" lineend="1269" name="__init__" signature="Document(*args)"><variable citdl="Document" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_Document" line="1270" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Get value by number.&#xA;&#xA;std::string Xapian::Document::get_value(Xapian::valueno slot) const&#xA;&#xA;Returns an empty string if no value with the given number is present&#xA;in the document.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The number of the value. " line="1271" name="get_value" /><variable attributes="__instancevar__" citdl="function" doc="Add a new value.&#xA;&#xA;void Xapian::Document::add_value(Xapian::valueno slot, const&#xA;std::string &amp;value)&#xA;&#xA;The new value will replace any existing value with the same number (or&#xA;if the new value is empty, it will remove any existing value with the&#xA;same number).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The value slot to add the value in.&#xA;&#xA;value:  The value to set. " line="1287" name="add_value" /><variable attributes="__instancevar__" citdl="function" doc="Remove any value with the given number.&#xA;&#xA;void Xapian::Document::remove_value(Xapian::valueno slot) " line="1307" name="remove_value" /><variable attributes="__instancevar__" citdl="function" doc="Remove all values associated with the document.&#xA;&#xA;void Xapian::Document::clear_values() " line="1315" name="clear_values" /><variable attributes="__instancevar__" citdl="function" doc="Get data stored in the document.&#xA;&#xA;std::string Xapian::Document::get_data() const&#xA;&#xA;This is potentially a relatively expensive operation, and shouldn&apos;t&#xA;normally be used during the match (e.g. in a PostingSource or match&#xA;decider functor. Put data for use by match deciders in a value&#xA;instead. " line="1323" name="get_data" /><variable attributes="__instancevar__" citdl="function" doc="Set data stored in the document.&#xA;&#xA;void Xapian::Document::set_data(const std::string &amp;data)&#xA;&#xA;Xapian treats the data as an opaque blob. It may try to compress it,&#xA;but other than that it will just store it and return it when&#xA;requested.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;data:  The data to store. " line="1336" name="set_data" /><variable attributes="__instancevar__" citdl="function" doc="Add an occurrence of a term at a particular position.&#xA;&#xA;void Xapian::Document::add_posting(const std::string &amp;tname,&#xA;Xapian::termpos tpos, Xapian::termcount wdfinc=1)&#xA;&#xA;Multiple occurrences of the term at the same position are represented&#xA;only once in the positional information, but do increase the wdf.&#xA;&#xA;If the term is not already in the document, it will be added to it.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The name of the term.&#xA;&#xA;tpos:  The position of the term.&#xA;&#xA;wdfinc:  The increment that will be applied to the wdf for this term.&#xA;" line="1353" name="add_posting" /><variable attributes="__instancevar__" citdl="function" doc="Add a term to the document, without positional information.&#xA;&#xA;void Xapian::Document::add_term(const std::string &amp;tname,&#xA;Xapian::termcount wdfinc=1)&#xA;&#xA;Any existing positional information for the term will be left&#xA;unmodified.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The name of the term.&#xA;&#xA;wdfinc:  The increment that will be applied to the wdf for this term&#xA;(default: 1). " line="1377" name="add_term" /><variable attributes="__instancevar__" citdl="function" doc="Add a boolean filter term to the document.&#xA;&#xA;void Xapian::Document::add_boolean_term(const std::string &amp;term)&#xA;&#xA;This method adds term to the document with wdf of 0 - this is&#xA;generally what you want for a term used for boolean filtering as the&#xA;wdf of such terms is ignored, and it doesn&apos;t make sense for them to&#xA;contribute to the document&apos;s length.&#xA;&#xA;If the specified term already indexes this document, this method has&#xA;no effect.&#xA;&#xA;It is exactly the same as add_term(term, 0).&#xA;&#xA;This method was added in Xapian 1.0.18.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;term:  The term to add. " line="1397" name="add_boolean_term" /><variable attributes="__instancevar__" citdl="function" doc="Remove a posting of a term from the document.&#xA;&#xA;void Xapian::Document::remove_posting(const std::string &amp;tname,&#xA;Xapian::termpos tpos, Xapian::termcount wdfdec=1)&#xA;&#xA;Note that the term will still index the document even if all&#xA;occurrences are removed. To remove a term from a document completely,&#xA;use remove_term().&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The name of the term.&#xA;&#xA;tpos:  The position of the term.&#xA;&#xA;wdfdec:  The decrement that will be applied to the wdf when removing&#xA;this posting. The wdf will not go below the value of 0.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if the term is not at&#xA;the position specified in the position list for this term in this&#xA;document.&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if the term is not in&#xA;the document " line="1422" name="remove_posting" /><variable attributes="__instancevar__" citdl="function" doc="Remove a term and all postings associated with it.&#xA;&#xA;void Xapian::Document::remove_term(const std::string &amp;tname)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The name of the term.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if the term is not in&#xA;the document " line="1455" name="remove_term" /><variable attributes="__instancevar__" citdl="function" doc="Remove all terms (and postings) from the document.&#xA;&#xA;void Xapian::Document::clear_terms() " line="1474" name="clear_terms" /><variable attributes="__instancevar__" citdl="function" doc="The length of the termlist - i.e.&#xA;&#xA;Xapian::termcount Xapian::Document::termlist_count() const&#xA;&#xA;the number of different terms which index this document. " line="1482" name="termlist_count" /><variable attributes="__instancevar__" citdl="function" doc="Iterator for the terms in this document.&#xA;&#xA;TermIterator Xapian::Document::termlist_begin() const " line="1492" name="termlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Equivalent end iterator for termlist_begin().&#xA;&#xA;TermIterator Xapian::Document::termlist_end() const " line="1500" name="termlist_end" /><variable attributes="__instancevar__" citdl="function" doc="Count the values in this document.&#xA;&#xA;Xapian::termcount Xapian::Document::values_count() const " line="1508" name="values_count" /><variable attributes="__instancevar__" citdl="function" doc="Iterator for the values in this document.&#xA;&#xA;ValueIterator Xapian::Document::values_begin() const " line="1516" name="values_begin" /><variable attributes="__instancevar__" citdl="function" doc="Equivalent end iterator for values_begin().&#xA;&#xA;ValueIteratorEnd_ Xapian::Document::values_end() const " line="1524" name="values_end" /><variable attributes="__instancevar__" citdl="function" doc="Get the document id which is associated with this document (if any).&#xA;&#xA;docid Xapian::Document::get_docid() const&#xA;&#xA;NB If multiple databases are being searched together, then this will&#xA;be the document id in the individual database, not the merged&#xA;database!&#xA;&#xA;If this document came from a database, return the document id in that&#xA;database. Otherwise, return 0 (in Xapian 1.0.22/1.2.4 or later; prior&#xA;to this the returned value was uninitialised). " line="1532" name="get_docid" /><variable attributes="__instancevar__" citdl="function" doc="Serialise document into a string.&#xA;&#xA;std::string Xapian::Document::serialise() const&#xA;&#xA;The document representation may change between Xapian releases: even&#xA;between minor versions. However, it is guaranteed not to change if the&#xA;remote database protocol has not changed between releases. " line="1548" name="serialise" /><variable citdl="staticmethod()" line="1560" name="unserialise" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::Document::get_description() const " line="1561" name="__str__" /><variable attributes="__instancevar__" citdl="_document_gen_termlist_iter" line="6874" name="__iter__" /><variable attributes="__instancevar__" citdl="_document_gen_termlist_iter" line="6875" name="termlist" /><variable attributes="__instancevar__" citdl="_document_gen_values_iter" line="7373" name="values" /></scope><variable citdl="_xapian.Document_swigregister" line="1590" name="Document_swigregister" /><variable citdl="function" line="1593" name="Document_unserialise" /><scope classrefs="object" doc="Base class which provides an &quot;external&quot; source of postings. " ilk="class" line="1597" lineend="1880" name="PostingSource"><variable citdl="_swig_property()" line="1601" name="thisown" /><variable citdl="_swig_repr" line="1602" name="__repr__" /><scope attributes="__ctor__" ilk="function" line="1603" lineend="1608" name="__init__" signature="PostingSource()"><variable citdl="PostingSource" ilk="argument" name="self" /><variable attributes="protected" citdl="PostingSource" line="1605" name="_self" /></scope><variable citdl="_xapian.delete_PostingSource" line="1609" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="A lower bound on the number of documents this object can return.&#xA;&#xA;virtual Xapian::doccount Xapian::PostingSource::get_termfreq_min()&#xA;const =0&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time. " line="1610" name="get_termfreq_min" /><variable attributes="__instancevar__" citdl="function" doc="An estimate of the number of documents this object can return.&#xA;&#xA;virtual Xapian::doccount Xapian::PostingSource::get_termfreq_est()&#xA;const =0&#xA;&#xA;It must always be true that:&#xA;&#xA;get_termfreq_min() &lt;= get_termfreq_est() &lt;= get_termfreq_max()&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time. " line="1622" name="get_termfreq_est" /><variable attributes="__instancevar__" citdl="function" doc="An upper bound on the number of documents this object can return.&#xA;&#xA;virtual Xapian::doccount Xapian::PostingSource::get_termfreq_max()&#xA;const =0&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time. " line="1638" name="get_termfreq_max" /><variable attributes="__instancevar__" citdl="function" doc="Return the currently set upper bound on what get_weight() can return.&#xA;&#xA;Xapian::weight Xapian::PostingSource::get_maxweight() const " line="1650" name="get_maxweight" /><variable attributes="__instancevar__" citdl="function" doc="Return the weight contribution for the current document.&#xA;&#xA;virtual Xapian::weight Xapian::PostingSource::get_weight() const&#xA;&#xA;This default implementation always returns 0, for convenience when&#xA;implementing &quot;weight-less&quot; PostingSource subclasses.&#xA;&#xA;This method may assume that it will only be called when there is a&#xA;&quot;current document&quot;. In detail: Xapian will always call init() on a&#xA;PostingSource before calling this for the first time. It will also&#xA;only call this if the PostingSource reports that it is pointing to a&#xA;valid document (ie, it will not call it before calling at least one of&#xA;next(), skip_to() or check(), and will ensure that the PostingSource&#xA;is not at the end by calling at_end()). " line="1658" name="get_weight" /><variable attributes="__instancevar__" citdl="function" doc="Return the current docid.&#xA;&#xA;virtual Xapian::docid Xapian::PostingSource::get_docid() const =0&#xA;&#xA;This method may assume that it will only be called when there is a&#xA;&quot;current document&quot;. See  get_weight() for details.&#xA;&#xA;Note: in the case of a multi-database search, the returned docid&#xA;should be in the single subdatabase relevant to this posting source.&#xA;See the  init() method for details. " line="1677" name="get_docid" /><variable attributes="__instancevar__" citdl="function" doc="Advance the current position to the next matching document.&#xA;&#xA;virtual void Xapian::PostingSource::next(Xapian::weight min_wt)=0&#xA;&#xA;The PostingSource starts before the first entry in the list, so next()&#xA;must be called before any methods which need the context of the&#xA;current position.&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;min_wt:  The minimum weight contribution that is needed (this is just&#xA;a hint which subclasses may ignore). " line="1692" name="next" /><variable attributes="__instancevar__" citdl="function" doc="Advance to the specified docid.&#xA;&#xA;virtual void Xapian::PostingSource::skip_to(Xapian::docid did,&#xA;Xapian::weight min_wt)&#xA;&#xA;If the specified docid isn&apos;t in the list, position ourselves on the&#xA;first document after it (or at_end() if no greater docids are&#xA;present).&#xA;&#xA;If the current position is already the specified docid, this method&#xA;will leave the position unmodified.&#xA;&#xA;If the specified docid is earlier than the current position, the&#xA;behaviour is unspecified. A sensible behaviour would be to leave the&#xA;current position unmodified, but it is also reasonable to move to the&#xA;specified docid.&#xA;&#xA;The default implementation calls next() repeatedly, which works but&#xA;skip_to() can often be implemented much more efficiently.&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time.&#xA;&#xA;Note: in the case of a multi-database search, the docid specified is&#xA;the docid in the single subdatabase relevant to this posting source.&#xA;See the  init() method for details.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;did:  The document id to advance to.&#xA;&#xA;min_wt:  The minimum weight contribution that is needed (this is just&#xA;a hint which subclasses may ignore). " line="1713" name="skip_to" /><variable attributes="__instancevar__" citdl="function" doc="Check if the specified docid occurs.&#xA;&#xA;virtual bool Xapian::PostingSource::check(Xapian::docid did,&#xA;Xapian::weight min_wt)&#xA;&#xA;The caller is required to ensure that the specified document id did&#xA;actually exists in the database. If it does, it must move to that&#xA;document id, and return true. If it does not, it may either:&#xA;&#xA;return true, having moved to a definite position (including&#xA;&quot;at_end&quot;), which must be the same position as skip_to() would have&#xA;moved to.&#xA;&#xA;or&#xA;&#xA;return false, having moved to an &quot;indeterminate&quot; position, such that&#xA;a subsequent call to next() or skip_to() will move to the next&#xA;matching position after did.&#xA;&#xA;Generally, this method should act like skip_to() and return true if&#xA;that can be done at little extra cost.&#xA;&#xA;Otherwise it should simply check if a particular docid is present,&#xA;returning true if it is, and false if it isn&apos;t.&#xA;&#xA;The default implementation calls skip_to() and always returns true.&#xA;&#xA;Xapian will always call init() on a PostingSource before calling this&#xA;for the first time.&#xA;&#xA;Note: in the case of a multi-database search, the docid specified is&#xA;the docid in the single subdatabase relevant to this posting source.&#xA;See the  init() method for details.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;did:  The document id to check.&#xA;&#xA;min_wt:  The minimum weight contribution that is needed (this is just&#xA;a hint which subclasses may ignore). " line="1752" name="check" /><variable attributes="__instancevar__" citdl="function" doc="Return true if the current position is past the last entry in this&#xA;list.&#xA;&#xA;virtual bool Xapian::PostingSource::at_end() const =0&#xA;&#xA;At least one of  next(),  skip_to() or  check() will be called before&#xA;this method is first called. " line="1798" name="at_end" /><variable attributes="__instancevar__" citdl="function" doc="Name of the posting source class.&#xA;&#xA;virtual std::string Xapian::PostingSource::name() const&#xA;&#xA;This is used when serialising and unserialising posting sources; for&#xA;example, for performing remote searches.&#xA;&#xA;If the subclass is in a C++ namespace, the namespace should be&#xA;included in the name, using &quot;::&quot; as a separator. For example, for a&#xA;PostingSource subclass called &quot;FooPostingSource&quot; in the &quot;Xapian&quot;&#xA;namespace the result of this call should be&#xA;&quot;Xapian::FooPostingSource&quot;.&#xA;&#xA;This should only be implemented if serialise() and unserialise() are&#xA;also implemented. The default implementation returns an empty string.&#xA;&#xA;If this returns an empty string, Xapian will assume that serialise()&#xA;and unserialise() are not implemented. " line="1810" name="name" /><variable attributes="__instancevar__" citdl="function" doc="Set this PostingSource to the start of the list of postings.&#xA;&#xA;virtual void Xapian::PostingSource::init(const Database &amp;db)=0&#xA;&#xA;This is called automatically by the matcher prior to each query being&#xA;processed.&#xA;&#xA;If a PostingSource is used for multiple searches,  init() will&#xA;therefore be called multiple times, and must handle this by using the&#xA;database passed in the most recent call.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;db:  The database which the PostingSource should iterate through.&#xA;&#xA;Note: the database supplied to this method must not be modified: in&#xA;particular, the reopen() method should not be called on it.&#xA;&#xA;Note: in the case of a multi-database search, a separate PostingSource&#xA;will be used for each database (the separate PostingSources will be&#xA;obtained using  clone()), and each PostingSource will be passed one of&#xA;the sub-databases as the db parameter here. The db parameter will&#xA;therefore always refer to a single database. All docids passed to, or&#xA;returned from, the PostingSource refer to docids in that single&#xA;database, rather than in the multi- database. " line="1833" name="init" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;virtual std::string Xapian::PostingSource::get_description() const&#xA;&#xA;This default implementation returns a generic answer. This default it&#xA;provided to avoid forcing those deriving their own PostingSource&#xA;subclass from having to implement this (they may not care what&#xA;get_description() gives for their subclass). " line="1864" name="__str__" /><scope ilk="function" line="1877" lineend="1880" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="PostingSource" ilk="argument" name="self" /></scope></scope><variable citdl="_xapian.PostingSource_swigregister" line="1894" name="PostingSource_swigregister" /><scope classrefs="PostingSource" doc="A posting source which generates weights from a value slot.&#xA;&#xA;This is a base class for classes which generate weights using values&#xA;stored in the specified slot. For example, ValueWeightPostingSource&#xA;uses sortable_unserialise to convert values directly to weights.&#xA;&#xA;The upper bound on the weight returned is set to DBL_MAX. Subclasses&#xA;should call set_maxweight() in their init() methods after calling&#xA;ValuePostingSource::init() if they know a tighter bound on the weight.&#xA;" ilk="class" line="1897" lineend="1924" name="ValuePostingSource"><variable citdl="_swig_property()" line="1910" name="thisown" /><variable citdl="_swig_repr" line="1911" name="__repr__" /><scope attributes="__ctor__" doc="Construct a ValuePostingSource.&#xA;&#xA;Xapian::ValuePostingSource::ValuePostingSource(Xapian::valueno slot_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value slot to read values from. " ilk="function" line="1912" lineend="1923" name="__init__" signature="ValuePostingSource(*args)"><variable citdl="ValuePostingSource" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_ValuePostingSource" line="1924" name="__swig_destroy__" /></scope><variable citdl="_xapian.ValuePostingSource_swigregister" line="1925" name="ValuePostingSource_swigregister" /><scope classrefs="ValuePostingSource" doc="A posting source which reads weights from a value slot.&#xA;&#xA;This returns entries for all documents in the given database which&#xA;have a non empty values in the specified slot. It returns a weight&#xA;calculated by applying sortable_unserialise to the value stored in the&#xA;slot (so the values stored should probably have been calculated by&#xA;applying sortable_serialise to a floating point number at index time).&#xA;&#xA;The upper bound on the weight returned is set using the upper bound on&#xA;the values in the specified slot, or DBL_MAX if value bounds aren&apos;t&#xA;supported by the current backend.&#xA;&#xA;For efficiency, this posting source doesn&apos;t check that the stored&#xA;values are valid in any way, so it will never raise an exception due&#xA;to invalid stored values. In particular, it doesn&apos;t ensure that the&#xA;unserialised values are positive, which is a requirement for weights.&#xA;The behaviour if the slot contains values which unserialise to&#xA;negative values is undefined. " ilk="class" line="1928" lineend="1964" name="ValueWeightPostingSource"><variable citdl="_swig_property()" line="1949" name="thisown" /><variable citdl="_swig_repr" line="1950" name="__repr__" /><scope attributes="__ctor__" doc="Construct a ValueWeightPostingSource.&#xA;&#xA;Xapian::ValueWeightPostingSource::ValueWeightPostingSource(Xapian::valueno&#xA;slot_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value slot to read values from. " ilk="function" line="1951" lineend="1963" name="__init__" signature="ValueWeightPostingSource(*args)"><variable citdl="ValueWeightPostingSource" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_ValueWeightPostingSource" line="1964" name="__swig_destroy__" /></scope><variable citdl="_xapian.ValueWeightPostingSource_swigregister" line="1965" name="ValueWeightPostingSource_swigregister" /><scope classrefs="ValueWeightPostingSource" doc="Read weights from a value which is known to decrease as docid&#xA;increases.&#xA;&#xA;This posting source can be used, like ValueWeightPostingSource, to add&#xA;a weight contribution to a query based on the values stored in a slot.&#xA;The values in the slot must be serialised as by  sortable_serialise().&#xA;&#xA;However, this posting source is additionally given a range of document&#xA;IDs, within which the weight is known to be decreasing. ie, for all&#xA;documents with ids A and B within this range (including the&#xA;endpoints), where A is less than B, the weight of A is less than or&#xA;equal to the weight of B. This can allow the posting source to skip to&#xA;the end of the range quickly if insufficient weight is left in the&#xA;posting source for a particular source.&#xA;&#xA;By default, the range is assumed to cover all document IDs.&#xA;&#xA;The ordering property can be arranged at index time, or by sorting an&#xA;indexed database to produce a new, sorted, database. " ilk="class" line="1968" lineend="1998" name="DecreasingValueWeightPostingSource"><variable citdl="_swig_property()" line="1990" name="thisown" /><variable citdl="_swig_repr" line="1991" name="__repr__" /><scope attributes="__ctor__" doc="Xapian::DecreasingValueWeightPostingSource::DecreasingValueWeightPostingSource(Xapian::valueno&#xA;slot_, Xapian::docid range_start_=0, Xapian::docid range_end_=0) " ilk="function" line="1992" lineend="1997" name="__init__" signature="DecreasingValueWeightPostingSource(*args)"><variable citdl="DecreasingValueWeightPostingSource" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DecreasingValueWeightPostingSource" line="1998" name="__swig_destroy__" /></scope><variable citdl="_xapian.DecreasingValueWeightPostingSource_swigregister" line="1999" name="DecreasingValueWeightPostingSource_swigregister" /><scope classrefs="ValuePostingSource" doc="A posting source which looks up weights in a map using values as the&#xA;key.&#xA;&#xA;This allows will return entries for all documents in the given&#xA;database which have a value in the slot specified. The values will be&#xA;mapped to the corresponding weight in the weight map. If there is no&#xA;mapping for a particular value, the default weight will be returned&#xA;(which itself defaults to 0.0). " ilk="class" line="2002" lineend="2065" name="ValueMapPostingSource"><variable citdl="_swig_property()" line="2013" name="thisown" /><variable citdl="_swig_repr" line="2014" name="__repr__" /><scope attributes="__ctor__" doc="Construct a ValueWeightPostingSource.&#xA;&#xA;Xapian::ValueMapPostingSource::ValueMapPostingSource(Xapian::valueno&#xA;slot_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value slot to read values from. " ilk="function" line="2015" lineend="2027" name="__init__" signature="ValueMapPostingSource(*args)"><variable citdl="ValueMapPostingSource" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Add a mapping.&#xA;&#xA;void Xapian::ValueMapPostingSource::add_mapping(const std::string&#xA;&amp;key, double wt)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;key:  The key looked up from the value slot.&#xA;&#xA;wt:  The weight to give this key. " line="2028" name="add_mapping" /><variable attributes="__instancevar__" citdl="function" doc="Clear all mappings.&#xA;&#xA;void Xapian::ValueMapPostingSource::clear_mappings() " line="2044" name="clear_mappings" /><variable attributes="__instancevar__" citdl="function" doc="Set a default weight for document values not in the map.&#xA;&#xA;void Xapian::ValueMapPostingSource::set_default_weight(double wt)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;wt:  The weight to set as the default. " line="2052" name="set_default_weight" /><variable citdl="_xapian.delete_ValueMapPostingSource" line="2065" name="__swig_destroy__" /></scope><variable citdl="_xapian.ValueMapPostingSource_swigregister" line="2069" name="ValueMapPostingSource_swigregister" /><scope classrefs="PostingSource" doc="A posting source which returns a fixed weight for all documents.&#xA;&#xA;This returns entries for all documents in the given database, with a&#xA;fixed weight (specified by a parameter to the constructor). " ilk="class" line="2072" lineend="2094" name="FixedWeightPostingSource"><variable citdl="_swig_property()" line="2079" name="thisown" /><variable citdl="_swig_repr" line="2080" name="__repr__" /><scope attributes="__ctor__" doc="Construct a FixedWeightPostingSource.&#xA;&#xA;Xapian::FixedWeightPostingSource::FixedWeightPostingSource(Xapian::weight&#xA;wt)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;wt:  The fixed weight to return. " ilk="function" line="2081" lineend="2093" name="__init__" signature="FixedWeightPostingSource(*args)"><variable citdl="FixedWeightPostingSource" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_FixedWeightPostingSource" line="2094" name="__swig_destroy__" /></scope><variable citdl="_xapian.FixedWeightPostingSource_swigregister" line="2095" name="FixedWeightPostingSource_swigregister" /><scope classrefs="object" doc="A match set ( MSet).&#xA;&#xA;This class represents (a portion of) the results of a query. " ilk="class" line="2098" lineend="2346" name="MSet"><variable citdl="_swig_property()" line="2104" name="thisown" /><variable citdl="_swig_repr" line="2105" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed (and is cheap).&#xA;&#xA;Xapian::MSet::MSet(const MSet &amp;other) " ilk="function" line="2106" lineend="2112" name="__init__" signature="MSet(*args)"><variable citdl="MSet" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_MSet" line="2113" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Fetch all the items in the MSet.&#xA;&#xA;void Xapian::MSet::fetch() const " line="2114" name="fetch" /><variable attributes="__instancevar__" citdl="function" doc="Return the percentage score for a particular item.&#xA;&#xA;Xapian::percent Xapian::MSet::convert_to_percent(const MSetIterator&#xA;&amp;it) const " line="2122" name="convert_to_percent" /><variable attributes="__instancevar__" citdl="function" doc="Return the term frequency of the given query term.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_termfreq(const std::string &amp;tname)&#xA;const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The term to look for.&#xA;&#xA;This is sometimes more efficient than asking the database directly for&#xA;the term frequency - in particular, if the term was in the query, its&#xA;frequency will usually be cached in the MSet. " line="2131" name="get_termfreq" /><variable attributes="__instancevar__" citdl="function" doc="Return the term weight of the given query term.&#xA;&#xA;Xapian::weight Xapian::MSet::get_termweight(const std::string &amp;tname)&#xA;const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The term to look for.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  is thrown if the term was not in the&#xA;query. " line="2149" name="get_termweight" /><variable attributes="__instancevar__" citdl="function" doc="The index of the first item in the result which was put into the MSet.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_firstitem() const&#xA;&#xA;This corresponds to the parameter &quot;first&quot; specified in&#xA;Xapian::Enquire::get_mset(). A value of 0 corresponds to the highest&#xA;result being the first item in the MSet. " line="2169" name="get_firstitem" /><variable attributes="__instancevar__" citdl="function" doc="A lower bound on the number of documents in the database which match&#xA;the query.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_matches_lower_bound() const&#xA;&#xA;This figure takes into account collapsing of duplicates, and weighting&#xA;cutoff values.&#xA;&#xA;This number is usually considerably less than the actual number of&#xA;documents which match the query. " line="2181" name="get_matches_lower_bound" /><variable attributes="__instancevar__" citdl="function" doc="An estimate for the number of documents in the database which match&#xA;the query.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_matches_estimated() const&#xA;&#xA;This figure takes into account collapsing of duplicates, and weighting&#xA;cutoff values.&#xA;&#xA;This value is returned because there is sometimes a request to display&#xA;such information. However, our experience is that presenting this&#xA;value to users causes them to worry about the large number of results,&#xA;rather than how useful those at the top of the result set are, and is&#xA;thus undesirable. " line="2196" name="get_matches_estimated" /><variable attributes="__instancevar__" citdl="function" doc="An upper bound on the number of documents in the database which match&#xA;the query.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_matches_upper_bound() const&#xA;&#xA;This figure takes into account collapsing of duplicates, and weighting&#xA;cutoff values.&#xA;&#xA;This number is usually considerably greater than the actual number of&#xA;documents which match the query. " line="2214" name="get_matches_upper_bound" /><variable attributes="__instancevar__" citdl="function" doc="A lower bound on the number of documents in the database which would&#xA;match the query if collapsing wasn&apos;t used.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_uncollapsed_matches_lower_bound()&#xA;const " line="2229" name="get_uncollapsed_matches_lower_bound" /><variable attributes="__instancevar__" citdl="function" doc="A estimate of the number of documents in the database which would&#xA;match the query if collapsing wasn&apos;t used.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_uncollapsed_matches_estimated()&#xA;const " line="2239" name="get_uncollapsed_matches_estimated" /><variable attributes="__instancevar__" citdl="function" doc="A upper bound on the number of documents in the database which would&#xA;match the query if collapsing wasn&apos;t used.&#xA;&#xA;Xapian::doccount Xapian::MSet::get_uncollapsed_matches_upper_bound()&#xA;const " line="2249" name="get_uncollapsed_matches_upper_bound" /><variable attributes="__instancevar__" citdl="function" doc="The maximum possible weight in the MSet.&#xA;&#xA;Xapian::weight Xapian::MSet::get_max_possible() const&#xA;&#xA;This weight is likely not to be attained in the set of results, but&#xA;represents an upper bound on the weight which a document could attain&#xA;for the given query. " line="2259" name="get_max_possible" /><variable attributes="__instancevar__" citdl="function" doc="The greatest weight which is attained by any document in the database.&#xA;&#xA;Xapian::weight Xapian::MSet::get_max_attained() const&#xA;&#xA;If firstitem == 0 and the primary ordering is by relevance, this is&#xA;the weight of the first entry in the MSet.&#xA;&#xA;If no documents are found by the query, this will be 0.&#xA;&#xA;Note that calculation of max_attained requires calculation of at least&#xA;one result item - therefore, if no items were requested when the query&#xA;was performed (by specifying maxitems = 0 in&#xA;Xapian::Enquire::get_mset()), this value will be 0. " line="2271" name="get_max_attained" /><variable attributes="__instancevar__" citdl="function" doc="The number of items in this MSet.&#xA;&#xA;Xapian::doccount Xapian::MSet::size() const " line="2289" name="size" /><variable attributes="__instancevar__" citdl="function" doc="Test if this MSet is empty.&#xA;&#xA;bool Xapian::MSet::empty() const " line="2297" name="empty" /><variable attributes="__instancevar__" citdl="function" doc="Iterator for the items in this MSet.&#xA;&#xA;MSetIterator Xapian::MSet::begin() const " line="2305" name="begin" /><variable attributes="__instancevar__" citdl="function" doc="End iterator corresponding to begin().&#xA;&#xA;MSetIterator Xapian::MSet::end() const " line="2313" name="end" /><variable attributes="__instancevar__" citdl="function" doc="Iterator pointing to the last element of this MSet.&#xA;&#xA;MSetIterator Xapian::MSet::back() const " line="2321" name="back" /><variable attributes="protected __instancevar__" citdl="function" doc="Get an item from the MSet.&#xA;&#xA;The supplied index is relative to the start of the MSet, not the absolute rank&#xA;of the item. " line="2329" name="_get_hit_internal" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::MSet::get_description() const " line="2338" name="__str__" /><variable citdl="_swig_property()" line="2346" name="items" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2366" name="get_document_percentage" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2367" name="get_document" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2368" name="get_docid" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2370" name="__cmp__" /><variable attributes="__instancevar__" citdl="_mset_gen_iter" line="6408" name="__iter__" /><variable attributes="__instancevar__" line="6410" name="__len__" /><variable attributes="__instancevar__" citdl="_mset_getitem" line="6426" name="__getitem__" /><variable attributes="__instancevar__" citdl="_mset_getitem" line="6427" name="get_hit" /></scope><variable citdl="_xapian.MSet_swigregister" line="2371" name="MSet_swigregister" /><scope classrefs="object" doc="An iterator pointing to items in an MSet.&#xA;&#xA;This is used for access to individual results of a match. " ilk="class" line="2374" lineend="2491" name="MSetIterator"><variable citdl="_swig_property()" line="2380" name="thisown" /><variable citdl="_swig_repr" line="2381" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed (and is cheap).&#xA;&#xA;Xapian::MSetIterator::MSetIterator(const MSetIterator &amp;other) " ilk="function" line="2382" lineend="2388" name="__init__" signature="MSetIterator(*args)"><variable citdl="MSetIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_MSetIterator" line="2389" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Get a Xapian::Document object for the current position.&#xA;&#xA;Xapian::Document Xapian::MSetIterator::get_document() const&#xA;&#xA;This method returns a Xapian::Document object which provides the&#xA;information about the document pointed to by the MSetIterator.&#xA;&#xA;If the underlying database has suitable support, using this call&#xA;(rather than asking the database for a document based on its document&#xA;ID) will enable the system to ensure that the correct data is&#xA;returned, and that the document has not been deleted or changed since&#xA;the query was performed.&#xA;&#xA;A Xapian::Document object containing the document data.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DocNotFoundError:  The document specified could not be found&#xA;in the database. " line="2390" name="get_document" /><variable attributes="__instancevar__" citdl="function" doc="Get the rank of the document at the current position.&#xA;&#xA;Xapian::doccount Xapian::MSetIterator::get_rank() const&#xA;&#xA;The rank is the position that this document is at in the ordered list&#xA;of results of the query. The result is 0-based - i.e. the top-ranked&#xA;document has a rank of 0. " line="2415" name="get_rank" /><variable attributes="__instancevar__" citdl="function" doc="Get the weight of the document at the current position.&#xA;&#xA;Xapian::weight Xapian::MSetIterator::get_weight() const " line="2427" name="get_weight" /><variable attributes="__instancevar__" citdl="function" doc="Get the collapse key for this document.&#xA;&#xA;std::string Xapian::MSetIterator::get_collapse_key() const " line="2435" name="get_collapse_key" /><variable attributes="__instancevar__" citdl="function" doc="Get an estimate of the number of documents that have been collapsed&#xA;into this one.&#xA;&#xA;Xapian::doccount Xapian::MSetIterator::get_collapse_count() const&#xA;&#xA;The estimate will always be less than or equal to the actual number of&#xA;other documents satisfying the match criteria with the same collapse&#xA;key as this document.&#xA;&#xA;This method may return 0 even though there are other documents with&#xA;the same collapse key which satisfying the match criteria. However if&#xA;this method returns non-zero, there definitely are other such&#xA;documents. So this method may be used to inform the user that there&#xA;are &quot;at least N other matches in this group&quot;, or to control whether&#xA;to offer a &quot;show other documents in this group&quot; feature (but note&#xA;that it may not offer it in every case where it would show other&#xA;documents). " line="2443" name="get_collapse_count" /><variable attributes="__instancevar__" citdl="function" doc="This returns the weight of the document as a percentage score.&#xA;&#xA;Xapian::percent Xapian::MSetIterator::get_percent() const&#xA;&#xA;The return value will be an integer in the range 0 to 100: 0 meaning&#xA;that the item did not match the query at all.&#xA;&#xA;The intention is that the highest weighted document will get 100 if it&#xA;matches all the weight-contributing terms in the query. However,&#xA;currently it may get a lower percentage score if you use a&#xA;MatchDecider and the sorting is primarily by value. In this case, the&#xA;percentage for a particular document may vary depending on the first,&#xA;max_size, and checkatleast parameters passed to Enquire::get_mset()&#xA;(this bug is hard to fix without having to apply the MatchDecider to&#xA;potentially many more documents, which is potentially costly). " line="2465" name="get_percent" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::MSetIterator::get_description() const " line="2485" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2493" name="get_docid" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2494" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2495" name="prev" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2496" name="equals" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2504" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2505" name="__ne__" /><variable attributes="__instancevar__" line="7517" name="__next__" /></scope><variable citdl="_xapian.MSetIterator_swigregister" line="2506" name="MSetIterator_swigregister" /><scope classrefs="object" doc="Class representing an ordered set of expand terms (an ESet).&#xA;&#xA;This set represents the results of an expand operation, which is&#xA;performed by Xapian::Enquire::get_eset(). " ilk="class" line="2509" lineend="2585" name="ESet"><variable citdl="_swig_property()" line="2516" name="thisown" /><variable citdl="_swig_repr" line="2517" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed (and is cheap).&#xA;&#xA;Xapian::ESet::ESet(const ESet &amp;other) " ilk="function" line="2518" lineend="2524" name="__init__" signature="ESet(*args)"><variable citdl="ESet" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_ESet" line="2525" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="A lower bound on the number of terms which are in the full set of&#xA;results of the expand.&#xA;&#xA;Xapian::termcount Xapian::ESet::get_ebound() const&#xA;&#xA;This will be greater than or equal to size() " line="2526" name="get_ebound" /><variable attributes="__instancevar__" citdl="function" doc="The number of terms in this E-Set.&#xA;&#xA;Xapian::termcount Xapian::ESet::size() const " line="2537" name="size" /><variable attributes="__instancevar__" citdl="function" doc="Test if this E-Set is empty.&#xA;&#xA;bool Xapian::ESet::empty() const " line="2545" name="empty" /><variable attributes="__instancevar__" citdl="function" doc="Iterator for the terms in this E-Set.&#xA;&#xA;ESetIterator Xapian::ESet::begin() const " line="2553" name="begin" /><variable attributes="__instancevar__" citdl="function" doc="End iterator corresponding to begin().&#xA;&#xA;ESetIterator Xapian::ESet::end() const " line="2561" name="end" /><variable attributes="__instancevar__" citdl="function" doc="Iterator pointing to the last element of this E-Set.&#xA;&#xA;ESetIterator Xapian::ESet::back() const " line="2569" name="back" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::ESet::get_description() const " line="2577" name="__str__" /><variable citdl="_swig_property()" line="2585" name="items" /><variable attributes="__instancevar__" citdl="_eset_gen_iter" line="6491" name="__iter__" /><variable attributes="__instancevar__" line="6493" name="__len__" /></scope><variable citdl="_xapian.ESet_swigregister" line="2593" name="ESet_swigregister" /><scope classrefs="object" doc="Iterate through terms in the ESet. " ilk="class" line="2596" lineend="2624" name="ESetIterator"><variable citdl="_swig_property()" line="2600" name="thisown" /><variable citdl="_swig_repr" line="2601" name="__repr__" /><scope attributes="__ctor__" doc="Copying is allowed (and is cheap).&#xA;&#xA;Xapian::ESetIterator::ESetIterator(const ESetIterator &amp;other) " ilk="function" line="2602" lineend="2608" name="__init__" signature="ESetIterator(*args)"><variable citdl="ESetIterator" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_ESetIterator" line="2609" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Get the weight of the term at the current position.&#xA;&#xA;Xapian::weight Xapian::ESetIterator::get_weight() const " line="2610" name="get_weight" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::ESetIterator::get_description() const " line="2618" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2626" name="get_term" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2627" name="next" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2628" name="prev" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2629" name="equals" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2632" name="__eq__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2633" name="__ne__" /><variable attributes="__instancevar__" line="7516" name="__next__" /></scope><variable citdl="_xapian.ESetIterator_swigregister" line="2634" name="ESetIterator_swigregister" /><scope classrefs="object" doc="A relevance set (R-Set).&#xA;&#xA;This is the set of documents which are marked as relevant, for use in&#xA;modifying the term weights, and in performing query expansion. " ilk="class" line="2637" lineend="2700" name="RSet"><variable citdl="_swig_property()" line="2644" name="thisown" /><variable citdl="_swig_repr" line="2645" name="__repr__" /><scope attributes="__ctor__" doc="Default constructor.&#xA;&#xA;Xapian::RSet::RSet() " ilk="function" line="2646" lineend="2652" name="__init__" signature="RSet(*args)"><variable citdl="RSet" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_RSet" line="2653" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="The number of documents in this R-Set.&#xA;&#xA;Xapian::doccount Xapian::RSet::size() const " line="2654" name="size" /><variable attributes="__instancevar__" citdl="function" doc="Test if this R-Set is empty.&#xA;&#xA;bool Xapian::RSet::empty() const " line="2662" name="empty" /><variable attributes="__instancevar__" citdl="function" doc="Add a document to the relevance set.&#xA;&#xA;void Xapian::RSet::add_document(const Xapian::MSetIterator &amp;i) " line="2670" name="add_document" /><variable attributes="__instancevar__" citdl="function" doc="Remove a document from the relevance set.&#xA;&#xA;void Xapian::RSet::remove_document(const Xapian::MSetIterator &amp;i) " line="2678" name="remove_document" /><variable attributes="__instancevar__" citdl="function" doc="Test if a given document in the relevance set.&#xA;&#xA;bool Xapian::RSet::contains(const Xapian::MSetIterator &amp;i) const " line="2686" name="contains" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::RSet::get_description() const " line="2694" name="__str__" /></scope><variable citdl="_xapian.RSet_swigregister" line="2708" name="RSet_swigregister" /><scope classrefs="object" doc="Base class for matcher decision functor. " ilk="class" line="2711" lineend="2727" name="MatchDecider"><variable citdl="_swig_property()" line="2715" name="thisown" /><variable citdl="_swig_repr" line="2716" name="__repr__" /><variable citdl="_xapian.delete_MatchDecider" line="2717" name="__swig_destroy__" /><scope attributes="__ctor__" ilk="function" line="2718" lineend="2723" name="__init__" signature="MatchDecider()"><variable citdl="MatchDecider" ilk="argument" name="self" /><variable attributes="protected" citdl="MatchDecider" line="2720" name="_self" /></scope><scope ilk="function" line="2724" lineend="2727" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="MatchDecider" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2728" name="__call__" /></scope><variable citdl="_xapian.MatchDecider_swigregister" line="2729" name="MatchDecider_swigregister" /><scope classrefs="object" doc="Virtual base class for expand decider functor. " ilk="class" line="2732" lineend="2748" name="ExpandDecider"><variable citdl="_swig_property()" line="2736" name="thisown" /><variable citdl="_swig_repr" line="2737" name="__repr__" /><variable citdl="_xapian.delete_ExpandDecider" line="2738" name="__swig_destroy__" /><scope attributes="__ctor__" ilk="function" line="2739" lineend="2744" name="__init__" signature="ExpandDecider()"><variable citdl="ExpandDecider" ilk="argument" name="self" /><variable attributes="protected" citdl="ExpandDecider" line="2741" name="_self" /></scope><scope ilk="function" line="2745" lineend="2748" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="ExpandDecider" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="2749" name="__call__" /></scope><variable citdl="_xapian.ExpandDecider_swigregister" line="2750" name="ExpandDecider_swigregister" /><scope classrefs="object" doc="This class provides an interface to the information retrieval system&#xA;for the purpose of searching.&#xA;&#xA;Databases are usually opened lazily, so exceptions may not be thrown&#xA;where you would expect them to be. You should catch Xapian::Error&#xA;exceptions when calling any method in Xapian::Enquire.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if an invalid argument&#xA;is supplied, for example, an unknown database type. " ilk="class" line="2753" lineend="3139" name="Enquire"><variable citdl="_swig_property()" line="2768" name="thisown" /><variable citdl="_swig_repr" line="2769" name="__repr__" /><scope attributes="__ctor__" doc="Create a Xapian::Enquire object.&#xA;&#xA;Xapian::Enquire::Enquire(const Database &amp;database, ErrorHandler&#xA;*errorhandler_=0)&#xA;&#xA;This specification cannot be changed once the Xapian::Enquire is&#xA;opened: you must create a new Xapian::Enquire object to access a&#xA;different database, or set of databases.&#xA;&#xA;The database supplied must have been initialised (ie, must not be the&#xA;result of calling the Database::Database() constructor). If you need&#xA;to handle a situation where you have no index gracefully, a database&#xA;created with InMemory::open() can be passed here, which represents a&#xA;completely empty database.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;database:  Specification of the database or databases to use.&#xA;&#xA;errorhandler_:  A pointer to the error handler to use. Ownership of&#xA;the object pointed to is not assumed by the Xapian::Enquire object -&#xA;the user should delete the Xapian::ErrorHandler object after the&#xA;Xapian::Enquire object is deleted. To use no error handler, this&#xA;parameter should be 0.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if an empty Database&#xA;object is supplied. " ilk="function" line="2770" lineend="2804" name="__init__" signature="Enquire(*args)"><variable citdl="Enquire" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_Enquire" line="2805" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Set the query to run.&#xA;&#xA;void Xapian::Enquire::set_query(const Xapian::Query &amp;query,&#xA;Xapian::termcount qlen=0)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;query:  the new query to run.&#xA;&#xA;qlen:  the query length to use in weight calculations - by default the&#xA;sum of the wqf of all terms is used. " line="2806" name="set_query" /><variable attributes="__instancevar__" citdl="function" doc="Get the query which has been set.&#xA;&#xA;const Xapian::Query&amp; Xapian::Enquire::get_query() const&#xA;&#xA;This is only valid after set_query() has been called.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if query has not yet&#xA;been set. " line="2823" name="get_query" /><variable attributes="__instancevar__" citdl="function" doc="Add a matchspy.&#xA;&#xA;void Xapian::Enquire::add_matchspy(MatchSpy *spy)&#xA;&#xA;This matchspy will be called with some of the documents which match&#xA;the query, during the match process. Exactly which of the matching&#xA;documents are passed to it depends on exactly when certain&#xA;optimisations occur during the match process, but it can be controlled&#xA;to some extent by setting the checkatleast parameter to  get_mset().&#xA;&#xA;In particular, if there are enough matching documents, at least the&#xA;number specified by checkatleast will be passed to the matchspy. This&#xA;means that you can force the matchspy to be shown all matching&#xA;documents by setting checkatleast to the number of documents in the&#xA;database.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;spy:  The MatchSpy subclass to add. The caller must ensure that this&#xA;remains valid while the Enquire object remains active, or until&#xA;clear_matchspies() is called. " line="2839" name="add_matchspy" /><variable attributes="__instancevar__" citdl="function" doc="Remove all the matchspies.&#xA;&#xA;void Xapian::Enquire::clear_matchspies() " line="2866" name="clear_matchspies" /><variable attributes="__instancevar__" citdl="function" doc="Set the weighting scheme to use for queries.&#xA;&#xA;void Xapian::Enquire::set_weighting_scheme(const Weight &amp;weight_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;weight_:  the new weighting scheme. If no weighting scheme is&#xA;specified, the default is BM25 with the default parameters. " line="2874" name="set_weighting_scheme" /><variable attributes="__instancevar__" citdl="function" doc="Set the collapse key to use for queries.&#xA;&#xA;void Xapian::Enquire::set_collapse_key(Xapian::valueno collapse_key,&#xA;Xapian::doccount collapse_max=1)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;collapse_key:  value number to collapse on - at most one MSet entry&#xA;with each particular value will be returned (default is&#xA;Xapian::BAD_VALUENO which means no collapsing).&#xA;&#xA;collapse_max:  Max number of items with the same key to leave after&#xA;collapsing (default 1).&#xA;&#xA;The MSet returned by get_mset() will have only the &quot;best&quot; (at most)&#xA;collapse_max entries with each particular value of collapse_key&#xA;(&quot;best&quot; being highest ranked - i.e. highest weight or highest&#xA;sorting key).&#xA;&#xA;An example use might be to create a value for each document containing&#xA;an MD5 hash of the document contents. Then duplicate documents from&#xA;different sources can be eliminated at search time by collapsing with&#xA;collapse_max = 1 (it&apos;s better to eliminate duplicates at index time,&#xA;but this may not be always be possible - for example the search may be&#xA;over more than one Xapian database).&#xA;&#xA;Another use is to group matches in a particular category (e.g. you&#xA;might collapse a mailing list search on the Subject: so that there&apos;s&#xA;only one result per discussion thread). In this case you can use&#xA;get_collapse_count() to give the user some idea how many other results&#xA;there are. And if you index the Subject: as a boolean term as well as&#xA;putting it in a value, you can offer a link to a non-collapsed search&#xA;restricted to that thread using a boolean filter. " line="2888" name="set_collapse_key" /><variable citdl="_xapian.Enquire_ASCENDING" line="2927" name="ASCENDING" /><variable citdl="_xapian.Enquire_DESCENDING" line="2928" name="DESCENDING" /><variable citdl="_xapian.Enquire_DONT_CARE" line="2929" name="DONT_CARE" /><variable attributes="__instancevar__" citdl="function" doc="Set the direction in which documents are ordered by document id in the&#xA;returned MSet.&#xA;&#xA;void Xapian::Enquire::set_docid_order(docid_order order)&#xA;&#xA;This order only has an effect on documents which would otherwise have&#xA;equal rank. For a weighted probabilistic match with no sort value,&#xA;this means documents with equal weight. For a boolean match, with no&#xA;sort value, this means all documents. And if a sort value is used,&#xA;this means documents with equal sort value (and also equal weight if&#xA;ordering on relevance after the sort).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;order:  This can be: Xapian::Enquire::ASCENDING docids sort in&#xA;ascending order (default)&#xA;&#xA;Xapian::Enquire::DESCENDING docids sort in descending order&#xA;&#xA;Xapian::Enquire::DONT_CARE docids sort in whatever order is most&#xA;efficient for the backend&#xA;&#xA;Note: If you add documents in strict date order, then a boolean search&#xA;- i.e. set_weighting_scheme(Xapian::BoolWeight()) - with&#xA;set_docid_order(Xapian::Enquire::DESCENDING) is an efficient way to&#xA;perform &quot;sort by date, newest first&quot;, and with&#xA;set_docid_order(Xapian::Enquire::ASCENDING) a very efficient way to&#xA;perform &quot;sort by date, oldest first&quot;. " line="2930" name="set_docid_order" /><variable attributes="__instancevar__" citdl="function" doc="Set the percentage and/or weight cutoffs.&#xA;&#xA;void Xapian::Enquire::set_cutoff(Xapian::percent percent_cutoff,&#xA;Xapian::weight weight_cutoff=0)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;percent_cutoff:  Minimum percentage score for returned documents. If a&#xA;document has a lower percentage score than this, it will not appear in&#xA;the MSet. If your intention is to return only matches which contain&#xA;all the terms in the query, then it&apos;s more efficient to use&#xA;Xapian::Query::OP_AND instead of Xapian::Query::OP_OR in the query&#xA;than to use set_cutoff(100). (default 0 =&gt; no percentage cut-off).&#xA;&#xA;weight_cutoff:  Minimum weight for a document to be returned. If a&#xA;document has a lower score that this, it will not appear in the MSet.&#xA;It is usually only possible to choose an appropriate weight for cutoff&#xA;based on the results of a previous run of the same query; this is thus&#xA;mainly useful for alerting operations. The other potential use is with&#xA;a user specified weighting scheme. (default 0 =&gt; no weight cut-off).&#xA;" line="2964" name="set_cutoff" /><variable attributes="__instancevar__" citdl="function" doc="Set the sorting to be by relevance only.&#xA;&#xA;void Xapian::Enquire::set_sort_by_relevance()&#xA;&#xA;This is the default. " line="2991" name="set_sort_by_relevance" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_value(Xapian::valueno sort_key) " line="3001" name="set_sort_by_value" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_value_then_relevance(Xapian::valueno&#xA;sort_key) " line="3008" name="set_sort_by_value_then_relevance" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_relevance_then_value(Xapian::valueno&#xA;sort_key) " line="3016" name="set_sort_by_relevance_then_value" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_key(Xapian::KeyMaker *sorter) " line="3024" name="set_sort_by_key" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_key_then_relevance(Xapian::KeyMaker&#xA;*sorter) " line="3031" name="set_sort_by_key_then_relevance" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::Enquire::set_sort_by_relevance_then_key(Xapian::KeyMaker&#xA;*sorter) " line="3039" name="set_sort_by_relevance_then_key" /><variable citdl="_xapian.Enquire_INCLUDE_QUERY_TERMS" line="3047" name="INCLUDE_QUERY_TERMS" /><variable citdl="_xapian.Enquire_USE_EXACT_TERMFREQ" line="3048" name="USE_EXACT_TERMFREQ" /><variable attributes="__instancevar__" citdl="function" doc="Get the expand set for the given rset.&#xA;&#xA;ESet Xapian::Enquire::get_eset(Xapian::termcount maxitems, const RSet&#xA;&amp;omrset, int flags, double k, const Xapian::ExpandDecider *edecider,&#xA;Xapian::weight min_wt) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;maxitems:  the maximum number of items to return.&#xA;&#xA;omrset:  the relevance set to use when performing the expand&#xA;operation.&#xA;&#xA;flags:  zero or more of these values |-ed together:&#xA;Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from&#xA;expand&#xA;&#xA;Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact&#xA;termfreq; otherwise an approximation is used which can greatly improve&#xA;efficiency, but still returns good results.&#xA;&#xA;k:  the parameter k in the query expansion algorithm (default is 1.0)&#xA;&#xA;edecider:  a decision functor to use to decide whether a given term&#xA;should be put in the ESet&#xA;&#xA;min_wt:  the minimum weight for included terms&#xA;&#xA;An ESet object containing the results of the expand.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  See class documentation. " line="3049" name="get_eset" /><variable attributes="__instancevar__" citdl="function" doc="Get terms which match a given document, by match set item.&#xA;&#xA;TermIterator Xapian::Enquire::get_matching_terms_begin(const&#xA;MSetIterator &amp;it) const&#xA;&#xA;This method returns the terms in the current query which match the&#xA;given document.&#xA;&#xA;If the underlying database has suitable support, using this call&#xA;(rather than passing a Xapian::docid) will enable the system to ensure&#xA;that the correct data is returned, and that the document has not been&#xA;deleted or changed since the query was performed.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;it:  The iterator for which to retrieve the matching terms.&#xA;&#xA;An iterator returning the terms which match the document. The terms&#xA;will be returned (as far as this makes any sense) in the same order as&#xA;the terms in the query. Terms will not occur more than once, even if&#xA;they do in the query.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  See class documentation.&#xA;&#xA;Xapian::DocNotFoundError:  The document specified could not be found&#xA;in the database. " line="3089" name="get_matching_terms_begin" /><variable attributes="__instancevar__" citdl="function" doc="End iterator corresponding to get_matching_terms_begin().&#xA;&#xA;TermIterator Xapian::Enquire::get_matching_terms_end(const&#xA;MSetIterator &amp;) const " line="3124" name="get_matching_terms_end" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::Enquire::get_description() const " line="3133" name="__str__" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="3156" name="get_mset" /><variable attributes="__instancevar__" citdl="_enquire_gen_iter" line="6735" name="matching_terms" /></scope><variable citdl="_xapian.Enquire_swigregister" line="3161" name="Enquire_swigregister" /><scope classrefs="object" doc="Registry for user subclasses.&#xA;&#xA;This class provides a way for the remote server to look up user&#xA;subclasses when unserialising. " ilk="class" line="3164" lineend="3277" name="Registry"><variable citdl="_swig_property()" line="3171" name="thisown" /><variable citdl="_swig_repr" line="3172" name="__repr__" /><scope attributes="__ctor__" doc="Default constructor.&#xA;&#xA;Xapian::Registry::Registry()&#xA;&#xA;The registry will contain all standard subclasses of user-subclassable&#xA;classes. " ilk="function" line="3173" lineend="3182" name="__init__" signature="Registry(*args)"><variable citdl="Registry" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_Registry" line="3183" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Register a weighting scheme.&#xA;&#xA;void Xapian::Registry::register_weighting_scheme(const Xapian::Weight&#xA;&amp;wt)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;wt:  The weighting scheme to register. " line="3184" name="register_weighting_scheme" /><variable attributes="__instancevar__" citdl="function" doc="Get the weighting scheme given a name.&#xA;&#xA;const Xapian::Weight* Xapian::Registry::get_weighting_scheme(const&#xA;std::string &amp;name) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;name:  The name of the weighting scheme to find.&#xA;&#xA;An object with the requested name, or NULL if the weighting scheme&#xA;could not be found. The returned object is owned by the registry and&#xA;so must not be deleted by the caller. " line="3198" name="get_weighting_scheme" /><variable attributes="__instancevar__" citdl="function" doc="Register a user-defined posting source class.&#xA;&#xA;void Xapian::Registry::register_posting_source(const&#xA;Xapian::PostingSource &amp;source)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;source:  The posting source to register. " line="3216" name="register_posting_source" /><variable attributes="__instancevar__" citdl="function" doc="Get a posting source given a name.&#xA;&#xA;const Xapian::PostingSource*&#xA;Xapian::Registry::get_posting_source(const std::string &amp;name) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;name:  The name of the posting source to find.&#xA;&#xA;An object with the requested name, or NULL if the posting source could&#xA;not be found. The returned object is owned by the registry and so must&#xA;not be deleted by the caller. " line="3230" name="get_posting_source" /><variable attributes="__instancevar__" citdl="function" doc="Register a user-defined match spy class.&#xA;&#xA;void Xapian::Registry::register_match_spy(const Xapian::MatchSpy &amp;spy)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;spy:  The match spy to register. " line="3248" name="register_match_spy" /><variable attributes="__instancevar__" citdl="function" doc="Get a match spy given a name.&#xA;&#xA;const Xapian::MatchSpy* Xapian::Registry::get_match_spy(const&#xA;std::string &amp;name) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;name:  The name of the match spy to find.&#xA;&#xA;An object with the requested name, or NULL if the match spy could not&#xA;be found. The returned object is owned by the registry and so must not&#xA;be deleted by the caller. " line="3261" name="get_match_spy" /></scope><variable citdl="_xapian.Registry_swigregister" line="3285" name="Registry_swigregister" /><scope classrefs="object" doc="Abstract base class for weighting schemes. " ilk="class" line="3288" lineend="3374" name="Weight"><variable citdl="_swig_property()" line="3292" name="thisown" /><scope attributes="__ctor__" ilk="function" line="3293" lineend="3293" name="__init__" signature="Weight(*args, **kwargs)"><variable citdl="Weight" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="3294" name="__repr__" /><variable citdl="_xapian.delete_Weight" line="3295" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return the name of this weighting scheme.&#xA;&#xA;virtual std::string Xapian::Weight::name() const&#xA;&#xA;This name is used by the remote backend. It is passed along with the&#xA;serialised parameters to the remote server so that it knows which&#xA;class to create.&#xA;&#xA;Return the full namespace-qualified name of your class here - if your&#xA;class is called FooWeight, return &quot;FooWeight&quot; from this method (&#xA;Xapian::BM25Weight returns &quot;Xapian::BM25Weight&quot; here).&#xA;&#xA;If you don&apos;t want to support the remote backend, you can use the&#xA;default implementation which simply returns an empty string. " line="3296" name="name" /><variable attributes="__instancevar__" citdl="function" doc="Calculate the weight contribution for this object&apos;s term to a&#xA;document.&#xA;&#xA;virtual Xapian::weight Xapian::Weight::get_sumpart(Xapian::termcount&#xA;wdf, Xapian::termcount doclen) const =0&#xA;&#xA;The parameters give information about the document which may be used&#xA;in the calculations:&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;wdf:  The within document frequency of the term in the document.&#xA;&#xA;doclen:  The document&apos;s length (unnormalised). " line="3315" name="get_sumpart" /><variable attributes="__instancevar__" citdl="function" doc="Return an upper bound on what get_sumpart() can return for any&#xA;document.&#xA;&#xA;virtual Xapian::weight Xapian::Weight::get_maxpart() const =0&#xA;&#xA;This information is used by the matcher to perform various&#xA;optimisations, so strive to make the bound as tight as possible. " line="3335" name="get_maxpart" /><variable attributes="__instancevar__" citdl="function" doc="Calculate the term-independent weight component for a document.&#xA;&#xA;virtual Xapian::weight Xapian::Weight::get_sumextra(Xapian::termcount&#xA;doclen) const =0&#xA;&#xA;The parameter gives information about the document which may be used&#xA;in the calculations:&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;doclen:  The document&apos;s length (unnormalised). " line="3347" name="get_sumextra" /><variable attributes="__instancevar__" citdl="function" doc="Return an upper bound on what get_sumextra() can return for any&#xA;document.&#xA;&#xA;virtual Xapian::weight Xapian::Weight::get_maxextra() const =0&#xA;&#xA;This information is used by the matcher to perform various&#xA;optimisations, so strive to make the bound as tight as possible. " line="3364" name="get_maxextra" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="3381" name="get_sumpart_needs_doclength_" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="3382" name="get_sumpart_needs_wdf_" /></scope><variable citdl="_xapian.Weight_swigregister" line="3383" name="Weight_swigregister" /><scope classrefs="Weight" doc="Class implementing a &quot;boolean&quot; weighting scheme.&#xA;&#xA;This weighting scheme gives all documents zero weight. " ilk="class" line="3386" lineend="3401" name="BoolWeight"><variable citdl="_swig_property()" line="3392" name="thisown" /><variable citdl="_swig_repr" line="3393" name="__repr__" /><scope attributes="__ctor__" doc="Construct a BoolWeight.&#xA;&#xA;Xapian::BoolWeight::BoolWeight() " ilk="function" line="3394" lineend="3400" name="__init__" signature="BoolWeight()"><variable citdl="BoolWeight" ilk="argument" name="self" /></scope><variable citdl="_xapian.delete_BoolWeight" line="3401" name="__swig_destroy__" /></scope><variable citdl="_xapian.BoolWeight_swigregister" line="3402" name="BoolWeight_swigregister" /><scope classrefs="Weight" doc="Xapian::Weight subclass implementing the BM25 probabilistic formula.&#xA;" ilk="class" line="3405" lineend="3415" name="BM25Weight"><variable citdl="_swig_property()" line="3410" name="thisown" /><variable citdl="_swig_repr" line="3411" name="__repr__" /><scope attributes="__ctor__" doc="Xapian::BM25Weight::BM25Weight() " ilk="function" line="3412" lineend="3414" name="__init__" signature="BM25Weight(*args)"><variable citdl="BM25Weight" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_BM25Weight" line="3415" name="__swig_destroy__" /></scope><variable citdl="_xapian.BM25Weight_swigregister" line="3416" name="BM25Weight_swigregister" /><scope classrefs="Weight" doc="Xapian::Weight subclass implementing the traditional probabilistic&#xA;formula.&#xA;&#xA;This class implements the &quot;traditional&quot; Probabilistic Weighting&#xA;scheme, as described by the early papers on Probabilistic Retrieval.&#xA;BM25 generally gives better results.&#xA;&#xA;TradWeight(k) is equivalent to BM25Weight(k, 0, 0, 1, 0), except that&#xA;the latter returns weights (k+1) times larger. " ilk="class" line="3419" lineend="3448" name="TradWeight"><variable citdl="_swig_property()" line="3431" name="thisown" /><variable citdl="_swig_repr" line="3432" name="__repr__" /><scope attributes="__ctor__" doc="Construct a TradWeight.&#xA;&#xA;Xapian::TradWeight::TradWeight(double k=1.0)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;k:  A non-negative parameter controlling how influential within-&#xA;document- frequency (wdf) and document length are. k=0 means that wdf&#xA;and document length don&apos;t affect the weights. The larger k is, the&#xA;more they do. (default 1) " ilk="function" line="3433" lineend="3447" name="__init__" signature="TradWeight(k=1.0)"><variable citdl="TradWeight" ilk="argument" name="self" /><variable citdl="float" ilk="argument" name="k" /></scope><variable citdl="_xapian.delete_TradWeight" line="3448" name="__swig_destroy__" /></scope><variable citdl="_xapian.TradWeight_swigregister" line="3449" name="TradWeight_swigregister" /><scope classrefs="object" doc="Abstract base class for match spies.&#xA;&#xA;The subclasses will generally accumulate information seen during the&#xA;match, to calculate aggregate functions, or other profiles of the&#xA;matching documents. " ilk="class" line="3452" lineend="3526" name="MatchSpy"><variable citdl="_swig_property()" line="3460" name="thisown" /><variable citdl="_swig_repr" line="3461" name="__repr__" /><scope attributes="__ctor__" ilk="function" line="3462" lineend="3467" name="__init__" signature="MatchSpy()"><variable citdl="MatchSpy" ilk="argument" name="self" /><variable attributes="protected" citdl="MatchSpy" line="3464" name="_self" /></scope><variable citdl="_xapian.delete_MatchSpy" line="3468" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return the name of this match spy.&#xA;&#xA;virtual std::string Xapian::MatchSpy::name() const&#xA;&#xA;This name is used by the remote backend. It is passed with the&#xA;serialised parameters to the remote server so that it knows which&#xA;class to create.&#xA;&#xA;Return the full namespace-qualified name of your class here - if your&#xA;class is called MyApp::FooMatchSpy, return &quot;MyApp::FooMatchSpy&quot; from&#xA;this method.&#xA;&#xA;If you don&apos;t want to support the remote backend in your match spy, you&#xA;can use the default implementation which simply throws&#xA;Xapian::UnimplementedError. " line="3469" name="name" /><variable attributes="__instancevar__" citdl="function" doc="Unserialise some results, and merge them into this matchspy.&#xA;&#xA;virtual void Xapian::MatchSpy::merge_results(const std::string &amp;s)&#xA;&#xA;The order in which results are merged should not be significant, since&#xA;this order is not specified (and will vary depending on the speed of&#xA;the search in each sub-database).&#xA;&#xA;If you don&apos;t want to support the remote backend in your match spy, you&#xA;can use the default implementation which simply throws&#xA;Xapian::UnimplementedError.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;s:  A string containing the serialised results. " line="3489" name="merge_results" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;virtual std::string Xapian::MatchSpy::get_description() const&#xA;&#xA;This default implementation returns a generic answer, to avoid forcing&#xA;those deriving their own MatchSpy subclasses from having to implement&#xA;this (they may not care what get_description() gives for their&#xA;subclass). " line="3510" name="__str__" /><scope ilk="function" line="3523" lineend="3526" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="MatchSpy" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="3527" name="__call__" /></scope><variable citdl="_xapian.MatchSpy_swigregister" line="3531" name="MatchSpy_swigregister" /><scope classrefs="MatchSpy" doc="Class for counting the frequencies of values in the matching&#xA;documents. " ilk="class" line="3534" lineend="3607" name="ValueCountMatchSpy"><variable citdl="_swig_property()" line="3539" name="thisown" /><variable citdl="_swig_repr" line="3540" name="__repr__" /><scope attributes="__ctor__" doc="Construct a MatchSpy which counts the values in a particular slot.&#xA;&#xA;Xapian::ValueCountMatchSpy::ValueCountMatchSpy(Xapian::valueno slot_)&#xA;" ilk="function" line="3541" lineend="3548" name="__init__" signature="ValueCountMatchSpy(*args)"><variable citdl="ValueCountMatchSpy" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Return the total number of documents tallied.&#xA;&#xA;size_t Xapian::ValueCountMatchSpy::get_total() const " line="3549" name="get_total" /><variable attributes="__instancevar__" citdl="function" doc="Get an iterator over the values seen in the slot.&#xA;&#xA;TermIterator Xapian::ValueCountMatchSpy::values_begin() const&#xA;&#xA;Items will be returned in ascending alphabetical order.&#xA;&#xA;During the iteration, the frequency of the current value can be&#xA;obtained with the get_termfreq() method on the iterator. " line="3557" name="values_begin" /><variable attributes="__instancevar__" citdl="function" doc="End iterator corresponding to values_begin().&#xA;&#xA;TermIterator Xapian::ValueCountMatchSpy::values_end() const " line="3570" name="values_end" /><variable attributes="__instancevar__" citdl="function" doc="Get an iterator over the most frequent values seen in the slot.&#xA;&#xA;TermIterator Xapian::ValueCountMatchSpy::top_values_begin(size_t&#xA;maxvalues) const&#xA;&#xA;Items will be returned in descending order of frequency. Values with&#xA;the same frequency will be returned in ascending alphabetical order.&#xA;&#xA;During the iteration, the frequency of the current value can be&#xA;obtained with the get_termfreq() method on the iterator.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;maxvalues:  The maximum number of values to return. " line="3578" name="top_values_begin" /><variable attributes="__instancevar__" citdl="function" doc="End iterator corresponding to top_values_begin().&#xA;&#xA;TermIterator Xapian::ValueCountMatchSpy::top_values_end(size_t) const&#xA;" line="3598" name="top_values_end" /><variable citdl="_xapian.delete_ValueCountMatchSpy" line="3607" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="wrapper()" line="6928" name="values" /><variable attributes="__instancevar__" citdl="wrapper()" line="6951" name="top_values" /></scope><variable citdl="_xapian.ValueCountMatchSpy_swigregister" line="3613" name="ValueCountMatchSpy_swigregister" /><scope classrefs="object" doc="This class is used to access a database, or a group of databases.&#xA;&#xA;For searching, this class is used in conjunction with an Enquire&#xA;object.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;InvalidArgumentError:  will be thrown if an invalid argument is&#xA;supplied, for example, an unknown database type.&#xA;&#xA;DatabaseOpeningError:  may be thrown if the database cannot be opened&#xA;(for example, a required file cannot be found).&#xA;&#xA;DatabaseVersionError:  may be thrown if the database is in an&#xA;unsupported format (for example, created by a newer version of Xapian&#xA;which uses an incompatible format). " ilk="class" line="3616" lineend="4236" name="Database"><variable citdl="_swig_property()" line="3636" name="thisown" /><variable citdl="_swig_repr" line="3637" name="__repr__" /><variable attributes="__instancevar__" citdl="function" doc="Add an existing database (or group of databases) to those accessed by&#xA;this object.&#xA;&#xA;void Xapian::Database::add_database(const Database &amp;database)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;database:  the database(s) to add. " line="3638" name="add_database" /><variable citdl="_xapian.delete_Database" line="3652" name="__swig_destroy__" /><scope attributes="__ctor__" doc="Copying is allowed.&#xA;&#xA;Xapian::Database::Database(const Database &amp;other)&#xA;&#xA;The internals are reference counted, so copying is cheap.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;other:  The object to copy. " ilk="function" line="3653" lineend="3666" name="__init__" signature="Database(*args)"><variable citdl="Database" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Re-open the database.&#xA;&#xA;void Xapian::Database::reopen()&#xA;&#xA;This re-opens the database(s) to the latest available version(s). It&#xA;can be used either to make sure the latest results are returned, or to&#xA;recover from a Xapian::DatabaseModifiedError.&#xA;&#xA;Calling reopen() on a database which has been closed (with  close())&#xA;will always raise a Xapian::DatabaseError. " line="3667" name="reopen" /><variable attributes="__instancevar__" citdl="function" doc="Close the database.&#xA;&#xA;virtual void Xapian::Database::close()&#xA;&#xA;This closes the database and closes all its file handles.&#xA;&#xA;For a WritableDatabase, if a transaction is active it will be aborted,&#xA;while if no transaction is active commit() will be implicitly called.&#xA;Also the write lock is released.&#xA;&#xA;Closing a database cannot be undone - in particular, calling reopen()&#xA;after close() will not reopen it, but will instead throw a&#xA;Xapian::DatabaseError exception.&#xA;&#xA;Calling close() again on a database which has already been closed has&#xA;no effect (and doesn&apos;t raise an exception).&#xA;&#xA;After close() has been called, calls to other methods of the database,&#xA;and to methods of other objects associated with the database, will&#xA;either:&#xA;&#xA;behave exactly as they would have done if the database had not been&#xA;closed (this can only happen if all the required data is cached)&#xA;&#xA;raise a Xapian::DatabaseError exception indicating that the database&#xA;is closed.&#xA;&#xA;The reason for this behaviour is that otherwise we&apos;d have to check&#xA;that the database is still open on every method call on every object&#xA;associated with a Database, when in many cases they are working on&#xA;data which has already been loaded and so they are able to just behave&#xA;correctly.&#xA;&#xA;This method was added in Xapian 1.1.0. " line="3682" name="close" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;virtual std::string Xapian::Database::get_description() const " line="3721" name="__str__" /><variable attributes="__instancevar__" citdl="function" doc="An iterator pointing to the start of the postlist for a given term.&#xA;&#xA;PostingIterator Xapian::Database::postlist_begin(const std::string&#xA;&amp;tname) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The termname to iterate postings for. If the term name is the&#xA;empty string, the iterator returned will list all the documents in the&#xA;database. Such an iterator will always return a WDF value of 1, since&#xA;there is no obvious meaning for this quantity in this case. " line="3729" name="postlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to postlist_begin().&#xA;&#xA;PostingIterator Xapian::Database::postlist_end(const std::string &amp;)&#xA;const " line="3746" name="postlist_end" /><variable attributes="__instancevar__" citdl="function" doc="An iterator pointing to the start of the termlist for a given&#xA;document.&#xA;&#xA;TermIterator Xapian::Database::termlist_begin(Xapian::docid did) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;did:  The document id of the document to iterate terms for. " line="3755" name="termlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to termlist_begin().&#xA;&#xA;TermIterator Xapian::Database::termlist_end(Xapian::docid) const " line="3769" name="termlist_end" /><variable attributes="__instancevar__" citdl="function" doc="An iterator pointing to the start of the position list for a given&#xA;term in a given document.&#xA;&#xA;PositionIterator Xapian::Database::positionlist_begin(Xapian::docid&#xA;did, const std::string &amp;tname) const " line="3777" name="positionlist_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to positionlist_begin().&#xA;&#xA;PositionIterator Xapian::Database::positionlist_end(Xapian::docid,&#xA;const std::string &amp;) const " line="3787" name="positionlist_end" /><variable attributes="__instancevar__" citdl="function" doc="An iterator which runs across all terms with a given prefix.&#xA;&#xA;TermIterator Xapian::Database::allterms_begin(const std::string&#xA;&amp;prefix) const&#xA;&#xA;This is functionally similar to getting an iterator with&#xA;allterms_begin() and then calling skip_to(prefix) on that iterator to&#xA;move to the start of the prefix, but is more convenient (because it&#xA;detects the end of the prefixed terms), and may be more efficient than&#xA;simply calling skip_to() after opening the iterator, particularly for&#xA;remote databases.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;prefix:  The prefix to restrict the returned terms to. " line="3796" name="allterms_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to allterms_begin(prefix).&#xA;&#xA;TermIterator Xapian::Database::allterms_end(const std::string &amp;) const&#xA;" line="3817" name="allterms_end" /><variable attributes="__instancevar__" citdl="function" doc="Get the number of documents in the database.&#xA;&#xA;Xapian::doccount Xapian::Database::get_doccount() const " line="3826" name="get_doccount" /><variable attributes="__instancevar__" citdl="function" doc="Get the highest document id which has been used in the database.&#xA;&#xA;Xapian::docid Xapian::Database::get_lastdocid() const " line="3834" name="get_lastdocid" /><variable attributes="__instancevar__" citdl="function" doc="Get the average length of the documents in the database.&#xA;&#xA;Xapian::doclength Xapian::Database::get_avlength() const " line="3842" name="get_avlength" /><variable attributes="__instancevar__" citdl="function" doc="Get the number of documents in the database indexed by a given term.&#xA;&#xA;Xapian::doccount Xapian::Database::get_termfreq(const std::string&#xA;&amp;tname) const " line="3850" name="get_termfreq" /><variable attributes="__instancevar__" citdl="function" doc="Check if a given term exists in the database.&#xA;&#xA;bool Xapian::Database::term_exists(const std::string &amp;tname) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The term to test the existence of.&#xA;&#xA;true if and only if the term exists in the database. This is the same&#xA;as (get_termfreq(tname) != 0), but will often be more efficient. " line="3859" name="term_exists" /><variable attributes="__instancevar__" citdl="function" doc="Return the total number of occurrences of the given term.&#xA;&#xA;Xapian::termcount Xapian::Database::get_collection_freq(const&#xA;std::string &amp;tname) const&#xA;&#xA;This is the sum of the number of occurrences of the term in each&#xA;document it indexes: i.e., the sum of the within document frequencies&#xA;of the term.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;tname:  The term whose collection frequency is being requested. " line="3875" name="get_collection_freq" /><variable attributes="__instancevar__" citdl="function" doc="Return the frequency of a given value slot.&#xA;&#xA;Xapian::doccount Xapian::Database::get_value_freq(Xapian::valueno&#xA;slot) const&#xA;&#xA;This is the number of documents which have a (non-empty) value stored&#xA;in the slot.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The value slot to examine.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;UnimplementedError:  The frequency of the value isn&apos;t available for&#xA;this database type. " line="3893" name="get_value_freq" /><variable attributes="__instancevar__" citdl="function" doc="Get a lower bound on the values stored in the given value slot.&#xA;&#xA;std::string Xapian::Database::get_value_lower_bound(Xapian::valueno&#xA;slot) const&#xA;&#xA;If there are no values stored in the given value slot, this will&#xA;return an empty string.&#xA;&#xA;If the lower bound isn&apos;t available for the given database type, this&#xA;will return the lowest possible bound - the empty string.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The value slot to examine. " line="3916" name="get_value_lower_bound" /><variable attributes="__instancevar__" citdl="function" doc="Get an upper bound on the values stored in the given value slot.&#xA;&#xA;std::string Xapian::Database::get_value_upper_bound(Xapian::valueno&#xA;slot) const&#xA;&#xA;If there are no values stored in the given value slot, this will&#xA;return an empty string.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The value slot to examine.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;UnimplementedError:  The upper bound of the values isn&apos;t available for&#xA;this database type. " line="3936" name="get_value_upper_bound" /><variable attributes="__instancevar__" citdl="function" doc="Get a lower bound on the length of a document in this DB.&#xA;&#xA;Xapian::termcount Xapian::Database::get_doclength_lower_bound() const&#xA;&#xA;This bound does not include any zero-length documents. " line="3959" name="get_doclength_lower_bound" /><variable attributes="__instancevar__" citdl="function" doc="Get an upper bound on the length of a document in this DB.&#xA;&#xA;Xapian::termcount Xapian::Database::get_doclength_upper_bound() const&#xA;" line="3969" name="get_doclength_upper_bound" /><variable attributes="__instancevar__" citdl="function" doc="Get an upper bound on the wdf of term term.&#xA;&#xA;Xapian::termcount Xapian::Database::get_wdf_upper_bound(const&#xA;std::string &amp;term) const " line="3978" name="get_wdf_upper_bound" /><variable attributes="__instancevar__" citdl="function" doc="Return an iterator over the value in slot slot for each document.&#xA;&#xA;ValueIterator Xapian::Database::valuestream_begin(Xapian::valueno&#xA;slot) const " line="3987" name="valuestream_begin" /><variable attributes="__instancevar__" citdl="function" doc="Return end iterator corresponding to valuestream_begin().&#xA;&#xA;ValueIteratorEnd_ Xapian::Database::valuestream_end(Xapian::valueno)&#xA;const " line="3996" name="valuestream_end" /><variable attributes="__instancevar__" citdl="function" doc="Get the length of a document.&#xA;&#xA;Xapian::termcount Xapian::Database::get_doclength(Xapian::docid did)&#xA;const " line="4005" name="get_doclength" /><variable attributes="__instancevar__" citdl="function" doc="Send a &quot;keep-alive&quot; to remote databases to stop them timing out.&#xA;&#xA;void Xapian::Database::keep_alive()&#xA;&#xA;Has no effect on non-remote databases. " line="4014" name="keep_alive" /><variable attributes="__instancevar__" citdl="function" doc="Get a document from the database, given its document id.&#xA;&#xA;Xapian::Document Xapian::Database::get_document(Xapian::docid did)&#xA;const&#xA;&#xA;This method returns a Xapian::Document object which provides the&#xA;information about a document.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;did:  The document id of the document to retrieve.&#xA;&#xA;A Xapian::Document object containing the document data&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DocNotFoundError:  The document specified could not be found&#xA;in the database.&#xA;&#xA;Xapian::InvalidArgumentError:  did was 0, which is not a valid&#xA;document id. " line="4024" name="get_document" /><variable attributes="__instancevar__" citdl="function" doc="Suggest a spelling correction.&#xA;&#xA;std::string Xapian::Database::get_spelling_suggestion(const&#xA;std::string &amp;word, unsigned max_edit_distance=2) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;word:  The potentially misspelled word.&#xA;&#xA;max_edit_distance:  Only consider words which are at most&#xA;max_edit_distance edits from word. An edit is a character insertion,&#xA;deletion, or the transposition of two adjacent characters (default is&#xA;2). " line="4052" name="get_spelling_suggestion" /><variable attributes="__instancevar__" citdl="function" doc="An iterator which returns all the spelling correction targets.&#xA;&#xA;Xapian::TermIterator Xapian::Database::spellings_begin() const&#xA;&#xA;This returns all the words which are considered as targets for the&#xA;spelling correction algorithm. The frequency of each word is available&#xA;as the term frequency of each entry in the returned iterator. " line="4071" name="spellings_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to spellings_begin().&#xA;&#xA;Xapian::TermIterator Xapian::Database::spellings_end() const " line="4083" name="spellings_end" /><variable attributes="__instancevar__" citdl="function" doc="An iterator which returns all the synonyms for a given term.&#xA;&#xA;Xapian::TermIterator Xapian::Database::synonyms_begin(const&#xA;std::string &amp;term) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;term:  The term to return synonyms for. " line="4091" name="synonyms_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to synonyms_begin(term).&#xA;&#xA;Xapian::TermIterator Xapian::Database::synonyms_end(const std::string&#xA;&amp;) const " line="4105" name="synonyms_end" /><variable attributes="__instancevar__" citdl="function" doc="An iterator which returns all terms which have synonyms.&#xA;&#xA;Xapian::TermIterator Xapian::Database::synonym_keys_begin(const&#xA;std::string &amp;prefix=std::string()) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;prefix:  If non-empty, only terms with this prefix are returned. " line="4114" name="synonym_keys_begin" /><variable attributes="__instancevar__" citdl="function" doc="Corresponding end iterator to synonym_keys_begin(prefix).&#xA;&#xA;Xapian::TermIterator Xapian::Database::synonym_keys_end(const&#xA;std::string &amp;=std::string()) const " line="4128" name="synonym_keys_end" /><variable attributes="__instancevar__" citdl="function" doc="Get the user-specified metadata associated with a given key.&#xA;&#xA;std::string Xapian::Database::get_metadata(const std::string &amp;key)&#xA;const&#xA;&#xA;User-specified metadata allows you to store arbitrary information in&#xA;the form of (key,tag) pairs. See  WritableDatabase::set_metadata() for&#xA;more information.&#xA;&#xA;When invoked on a Xapian::Database object representing multiple&#xA;databases, currently only the metadata for the first is considered but&#xA;this behaviour may change in the future.&#xA;&#xA;If there is no piece of metadata associated with the specified key, an&#xA;empty string is returned (this applies even for backends which don&apos;t&#xA;support metadata).&#xA;&#xA;Empty keys are not valid, and specifying one will cause an exception.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;key:  The key of the metadata item to access.&#xA;&#xA;The retrieved metadata item&apos;s value.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if the key supplied is&#xA;empty. " line="4137" name="get_metadata" /><variable attributes="protected __instancevar__" citdl="function" doc="An iterator which returns all user-specified metadata keys.&#xA;&#xA;Xapian::TermIterator Xapian::Database::metadata_keys_begin(const&#xA;std::string &amp;prefix=std::string()) const&#xA;&#xA;When invoked on a Xapian::Database object representing multiple&#xA;databases, currently only the metadata for the first is considered but&#xA;this behaviour may change in the future.&#xA;&#xA;If the backend doesn&apos;t support metadata, then this method returns an&#xA;iterator which compares equal to that returned by metadata_keys_end().&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;prefix:  If non-empty, only keys with this prefix are returned.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::UnimplementedError:  will be thrown if the backend implements&#xA;user-specified metadata, but doesn&apos;t implement iterating its keys&#xA;(currently this happens for the InMemory backend). " line="4173" name="_metadata_keys_begin" /><variable attributes="protected __instancevar__" citdl="function" doc="Corresponding end iterator to metadata_keys_begin().&#xA;&#xA;Xapian::TermIterator Xapian::Database::metadata_keys_end(const&#xA;std::string &amp;=std::string()) const " line="4201" name="_metadata_keys_end" /><variable attributes="__instancevar__" citdl="function" doc="Get a UUID for the database.&#xA;&#xA;std::string Xapian::Database::get_uuid() const&#xA;&#xA;The UUID will persist for the lifetime of the database.&#xA;&#xA;Replicas (eg, made with the replication protocol, or by copying all&#xA;the database files) will have the same UUID. However, copies (made&#xA;with copydatabase, or xapian-compact) will have different UUIDs.&#xA;&#xA;If the backend does not support UUIDs or this database has no&#xA;subdatabases, the UUID will be empty.&#xA;&#xA;If this database has multiple sub-databases, the UUID string will&#xA;contain the UUIDs of all the sub-databases. " line="4210" name="get_uuid" /><variable attributes="__instancevar__" citdl="function" doc="Does this database have any positional information?&#xA;&#xA;bool Xapian::Database::has_positions() const " line="4230" name="has_positions" /><variable attributes="__instancevar__" citdl="_database_gen_allterms_iter" line="6769" name="__iter__" /><variable attributes="__instancevar__" citdl="_database_gen_allterms_iter" line="6770" name="allterms" /><variable attributes="__instancevar__" citdl="_database_gen_termlist_iter" line="6790" name="termlist" /><variable attributes="__instancevar__" citdl="_database_gen_spellings_iter" line="6804" name="spellings" /><variable attributes="__instancevar__" citdl="_database_gen_synonyms_iter" line="6818" name="synonyms" /><variable attributes="__instancevar__" citdl="_database_gen_synonym_keys_iter" line="6832" name="synonym_keys" /><variable attributes="__instancevar__" citdl="_database_gen_metadata_keys_iter" line="6847" name="metadata_keys" /><variable attributes="__instancevar__" citdl="_database_gen_postlist_iter" line="7266" name="postlist" /><variable attributes="__instancevar__" citdl="_database_gen_positionlist_iter" line="7312" name="positionlist" /><variable attributes="__instancevar__" citdl="wrapper()" line="7469" name="valuestream" /></scope><variable citdl="_xapian.Database_swigregister" line="4279" name="Database_swigregister" /><scope classrefs="Database" doc="This class provides read/write access to a database. " ilk="class" line="4282" lineend="4743" name="WritableDatabase"><variable citdl="_swig_property()" line="4286" name="thisown" /><variable citdl="_swig_repr" line="4287" name="__repr__" /><variable citdl="_xapian.delete_WritableDatabase" line="4288" name="__swig_destroy__" /><scope attributes="__ctor__" doc="Copying is allowed.&#xA;&#xA;Xapian::WritableDatabase::WritableDatabase(const WritableDatabase&#xA;&amp;other)&#xA;&#xA;The internals are reference counted, so copying is cheap.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;other:  The object to copy. " ilk="function" line="4289" lineend="4303" name="__init__" signature="WritableDatabase(*args)"><variable citdl="WritableDatabase" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Commit any pending modifications made to the database.&#xA;&#xA;void Xapian::WritableDatabase::commit()&#xA;&#xA;For efficiency reasons, when performing multiple updates to a database&#xA;it is best (indeed, almost essential) to make as many modifications as&#xA;memory will permit in a single pass through the database. To ensure&#xA;this, Xapian batches up modifications.&#xA;&#xA;This method may be called at any time to commit any pending&#xA;modifications to the database.&#xA;&#xA;If any of the modifications fail, an exception will be thrown and the&#xA;database will be left in a state in which each separate addition,&#xA;replacement or deletion operation has either been fully performed or&#xA;not performed at all: it is then up to the application to work out&#xA;which operations need to be repeated.&#xA;&#xA;It&apos;s not valid to call commit() within a transaction.&#xA;&#xA;Beware of calling commit() too frequently: this will make indexing&#xA;take much longer.&#xA;&#xA;Note that commit() need not be called explicitly: it will be called&#xA;automatically when the database is closed, or when a sufficient number&#xA;of modifications have been made. By default, this is every 10000&#xA;documents added, deleted, or modified. This value is rather&#xA;conservative, and if you have a machine with plenty of memory, you can&#xA;improve indexing throughput dramatically by setting&#xA;XAPIAN_FLUSH_THRESHOLD in the environment to a larger value.&#xA;&#xA;This method was new in Xapian 1.1.0 - in earlier versions it was&#xA;called flush().&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;modifying the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state. " line="4304" name="commit" /><variable attributes="__instancevar__" citdl="function" doc="Pre-1.1.0 name for commit().&#xA;&#xA;void Xapian::WritableDatabase::flush()&#xA;&#xA;Use commit() instead in new code. This alias may be deprecated in the&#xA;future. " line="4351" name="flush" /><variable attributes="__instancevar__" citdl="function" doc="Begin a transaction.&#xA;&#xA;void Xapian::WritableDatabase::begin_transaction(bool flushed=true)&#xA;&#xA;In Xapian a transaction is a group of modifications to the database&#xA;which are linked such that either all will be applied simultaneously&#xA;or none will be applied at all. Even in the case of a power failure,&#xA;this characteristic should be preserved (as long as the filesystem&#xA;isn&apos;t corrupted, etc).&#xA;&#xA;A transaction is started with begin_transaction() and can either be&#xA;committed by calling commit_transaction() or aborted by calling&#xA;cancel_transaction().&#xA;&#xA;By default, a transaction implicitly calls commit() before and after&#xA;so that the modifications stand and fall without affecting&#xA;modifications before or after.&#xA;&#xA;The downside of these implicit calls to commit() is that small&#xA;transactions can harm indexing performance in the same way that&#xA;explicitly calling commit() frequently can.&#xA;&#xA;If you&apos;re applying atomic groups of changes and only wish to ensure&#xA;that each group is either applied or not applied, then you can prevent&#xA;the automatic commit() before and after the transaction by starting&#xA;the transaction with begin_transaction(false). However, if&#xA;cancel_transaction is called (or if commit_transaction isn&apos;t called&#xA;before the WritableDatabase object is destroyed) then any changes&#xA;which were pending before the transaction began will also be&#xA;discarded.&#xA;&#xA;Transactions aren&apos;t currently supported by the InMemory backend.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;flushed:  Is this a flushed transaction? By default transactions are&#xA;&quot;flushed&quot;, which means that committing a transaction will ensure&#xA;those changes are permanently written to the database. By contrast,&#xA;unflushed transactions only ensure that changes within the transaction&#xA;are either all applied or all aren&apos;t.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::UnimplementedError:  will be thrown if transactions are not&#xA;available for this database type.&#xA;&#xA;Xapian::InvalidOperationError:  will be thrown if this is called at an&#xA;invalid time, such as when a transaction is already in progress. " line="4362" name="begin_transaction" /><variable attributes="__instancevar__" citdl="function" doc="Complete the transaction currently in progress.&#xA;&#xA;void Xapian::WritableDatabase::commit_transaction()&#xA;&#xA;If this method completes successfully and this is a flushed&#xA;transaction, all the database modifications made during the&#xA;transaction will have been committed to the database.&#xA;&#xA;If an error occurs, an exception will be thrown, and none of the&#xA;modifications made to the database during the transaction will have&#xA;been applied to the database.&#xA;&#xA;In all cases the transaction will no longer be in progress.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;modifying the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state.&#xA;&#xA;Xapian::InvalidOperationError:  will be thrown if a transaction is not&#xA;currently in progress.&#xA;&#xA;Xapian::UnimplementedError:  will be thrown if transactions are not&#xA;available for this database type. " line="4417" name="commit_transaction" /><variable attributes="__instancevar__" citdl="function" doc="Abort the transaction currently in progress, discarding the pending&#xA;modifications made to the database.&#xA;&#xA;void Xapian::WritableDatabase::cancel_transaction()&#xA;&#xA;If an error occurs in this method, an exception will be thrown, but&#xA;the transaction will be cancelled anyway.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;modifying the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state.&#xA;&#xA;Xapian::InvalidOperationError:  will be thrown if a transaction is not&#xA;currently in progress.&#xA;&#xA;Xapian::UnimplementedError:  will be thrown if transactions are not&#xA;available for this database type. " line="4450" name="cancel_transaction" /><variable attributes="__instancevar__" citdl="function" doc="Add a new document to the database.&#xA;&#xA;Xapian::docid Xapian::WritableDatabase::add_document(const&#xA;Xapian::Document &amp;document)&#xA;&#xA;This method adds the specified document to the database, returning a&#xA;newly allocated document ID. Automatically allocated document IDs come&#xA;from a per-database monotonically increasing counter, so IDs from&#xA;deleted documents won&apos;t be reused.&#xA;&#xA;If you want to specify the document ID to be used, you should call&#xA;replace_document() instead.&#xA;&#xA;Note that changes to the database won&apos;t be immediately committed to&#xA;disk; see commit() for more details.&#xA;&#xA;As with all database modification operations, the effect is atomic:&#xA;the document will either be fully added, or the document fails to be&#xA;added and an exception is thrown (possibly at a later time when&#xA;commit() is called or the database is closed).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;document:  The new document to be added.&#xA;&#xA;The document ID of the newly added document.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;writing to the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state. " line="4477" name="add_document" /><variable attributes="__instancevar__" citdl="function" doc="Delete any documents indexed by a term from the database.&#xA;&#xA;void Xapian::WritableDatabase::delete_document(const std::string&#xA;&amp;unique_term)&#xA;&#xA;This method removes any documents indexed by the specified term from&#xA;the database.&#xA;&#xA;A major use is for convenience when UIDs from another system are&#xA;mapped to terms in Xapian, although this method has other uses (for&#xA;example, you could add a &quot;deletion date&quot; term to documents at index&#xA;time and use this method to delete all documents due for deletion on a&#xA;particular date).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;unique_term:  The term to remove references to.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;writing to the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state. " line="4518" name="delete_document" /><variable attributes="__instancevar__" citdl="function" doc="Replace any documents matching a term.&#xA;&#xA;Xapian::docid Xapian::WritableDatabase::replace_document(const&#xA;std::string &amp;unique_term, const Xapian::Document &amp;document)&#xA;&#xA;This method replaces any documents indexed by the specified term with&#xA;the specified document. If any documents are indexed by the term, the&#xA;lowest document ID will be used for the document, otherwise a new&#xA;document ID will be generated as for add_document.&#xA;&#xA;One common use is to allow UIDs from another system to easily be&#xA;mapped to terms in Xapian. Note that this method doesn&apos;t automatically&#xA;add unique_term as a term, so you&apos;ll need to call&#xA;document.add_term(unique_term) first when using replace_document() in&#xA;this way.&#xA;&#xA;Note that changes to the database won&apos;t be immediately committed to&#xA;disk; see commit() for more details.&#xA;&#xA;As with all database modification operations, the effect is atomic:&#xA;the document(s) will either be fully replaced, or the document(s) fail&#xA;to be replaced and an exception is thrown (possibly at a later time&#xA;when commit() is called or the database is closed).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;unique_term:  The &quot;unique&quot; term.&#xA;&#xA;document:  The new document.&#xA;&#xA;The document ID that document was given.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;writing to the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state. " line="4550" name="replace_document" /><variable attributes="__instancevar__" citdl="function" doc="Add a word to the spelling dictionary.&#xA;&#xA;void Xapian::WritableDatabase::add_spelling(const std::string &amp;word,&#xA;Xapian::termcount freqinc=1) const&#xA;&#xA;If the word is already present, its frequency is increased.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;word:  The word to add.&#xA;&#xA;freqinc:  How much to increase its frequency by (default 1). " line="4596" name="add_spelling" /><variable attributes="__instancevar__" citdl="function" doc="Remove a word from the spelling dictionary.&#xA;&#xA;void Xapian::WritableDatabase::remove_spelling(const std::string&#xA;&amp;word, Xapian::termcount freqdec=1) const&#xA;&#xA;The word&apos;s frequency is decreased, and if would become zero or less&#xA;then the word is removed completely.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;word:  The word to remove.&#xA;&#xA;freqdec:  How much to decrease its frequency by (default 1). " line="4614" name="remove_spelling" /><variable attributes="__instancevar__" citdl="function" doc="Add a synonym for a term.&#xA;&#xA;void Xapian::WritableDatabase::add_synonym(const std::string &amp;term,&#xA;const std::string &amp;synonym) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;term:  The term to add a synonym for.&#xA;&#xA;synonym:  The synonym to add. If this is already a synonym for term,&#xA;then no action is taken. " line="4633" name="add_synonym" /><variable attributes="__instancevar__" citdl="function" doc="Remove a synonym for a term.&#xA;&#xA;void Xapian::WritableDatabase::remove_synonym(const std::string &amp;term,&#xA;const std::string &amp;synonym) const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;term:  The term to remove a synonym for.&#xA;&#xA;synonym:  The synonym to remove. If this isn&apos;t currently a synonym for&#xA;term, then no action is taken. " line="4650" name="remove_synonym" /><variable attributes="__instancevar__" citdl="function" doc="Remove all synonyms for a term.&#xA;&#xA;void Xapian::WritableDatabase::clear_synonyms(const std::string &amp;term)&#xA;const&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;term:  The term to remove all synonyms for. If the term has no&#xA;synonyms, no action is taken. " line="4667" name="clear_synonyms" /><variable attributes="__instancevar__" citdl="function" doc="Set the user-specified metadata associated with a given key.&#xA;&#xA;void Xapian::WritableDatabase::set_metadata(const std::string &amp;key,&#xA;const std::string &amp;value)&#xA;&#xA;This method sets the metadata value associated with a given key. If&#xA;there is already a metadata value stored in the database with the same&#xA;key, the old value is replaced. If you want to delete an existing item&#xA;of metadata, just set its value to the empty string.&#xA;&#xA;User-specified metadata allows you to store arbitrary information in&#xA;the form of (key,tag) pairs.&#xA;&#xA;There&apos;s no hard limit on the number of metadata items, or the size of&#xA;the metadata values. Metadata keys have a limited length, which&#xA;depends on the backend. We recommend limiting them to 200 bytes. Empty&#xA;keys are not valid, and specifying one will cause an exception.&#xA;&#xA;Metadata modifications are committed to disk in the same way as&#xA;modifications to the documents in the database are: i.e.,&#xA;modifications are atomic, and won&apos;t be committed to disk immediately&#xA;(see commit() for more details). This allows metadata to be used to&#xA;link databases with versioned external resources by storing the&#xA;appropriate version number in a metadata item.&#xA;&#xA;You can also use the metadata to store arbitrary extra information&#xA;associated with terms, documents, or postings by encoding the termname&#xA;and/or document id into the metadata key.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;key:  The key of the metadata item to set.&#xA;&#xA;value:  The value of the metadata item to set.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;Xapian::DatabaseError:  will be thrown if a problem occurs while&#xA;writing to the database.&#xA;&#xA;Xapian::DatabaseCorruptError:  will be thrown if the database is in a&#xA;corrupt state.&#xA;&#xA;Xapian::InvalidArgumentError:  will be thrown if the key supplied is&#xA;empty.&#xA;&#xA;Xapian::UnimplementedError:  will be thrown if the database backend in&#xA;use doesn&apos;t support user- specified metadata. " line="4682" name="set_metadata" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::WritableDatabase::get_description() const " line="4737" name="__str__" /></scope><variable citdl="_xapian.WritableDatabase_swigregister" line="4760" name="WritableDatabase_swigregister" /><variable citdl="_xapian.DB_CREATE_OR_OPEN" line="4763" name="DB_CREATE_OR_OPEN" /><variable citdl="_xapian.DB_CREATE" line="4764" name="DB_CREATE" /><variable citdl="_xapian.DB_CREATE_OR_OVERWRITE" line="4765" name="DB_CREATE_OR_OVERWRITE" /><variable citdl="_xapian.DB_OPEN" line="4766" name="DB_OPEN" /><scope doc="Construct a WritableDatabase object for a stub database file.&#xA;&#xA;WritableDatabase Xapian::Auto::open_stub(const std::string &amp;file, int&#xA;action)&#xA;&#xA;The stub database file must contain serialised parameters for exactly&#xA;one database.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;file:  pathname of the stub database file.&#xA;&#xA;action:  determines handling of existing/non-existing database:&#xA;Xapian::DB_CREATE fail if database already exist, otherwise create new&#xA;database.&#xA;&#xA;Xapian::DB_CREATE_OR_OPEN open existing database, or create new&#xA;database if none exists.&#xA;&#xA;Xapian::DB_CREATE_OR_OVERWRITE overwrite existing database, or create&#xA;new database if none exists.&#xA;&#xA;Xapian::DB_OPEN open existing database, failing if none exists. " ilk="function" line="4768" lineend="4795" name="open_stub" returns="_xapian.open_stub()" signature="open_stub(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope doc="Construct a Database object for update access to a Brass database.&#xA;&#xA;WritableDatabase Xapian::Brass::open(const std::string &amp;dir, int&#xA;action, int block_size=8192)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;dir:  pathname of the directory containing the database.&#xA;&#xA;action:  determines handling of existing/non-existing database:&#xA;Xapian::DB_CREATE fail if database already exist, otherwise create new&#xA;database.&#xA;&#xA;Xapian::DB_CREATE_OR_OPEN open existing database, or create new&#xA;database if none exists.&#xA;&#xA;Xapian::DB_CREATE_OR_OVERWRITE overwrite existing database, or create&#xA;new database if none exists.&#xA;&#xA;Xapian::DB_OPEN open existing database, failing if none exists.&#xA;&#xA;block_size:  the Btree blocksize to use (in bytes), which must be a&#xA;power of two between 2048 and 65536 (inclusive). The default (also&#xA;used if an invalid value if passed) is 8192 bytes. This parameter is&#xA;ignored when opening an existing database. " ilk="function" line="4797" lineend="4826" name="brass_open" returns="_xapian.brass_open()" signature="brass_open(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope doc="Construct a Database object for update access to a Chert database.&#xA;&#xA;WritableDatabase Xapian::Chert::open(const std::string &amp;dir, int&#xA;action, int block_size=8192)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;dir:  pathname of the directory containing the database.&#xA;&#xA;action:  determines handling of existing/non-existing database:&#xA;Xapian::DB_CREATE fail if database already exist, otherwise create new&#xA;database.&#xA;&#xA;Xapian::DB_CREATE_OR_OPEN open existing database, or create new&#xA;database if none exists.&#xA;&#xA;Xapian::DB_CREATE_OR_OVERWRITE overwrite existing database, or create&#xA;new database if none exists.&#xA;&#xA;Xapian::DB_OPEN open existing database, failing if none exists.&#xA;&#xA;block_size:  the Btree blocksize to use (in bytes), which must be a&#xA;power of two between 2048 and 65536 (inclusive). The default (also&#xA;used if an invalid value if passed) is 8192 bytes. This parameter is&#xA;ignored when opening an existing database. " ilk="function" line="4828" lineend="4857" name="chert_open" returns="_xapian.chert_open()" signature="chert_open(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope doc="Construct a Database object for update access to a Flint database.&#xA;&#xA;WritableDatabase Xapian::Flint::open(const std::string &amp;dir, int&#xA;action, int block_size=8192)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;dir:  pathname of the directory containing the database.&#xA;&#xA;action:  determines handling of existing/non-existing database:&#xA;Xapian::DB_CREATE fail if database already exist, otherwise create new&#xA;database.&#xA;&#xA;Xapian::DB_CREATE_OR_OPEN open existing database, or create new&#xA;database if none exists.&#xA;&#xA;Xapian::DB_CREATE_OR_OVERWRITE overwrite existing database, or create&#xA;new database if none exists.&#xA;&#xA;Xapian::DB_OPEN open existing database, failing if none exists.&#xA;&#xA;block_size:  the Btree blocksize to use (in bytes), which must be a&#xA;power of two between 2048 and 65536 (inclusive). The default (also&#xA;used if an invalid value if passed) is 8192 bytes. This parameter is&#xA;ignored when opening an existing database. " ilk="function" line="4859" lineend="4888" name="flint_open" returns="_xapian.flint_open()" signature="flint_open(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope doc="Construct a WritableDatabase object for a new, empty InMemory&#xA;database.&#xA;&#xA;WritableDatabase Xapian::InMemory::open()&#xA;&#xA;Only a writable InMemory database can be created, since a read-only&#xA;one would always remain empty. " ilk="function" line="4890" lineend="4900" name="inmemory_open" returns="_xapian.inmemory_open()" signature="inmemory_open()" /><scope doc="Construct a Database object for read-only access to a remote database&#xA;accessed via a program.&#xA;&#xA;Database Xapian::Remote::open(const std::string &amp;program, const&#xA;std::string &amp;args, Xapian::timeout timeout=10000)&#xA;&#xA;Access to the remote database is done by running an external program&#xA;and communicating with it on stdin/stdout.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;program:  the external program to run.&#xA;&#xA;args:  space-separated list of arguments to pass to program.&#xA;&#xA;timeout:  timeout in milliseconds. If this timeout is exceeded for any&#xA;individual operation on the remote database then&#xA;Xapian::NetworkTimeoutError is thrown. A timeout of 0 means don&apos;t&#xA;timeout. (Default is 10000ms, which is 10 seconds). " ilk="function" line="4902" lineend="4925" name="remote_open" returns="_xapian.remote_open()" signature="remote_open(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope doc="Construct a WritableDatabase object for update access to a remote&#xA;database accessed via a program.&#xA;&#xA;WritableDatabase Xapian::Remote::open_writable(const std::string&#xA;&amp;program, const std::string &amp;args, Xapian::timeout timeout=0)&#xA;&#xA;Access to the remote database is done by running an external program&#xA;and communicating with it on stdin/stdout.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;program:  the external program to run.&#xA;&#xA;args:  space-separated list of arguments to pass to program.&#xA;&#xA;timeout:  timeout in milliseconds. If this timeout is exceeded for any&#xA;individual operation on the remote database then&#xA;Xapian::NetworkTimeoutError is thrown. (Default is 0, which means&#xA;don&apos;t timeout). " ilk="function" line="4927" lineend="4950" name="remote_open_writable" returns="_xapian.remote_open_writable()" signature="remote_open_writable(*args)"><variable attributes="varargs" ilk="argument" name="args" /></scope><scope classrefs="object" doc="Class representing a query.&#xA;&#xA;Queries are represented as a tree of objects. " ilk="class" line="4951" lineend="5055" name="Query"><variable citdl="_swig_property()" line="4957" name="thisown" /><variable citdl="_swig_repr" line="4958" name="__repr__" /><variable citdl="_xapian.Query_OP_AND" line="4959" name="OP_AND" /><variable citdl="_xapian.Query_OP_OR" line="4960" name="OP_OR" /><variable citdl="_xapian.Query_OP_AND_NOT" line="4961" name="OP_AND_NOT" /><variable citdl="_xapian.Query_OP_XOR" line="4962" name="OP_XOR" /><variable citdl="_xapian.Query_OP_AND_MAYBE" line="4963" name="OP_AND_MAYBE" /><variable citdl="_xapian.Query_OP_FILTER" line="4964" name="OP_FILTER" /><variable citdl="_xapian.Query_OP_NEAR" line="4965" name="OP_NEAR" /><variable citdl="_xapian.Query_OP_PHRASE" line="4966" name="OP_PHRASE" /><variable citdl="_xapian.Query_OP_VALUE_RANGE" line="4967" name="OP_VALUE_RANGE" /><variable citdl="_xapian.Query_OP_SCALE_WEIGHT" line="4968" name="OP_SCALE_WEIGHT" /><variable citdl="_xapian.Query_OP_ELITE_SET" line="4969" name="OP_ELITE_SET" /><variable citdl="_xapian.Query_OP_VALUE_GE" line="4970" name="OP_VALUE_GE" /><variable citdl="_xapian.Query_OP_VALUE_LE" line="4971" name="OP_VALUE_LE" /><variable citdl="_xapian.Query_OP_SYNONYM" line="4972" name="OP_SYNONYM" /><variable citdl="_xapian.delete_Query" line="4973" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Get the length of the query, used by some ranking formulae.&#xA;&#xA;Xapian::termcount Xapian::Query::get_length() const&#xA;&#xA;This value is calculated automatically - if you want to override it&#xA;you can pass a different value to Enquire::set_query(). " line="4974" name="get_length" /><variable attributes="__instancevar__" citdl="function" doc="Return a Xapian::TermIterator returning all the terms in the query, in&#xA;order of termpos.&#xA;&#xA;TermIterator Xapian::Query::get_terms_begin() const&#xA;&#xA;If multiple terms have the same term position, their order is&#xA;unspecified. Duplicates (same term and termpos) will be removed. " line="4985" name="get_terms_begin" /><variable attributes="__instancevar__" citdl="function" doc="Return a Xapian::TermIterator to the end of the list of terms in the&#xA;query.&#xA;&#xA;TermIterator Xapian::Query::get_terms_end() const " line="4997" name="get_terms_end" /><variable attributes="__instancevar__" citdl="function" doc="Test if the query is empty (i.e.&#xA;&#xA;bool Xapian::Query::empty() const&#xA;&#xA;was constructed using the default ctor or with an empty iterator&#xA;ctor). " line="5006" name="empty" /><variable attributes="__instancevar__" citdl="function" doc="Serialise query into a string.&#xA;&#xA;std::string Xapian::Query::serialise() const&#xA;&#xA;The query representation may change between Xapian releases: even&#xA;between minor versions. However, it is guaranteed not to change unless&#xA;the remote database protocol has also changed between releases. " line="5017" name="serialise" /><variable citdl="staticmethod()" line="5029" name="unserialise" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::Query::get_description() const " line="5030" name="__str__" /><variable attributes="__ctor__ __instancevar__" citdl="function" doc="Construct an external source query.&#xA;&#xA;Xapian::Query::Query(Xapian::PostingSource *external_source)&#xA;&#xA;An attempt to clone the posting source will be made immediately, so if&#xA;the posting source supports clone(), the source supplied may be safely&#xA;deallocated after this call. If the source does not support clone(),&#xA;the caller must ensure that the posting source remains valid until the&#xA;Query is deallocated.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;external_source:  The source to use in the query. " line="5038" name="__init__" /><variable attributes="__instancevar__" citdl="_query_gen_iter" line="6747" name="__iter__" /><variable attributes="__instancevar__" citdl="" line="7511" name="MatchAll" /><variable attributes="__instancevar__" citdl="" line="7512" name="MatchNothing" /></scope><variable citdl="_xapian.Query_swigregister" line="5062" name="Query_swigregister" /><variable citdl="function" line="5065" name="Query_unserialise" /><scope classrefs="object" doc="Base class for stop-word decision functor. " ilk="class" line="5069" lineend="5093" name="Stopper"><variable citdl="_swig_property()" line="5073" name="thisown" /><variable citdl="_swig_repr" line="5074" name="__repr__" /><variable citdl="_xapian.delete_Stopper" line="5075" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;virtual std::string Xapian::Stopper::get_description() const " line="5076" name="__str__" /><scope attributes="__ctor__" ilk="function" line="5084" lineend="5089" name="__init__" signature="Stopper()"><variable citdl="Stopper" ilk="argument" name="self" /><variable attributes="protected" citdl="Stopper" line="5086" name="_self" /></scope><scope ilk="function" line="5090" lineend="5093" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="Stopper" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="5094" name="__call__" /></scope><variable citdl="_xapian.Stopper_swigregister" line="5096" name="Stopper_swigregister" /><scope classrefs="Stopper" doc="Simple implementation of Stopper class - this will suit most users. " ilk="class" line="5099" lineend="5120" name="SimpleStopper"><variable citdl="_swig_property()" line="5103" name="thisown" /><variable citdl="_swig_repr" line="5104" name="__repr__" /><scope attributes="__ctor__" doc="Initialise from a pair of iterators.&#xA;&#xA;Xapian::SimpleStopper::SimpleStopper(Iterator begin, Iterator end) " ilk="function" line="5105" lineend="5111" name="__init__" signature="SimpleStopper()"><variable citdl="SimpleStopper" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="function" doc="Add a single stop word.&#xA;&#xA;void Xapian::SimpleStopper::add(const std::string &amp;word) " line="5112" name="add" /><variable citdl="_xapian.delete_SimpleStopper" line="5120" name="__swig_destroy__" /></scope><variable citdl="_xapian.SimpleStopper_swigregister" line="5122" name="SimpleStopper_swigregister" /><scope classrefs="object" doc="Base class for value range processors. " ilk="class" line="5125" lineend="5141" name="ValueRangeProcessor"><variable citdl="_swig_property()" line="5129" name="thisown" /><variable citdl="_swig_repr" line="5130" name="__repr__" /><variable citdl="_xapian.delete_ValueRangeProcessor" line="5131" name="__swig_destroy__" /><scope attributes="__ctor__" ilk="function" line="5132" lineend="5137" name="__init__" signature="ValueRangeProcessor()"><variable citdl="ValueRangeProcessor" ilk="argument" name="self" /><variable attributes="protected" citdl="ValueRangeProcessor" line="5134" name="_self" /></scope><scope ilk="function" line="5138" lineend="5141" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="ValueRangeProcessor" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="5142" name="__call__" /></scope><variable citdl="_xapian.ValueRangeProcessor_swigregister" line="5143" name="ValueRangeProcessor_swigregister" /><scope classrefs="ValueRangeProcessor" doc="Handle a string range.&#xA;&#xA;The end points can be any strings. " ilk="class" line="5146" lineend="5173" name="StringValueRangeProcessor"><variable citdl="_swig_property()" line="5152" name="thisown" /><variable citdl="_swig_repr" line="5153" name="__repr__" /><scope attributes="__ctor__" doc="Constructor.&#xA;&#xA;Xapian::StringValueRangeProcessor::StringValueRangeProcessor(Xapian::valueno&#xA;slot_, const std::string &amp;str_, bool prefix_=true)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value number to return from operator().&#xA;&#xA;str_:  A string to look for to recognise values as belonging to this&#xA;range.&#xA;&#xA;prefix_:  Flag specifying whether to check for str_ as a prefix or a&#xA;suffix. " ilk="function" line="5154" lineend="5172" name="__init__" signature="StringValueRangeProcessor(*args)"><variable citdl="StringValueRangeProcessor" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_StringValueRangeProcessor" line="5173" name="__swig_destroy__" /></scope><variable citdl="_xapian.StringValueRangeProcessor_swigregister" line="5174" name="StringValueRangeProcessor_swigregister" /><scope classrefs="StringValueRangeProcessor" doc="Handle a date range.&#xA;&#xA;Begin and end must be dates in a recognised format. " ilk="class" line="5177" lineend="5230" name="DateValueRangeProcessor"><variable citdl="_swig_property()" line="5183" name="thisown" /><variable citdl="_swig_repr" line="5184" name="__repr__" /><scope attributes="__ctor__" doc="Constructor.&#xA;&#xA;Xapian::DateValueRangeProcessor::DateValueRangeProcessor(Xapian::valueno&#xA;slot_, const std::string &amp;str_, bool prefix_=true, bool&#xA;prefer_mdy_=false, int epoch_year_=1970)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value number to return from operator().&#xA;&#xA;str_:  A string to look for to recognise values as belonging to this&#xA;date range.&#xA;&#xA;prefix_:  Whether to look for the string at the start or end of the&#xA;values. If true, the string is a prefix; if false, the string is a&#xA;suffix (default: true).&#xA;&#xA;prefer_mdy_:  Should ambiguous dates be interpreted as month/day/year&#xA;rather than day/month/year? (default: false)&#xA;&#xA;epoch_year_:  Year to use as the epoch for dates with 2 digit years&#xA;(default: 1970, so 1/1/69 is 2069 while 1/1/70 is 1970).&#xA;&#xA;The string supplied in str_ is used by operator() to decide whether&#xA;the pair of strings supplied to it constitute a valid range. If&#xA;prefix_ is true, the first value in a range must begin with str_ (and&#xA;the second value may optionally begin with str_); if prefix_ is false,&#xA;the second value in a range must end with str_ (and the first value&#xA;may optionally end with str_).&#xA;&#xA;If str_ is empty, the setting of prefix_ is irrelevant, and no special&#xA;strings are required at the start or end of the strings defining the&#xA;range.&#xA;&#xA;The remainder of both strings defining the endpoints must be valid&#xA;dates.&#xA;&#xA;For example, if str_ is &quot;created:&quot; and prefix_ is true, and the&#xA;range processor has been added to the queryparser, the queryparser&#xA;will accept &quot;created:1/1/2000..31/12/2001&quot;. " ilk="function" line="5185" lineend="5229" name="__init__" signature="DateValueRangeProcessor(*args)"><variable citdl="DateValueRangeProcessor" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_DateValueRangeProcessor" line="5230" name="__swig_destroy__" /></scope><variable citdl="_xapian.DateValueRangeProcessor_swigregister" line="5231" name="DateValueRangeProcessor_swigregister" /><scope classrefs="StringValueRangeProcessor" doc="Handle a number range.&#xA;&#xA;This class must be used on values which have been encoded using&#xA;Xapian::sortable_serialise() which turns numbers into strings which&#xA;will sort in the same order as the numbers (the same values can be&#xA;used to implement a numeric sort). " ilk="class" line="5234" lineend="5286" name="NumberValueRangeProcessor"><variable citdl="_swig_property()" line="5243" name="thisown" /><variable citdl="_swig_repr" line="5244" name="__repr__" /><scope attributes="__ctor__" doc="Constructor.&#xA;&#xA;Xapian::NumberValueRangeProcessor::NumberValueRangeProcessor(Xapian::valueno&#xA;slot_, const std::string &amp;str_, bool prefix_=true)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot_:  The value number to return from operator().&#xA;&#xA;str_:  A string to look for to recognise values as belonging to this&#xA;numeric range.&#xA;&#xA;prefix_:  Whether to look for the string at the start or end of the&#xA;values. If true, the string is a prefix; if false, the string is a&#xA;suffix (default: true).&#xA;&#xA;The string supplied in str_ is used by operator() to decide whether&#xA;the pair of strings supplied to it constitute a valid range. If&#xA;prefix_ is true, the first value in a range must begin with str_ (and&#xA;the second value may optionally begin with str_); if prefix_ is false,&#xA;the second value in a range must end with str_ (and the first value&#xA;may optionally end with str_).&#xA;&#xA;If str_ is empty, the setting of prefix_ is irrelevant, and no special&#xA;strings are required at the start or end of the strings defining the&#xA;range.&#xA;&#xA;The remainder of both strings defining the endpoints must be valid&#xA;floating point numbers. (FIXME: define format recognised).&#xA;&#xA;For example, if str_ is &quot;$&quot; and prefix_ is true, and the range&#xA;processor has been added to the queryparser, the queryparser will&#xA;accept &quot;$10..50&quot; or &quot;$10..$50&quot;, but not &quot;10..50&quot; or &quot;10..$50&quot;&#xA;as valid ranges. If str_ is &quot;kg&quot; and prefix_ is false, the&#xA;queryparser will accept &quot;10..50kg&quot; or &quot;10kg..50kg&quot;, but not&#xA;&quot;10..50&quot; or &quot;10kg..50&quot; as valid ranges. " ilk="function" line="5245" lineend="5285" name="__init__" signature="NumberValueRangeProcessor(*args)"><variable citdl="NumberValueRangeProcessor" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable citdl="_xapian.delete_NumberValueRangeProcessor" line="5286" name="__swig_destroy__" /></scope><variable citdl="_xapian.NumberValueRangeProcessor_swigregister" line="5287" name="NumberValueRangeProcessor_swigregister" /><scope classrefs="object" doc="Build a Xapian::Query object from a user query string. " ilk="class" line="5290" lineend="5602" name="QueryParser"><variable citdl="_swig_property()" line="5294" name="thisown" /><variable citdl="_swig_repr" line="5295" name="__repr__" /><variable citdl="_xapian.QueryParser_FLAG_BOOLEAN" line="5296" name="FLAG_BOOLEAN" /><variable citdl="_xapian.QueryParser_FLAG_PHRASE" line="5297" name="FLAG_PHRASE" /><variable citdl="_xapian.QueryParser_FLAG_LOVEHATE" line="5298" name="FLAG_LOVEHATE" /><variable citdl="_xapian.QueryParser_FLAG_BOOLEAN_ANY_CASE" line="5299" name="FLAG_BOOLEAN_ANY_CASE" /><variable citdl="_xapian.QueryParser_FLAG_WILDCARD" line="5300" name="FLAG_WILDCARD" /><variable citdl="_xapian.QueryParser_FLAG_PURE_NOT" line="5301" name="FLAG_PURE_NOT" /><variable citdl="_xapian.QueryParser_FLAG_PARTIAL" line="5302" name="FLAG_PARTIAL" /><variable citdl="_xapian.QueryParser_FLAG_SPELLING_CORRECTION" line="5303" name="FLAG_SPELLING_CORRECTION" /><variable citdl="_xapian.QueryParser_FLAG_SYNONYM" line="5304" name="FLAG_SYNONYM" /><variable citdl="_xapian.QueryParser_FLAG_AUTO_SYNONYMS" line="5305" name="FLAG_AUTO_SYNONYMS" /><variable citdl="_xapian.QueryParser_FLAG_AUTO_MULTIWORD_SYNONYMS" line="5306" name="FLAG_AUTO_MULTIWORD_SYNONYMS" /><variable citdl="_xapian.QueryParser_FLAG_DEFAULT" line="5307" name="FLAG_DEFAULT" /><variable citdl="_xapian.QueryParser_STEM_NONE" line="5308" name="STEM_NONE" /><variable citdl="_xapian.QueryParser_STEM_SOME" line="5309" name="STEM_SOME" /><variable citdl="_xapian.QueryParser_STEM_ALL" line="5310" name="STEM_ALL" /><variable citdl="_xapian.QueryParser_STEM_ALL_Z" line="5311" name="STEM_ALL_Z" /><scope attributes="__ctor__" doc="Default constructor.&#xA;&#xA;Xapian::QueryParser::QueryParser() " ilk="function" line="5312" lineend="5318" name="__init__" signature="QueryParser()"><variable citdl="QueryParser" ilk="argument" name="self" /></scope><variable citdl="_xapian.delete_QueryParser" line="5319" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Set the stemmer.&#xA;&#xA;void Xapian::QueryParser::set_stemmer(const Xapian::Stem &amp;stemmer)&#xA;&#xA;This sets the stemming algorithm which will be used by the query&#xA;parser. Note that the stemming algorithm will only be used according&#xA;to the stemming strategy set by set_stemming_strategy(), which&#xA;defaults to STEM_NONE. Therefore, to use a stemming algorithm, you&#xA;will also need to call set_stemming_strategy() with a value other than&#xA;STEM_NONE.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;stemmer:  The Xapian::Stem object to set. " line="5320" name="set_stemmer" /><variable attributes="__instancevar__" citdl="function" doc="Set the stemming strategy.&#xA;&#xA;void Xapian::QueryParser::set_stemming_strategy(stem_strategy&#xA;strategy)&#xA;&#xA;This controls how the query parser will apply the stemming algorithm.&#xA;Note that the stemming algorithm is only applied to words in&#xA;probabilistic fields - boolean filter terms are never stemmed.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;strategy:  The strategy to use - possible values are: STEM_NONE: Don&apos;t&#xA;perform any stemming. (default in Xapian &lt;= 1.3.0)&#xA;&#xA;STEM_SOME: Search for stemmed forms of terms except for those which&#xA;start with a capital letter, or are followed by certain characters&#xA;(currently: (/@&lt;&gt;=*[{&quot; ), or are used with operators which need&#xA;positional information. Stemmed terms are prefixed with &apos;Z&apos;. (default&#xA;in Xapian &gt;= 1.3.1)&#xA;&#xA;STEM_ALL: Search for stemmed forms of all words (note: no &apos;Z&apos; prefix&#xA;is added).&#xA;&#xA;STEM_ALL_Z: Search for stemmed forms of all words (note: &apos;Z&apos; prefix is&#xA;added). (new in Xapian 1.2.11 and 1.3.1) " line="5340" name="set_stemming_strategy" /><variable attributes="__instancevar__" citdl="function" doc="Set the stopper.&#xA;&#xA;void Xapian::QueryParser::set_stopper(const Stopper *stop=NULL)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;stop:  The Stopper object to set (default NULL, which means no&#xA;stopwords). " line="5371" name="set_stopper" /><variable attributes="__instancevar__" citdl="function" doc="Set the default operator.&#xA;&#xA;void Xapian::QueryParser::set_default_op(Query::op default_op)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;default_op:  The operator to use to combine non-filter query items&#xA;when no explicit operator is used.&#xA;&#xA;The most useful values for this are OP_OR (the default) and OP_AND.&#xA;OP_NEAR and OP_PHRASE can also be useful.&#xA;&#xA;So for example, &apos;weather forecast&apos; is parsed as if it were &apos;weather OR&#xA;forecast&apos; by default. " line="5385" name="set_default_op" /><variable attributes="__instancevar__" citdl="function" doc="Get the current default operator.&#xA;&#xA;Query::op Xapian::QueryParser::get_default_op() const " line="5405" name="get_default_op" /><variable attributes="__instancevar__" citdl="function" doc="Specify the database being searched.&#xA;&#xA;void Xapian::QueryParser::set_database(const Database &amp;db)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;db:  The database to use for wildcard expansion (FLAG_WILDCARD and&#xA;FLAG_PARTIAL), spelling correction (FLAG_SPELLING_CORRECTION), and&#xA;synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and&#xA;FLAG_AUTO_MULTIWORD_SYNONYMS). " line="5413" name="set_database" /><variable attributes="__instancevar__" citdl="function" doc="Specify the maximum expansion of a wildcard term.&#xA;&#xA;void Xapian::QueryParser::set_max_wildcard_expansion(Xapian::termcount&#xA;limit)&#xA;&#xA;Note: you must also set FLAG_WILDCARD for wildcard expansion to&#xA;happen.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;limit:  The maximum number of terms each wildcard in the query can&#xA;expand to, or 0 for no limit (which is the default). " line="5429" name="set_max_wildcard_expansion" /><variable attributes="__instancevar__" citdl="function" doc="Parse a query.&#xA;&#xA;Query Xapian::QueryParser::parse_query(const std::string&#xA;&amp;query_string, unsigned flags=FLAG_DEFAULT, const std::string&#xA;&amp;default_prefix=std::string())&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;query_string:  A free-text query as entered by a user&#xA;&#xA;flags:  Zero or more Query::feature_flag specifying what features the&#xA;QueryParser should support. Combine multiple values with bitwise-or&#xA;(|) (default FLAG_DEFAULT).&#xA;&#xA;default_prefix:  The default term prefix to use (default none). For&#xA;example, you can pass &quot;A&quot; when parsing an &quot;Author&quot; field.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;If:  the query string can&apos;t be parsed, then Xapian::QueryParserError&#xA;is thrown. You can get an English error message to report to the user&#xA;by catching it and calling get_msg() on the caught exception. The&#xA;current possible values (in case you want to translate them) are:&#xA;&#xA;Unknown range operation&#xA;&#xA;parse error&#xA;&#xA;Syntax: &lt;expression&gt; AND &lt;expression&gt;&#xA;&#xA;Syntax: &lt;expression&gt; AND NOT &lt;expression&gt;&#xA;&#xA;Syntax: &lt;expression&gt; NOT &lt;expression&gt;&#xA;&#xA;Syntax: &lt;expression&gt; OR &lt;expression&gt;&#xA;&#xA;Syntax: &lt;expression&gt; XOR &lt;expression&gt; " line="5447" name="parse_query" /><variable attributes="__instancevar__" citdl="function" doc="Add a probabilistic term prefix.&#xA;&#xA;void Xapian::QueryParser::add_prefix(const std::string &amp;field, const&#xA;std::string &amp;prefix)&#xA;&#xA;For example:&#xA;&#xA;This allows the user to search for author:Orwell which will be&#xA;converted to a search for the term &quot;Aorwell&quot;.&#xA;&#xA;Multiple fields can be mapped to the same prefix. For example, you can&#xA;make title: and subject: aliases for each other.&#xA;&#xA;As of 1.0.4, you can call this method multiple times with the same&#xA;value of field to allow a single field to be mapped to multiple&#xA;prefixes. Multiple terms being generated for such a field, and&#xA;combined with  Xapian::Query::OP_OR.&#xA;&#xA;If any prefixes are specified for the empty field name (i.e. you call&#xA;this method with an empty string as the first parameter) these&#xA;prefixes will be used for terms without a field specifier. If you do&#xA;this and also specify the default_prefix parameter to  parse_query(),&#xA;then the default_prefix parameter will override.&#xA;&#xA;If the prefix parameter is empty, then &quot;field:word&quot; will produce the&#xA;term &quot;word&quot; (and this can be one of several prefixes for a&#xA;particular field, or for terms without a field specifier).&#xA;&#xA;If you call  add_prefix() and  add_boolean_prefix() for the same value&#xA;of field, a  Xapian::InvalidOperationError exception will be thrown.&#xA;&#xA;In 1.0.3 and earlier, subsequent calls to this method with the same&#xA;value of field had no effect.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;field:  The user visible field name&#xA;&#xA;prefix:  The term prefix to map this to " line="5491" name="add_prefix" /><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::QueryParser::add_boolean_prefix(const std::string &amp;field,&#xA;const std::string &amp;prefix) " line="5536" name="add_boolean_prefix" /><variable attributes="__instancevar__" citdl="function" doc="Iterate over terms omitted from the query as stopwords.&#xA;&#xA;TermIterator Xapian::QueryParser::stoplist_begin() const " line="5544" name="stoplist_begin" /><variable attributes="__instancevar__" citdl="function" doc="TermIterator Xapian::QueryParser::stoplist_end() const " line="5552" name="stoplist_end" /><variable attributes="__instancevar__" citdl="function" doc="Iterate over unstemmed forms of the given (stemmed) term used in the&#xA;query.&#xA;&#xA;TermIterator Xapian::QueryParser::unstem_begin(const std::string&#xA;&amp;term) const " line="5556" name="unstem_begin" /><variable attributes="__instancevar__" citdl="function" doc="TermIterator&#xA;Xapian::QueryParser::unstem_end(const std::string &amp;) const " line="5566" name="unstem_end" /><variable attributes="__instancevar__" citdl="function" doc="Register a ValueRangeProcessor.&#xA;&#xA;void&#xA;Xapian::QueryParser::add_valuerangeprocessor(Xapian::ValueRangeProcessor&#xA;*vrproc) " line="5573" name="add_valuerangeprocessor" /><variable attributes="__instancevar__" citdl="function" doc="Get the spelling-corrected query string.&#xA;&#xA;std::string Xapian::QueryParser::get_corrected_query_string() const&#xA;&#xA;This will only be set if FLAG_SPELLING_CORRECTION is specified when&#xA;QueryParser::parse_query() was last called.&#xA;&#xA;If there were no corrections, an empty string is returned. " line="5583" name="get_corrected_query_string" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::QueryParser::get_description() const " line="5596" name="__str__" /><variable attributes="__instancevar__" citdl="_queryparser_gen_stoplist_iter" line="6891" name="stoplist" /><variable attributes="__instancevar__" citdl="_queryparser_gen_unstemlist_iter" line="6908" name="unstemlist" /></scope><variable citdl="_xapian.QueryParser_swigregister" line="5621" name="QueryParser_swigregister" /><variable citdl="function" line="5625" name="sortable_serialise" /><variable citdl="function" line="5629" name="sortable_unserialise" /><scope classrefs="object" doc="Class representing a stemming algorithm implementation. " ilk="class" line="5632" lineend="5657" name="StemImplementation"><variable citdl="_swig_property()" line="5636" name="thisown" /><variable citdl="_swig_repr" line="5637" name="__repr__" /><variable citdl="_xapian.delete_StemImplementation" line="5638" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;virtual std::string Xapian::StemImplementation::get_description()&#xA;const =0 " line="5639" name="__str__" /><scope attributes="__ctor__" ilk="function" line="5648" lineend="5653" name="__init__" signature="StemImplementation()"><variable citdl="StemImplementation" ilk="argument" name="self" /><variable attributes="protected" citdl="StemImplementation" line="5650" name="_self" /></scope><scope ilk="function" line="5654" lineend="5657" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="StemImplementation" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="5658" name="__call__" /></scope><variable citdl="_xapian.StemImplementation_swigregister" line="5660" name="StemImplementation_swigregister" /><scope classrefs="object" doc="Class representing a stemming algorithm. " ilk="class" line="5663" lineend="5698" name="Stem"><variable citdl="_swig_property()" line="5667" name="thisown" /><variable citdl="_swig_repr" line="5668" name="__repr__" /><variable attributes="__ctor__ __instancevar__" citdl="function" doc="Construct a Xapian::Stem object with a user-provided stemming&#xA;algorithm.&#xA;&#xA;Xapian::Stem::Stem(StemImplementation *p)&#xA;&#xA;You can subclass Xapian::StemImplementation to implement your own&#xA;stemming algorithm (or to wrap a third-party algorithm) and then wrap&#xA;your implementation in a Xapian::Stem object to pass to the Xapian&#xA;API.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;p:  The user-subclassed StemImplementation object. This is reference&#xA;counted, and so will be automatically deleted by the Xapian::Stem&#xA;wrapper when no longer required. " line="5669" name="__init__" /><variable citdl="_xapian.delete_Stem" line="5689" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::Stem::get_description() const " line="5690" name="__str__" /><variable citdl="staticmethod()" line="5698" name="get_available_languages" /><variable attributes="__instancevar__" citdl="new_instancemethod()" line="5699" name="__call__" /></scope><variable citdl="_xapian.Stem_swigregister" line="5701" name="Stem_swigregister" /><variable citdl="function" line="5704" name="Stem_get_available_languages" /><scope classrefs="object" doc="Parses a piece of text and generate terms.&#xA;&#xA;This module takes a piece of text and parses it to produce words which&#xA;are then used to generate suitable terms for indexing. The terms&#xA;generated are suitable for use with Query objects produced by the&#xA;QueryParser class. " ilk="class" line="5708" lineend="5919" name="TermGenerator"><variable citdl="_swig_property()" line="5717" name="thisown" /><variable citdl="_swig_repr" line="5718" name="__repr__" /><scope attributes="__ctor__" doc="Default constructor.&#xA;&#xA;Xapian::TermGenerator::TermGenerator() " ilk="function" line="5719" lineend="5725" name="__init__" signature="TermGenerator()"><variable citdl="TermGenerator" ilk="argument" name="self" /></scope><variable citdl="_xapian.delete_TermGenerator" line="5726" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Set the Xapian::Stem object to be used for generating stemmed terms.&#xA;&#xA;void Xapian::TermGenerator::set_stemmer(const Xapian::Stem &amp;stemmer)&#xA;" line="5727" name="set_stemmer" /><variable attributes="__instancevar__" citdl="function" doc="Set the Xapian::Stopper object to be used for identifying stopwords.&#xA;&#xA;void Xapian::TermGenerator::set_stopper(const Xapian::Stopper&#xA;*stop=NULL)&#xA;&#xA;Stemmed forms of stopwords aren&apos;t indexed, but unstemmed forms still&#xA;are so that searches for phrases including stop words still work.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;stop:  The Stopper object to set (default NULL, which means no&#xA;stopwords). " line="5736" name="set_stopper" /><variable attributes="__instancevar__" citdl="function" doc="Set the current document.&#xA;&#xA;void Xapian::TermGenerator::set_document(const Xapian::Document &amp;doc)&#xA;" line="5754" name="set_document" /><variable attributes="__instancevar__" citdl="function" doc="Get the current document.&#xA;&#xA;const Xapian::Document&amp; Xapian::TermGenerator::get_document() const " line="5763" name="get_document" /><variable attributes="__instancevar__" citdl="function" doc="Set the database to index spelling data to.&#xA;&#xA;void Xapian::TermGenerator::set_database(const&#xA;Xapian::WritableDatabase &amp;db) " line="5771" name="set_database" /><variable citdl="_xapian.TermGenerator_FLAG_SPELLING" line="5780" name="FLAG_SPELLING" /><variable citdl="_xapian.TermGenerator_STEM_NONE" line="5781" name="STEM_NONE" /><variable citdl="_xapian.TermGenerator_STEM_SOME" line="5782" name="STEM_SOME" /><variable citdl="_xapian.TermGenerator_STEM_ALL" line="5783" name="STEM_ALL" /><variable citdl="_xapian.TermGenerator_STEM_ALL_Z" line="5784" name="STEM_ALL_Z" /><variable attributes="__instancevar__" citdl="function" doc="Set flags.&#xA;&#xA;flags Xapian::TermGenerator::set_flags(flags toggle, flags&#xA;mask=flags(0))&#xA;&#xA;The new value of flags is: (flags &amp; mask) ^ toggle&#xA;&#xA;To just set the flags, pass the new flags in toggle and the default&#xA;value for mask.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;toggle:  Flags to XOR.&#xA;&#xA;mask:  Flags to AND with first.&#xA;&#xA;The old flags setting. " line="5785" name="set_flags" /><variable attributes="__instancevar__" citdl="function" doc="Set the stemming strategy.&#xA;&#xA;void Xapian::TermGenerator::set_stemming_strategy(stem_strategy&#xA;strategy)&#xA;&#xA;This method controls how the stemming algorithm is applied. It was new&#xA;in Xapian 1.3.1.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;strategy:  The strategy to use - possible values are: STEM_NONE: Don&apos;t&#xA;perform any stemming - only unstemmed terms are generated.&#xA;&#xA;STEM_SOME: Generate both stemmed (with a &quot;Z&quot; prefix) and unstemmed&#xA;terms. This is the default strategy.&#xA;&#xA;STEM_ALL: Generate only stemmed terms (but without a &quot;Z&quot; prefix).&#xA;&#xA;STEM_ALL_Z: Generate only stemmed terms (with a &quot;Z&quot; prefix). " line="5808" name="set_stemming_strategy" /><variable attributes="__instancevar__" citdl="function" doc="Index some text in a std::string.&#xA;&#xA;void Xapian::TermGenerator::index_text(const std::string &amp;text,&#xA;Xapian::termcount wdf_inc=1, const std::string &amp;prefix=std::string())&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;text:  The text to index.&#xA;&#xA;wdf_inc:  The wdf increment (default 1).&#xA;&#xA;prefix:  The term prefix to use (default is no prefix). " line="5833" name="index_text" /><variable attributes="__instancevar__" citdl="function" doc="Index some text in a std::string without positional information.&#xA;&#xA;void Xapian::TermGenerator::index_text_without_positions(const&#xA;std::string &amp;text, Xapian::termcount wdf_inc=1, const std::string&#xA;&amp;prefix=std::string())&#xA;&#xA;Just like index_text, but no positional information is generated. This&#xA;means that the database will be significantly smaller, but that phrase&#xA;searching and NEAR won&apos;t be supported.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;text:  The text to index.&#xA;&#xA;wdf_inc:  The wdf increment (default 1).&#xA;&#xA;prefix:  The term prefix to use (default is no prefix). " line="5851" name="index_text_without_positions" /><variable attributes="__instancevar__" citdl="function" doc="Increase the term position used by index_text.&#xA;&#xA;void Xapian::TermGenerator::increase_termpos(Xapian::termcount&#xA;delta=100)&#xA;&#xA;This can be used between indexing text from different fields or other&#xA;places to prevent phrase searches from spanning between them (e.g.&#xA;between the title and body text, or between two chapters in a book).&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;delta:  Amount to increase the term position by (default: 100). " line="5874" name="increase_termpos" /><variable attributes="__instancevar__" citdl="function" doc="Get the current term position.&#xA;&#xA;Xapian::termcount Xapian::TermGenerator::get_termpos() const " line="5892" name="get_termpos" /><variable attributes="__instancevar__" citdl="function" doc="Set the current term position.&#xA;&#xA;void Xapian::TermGenerator::set_termpos(Xapian::termcount termpos)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;termpos:  The new term position to set. " line="5900" name="set_termpos" /><variable attributes="__instancevar__" citdl="function" doc="Return a string describing this object.&#xA;&#xA;std::string Xapian::TermGenerator::get_description() const " line="5913" name="__str__" /></scope><variable citdl="_xapian.TermGenerator_swigregister" line="5934" name="TermGenerator_swigregister" /><scope classrefs="object" doc="Virtual base class for key making functors. " ilk="class" line="5937" lineend="5953" name="KeyMaker"><variable citdl="_swig_property()" line="5941" name="thisown" /><variable citdl="_swig_repr" line="5942" name="__repr__" /><variable citdl="_xapian.delete_KeyMaker" line="5943" name="__swig_destroy__" /><scope attributes="__ctor__" ilk="function" line="5944" lineend="5949" name="__init__" signature="KeyMaker()"><variable citdl="KeyMaker" ilk="argument" name="self" /><variable attributes="protected" citdl="KeyMaker" line="5946" name="_self" /></scope><scope ilk="function" line="5950" lineend="5953" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="KeyMaker" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="new_instancemethod()" line="5954" name="__call__" /></scope><variable citdl="_xapian.KeyMaker_swigregister" line="5955" name="KeyMaker_swigregister" /><scope classrefs="KeyMaker" doc="KeyMaker subclass which combines several values.&#xA;&#xA;When the result is used for sorting, results are ordered by the first&#xA;value. In the event of a tie, the second is used. If this is the same&#xA;for both, the third is used, and so on. If reverse is true for a&#xA;value, then the sort order for that value is reversed.&#xA;&#xA;When used for collapsing, the documents will only be considered equal&#xA;if all the values specified match. If none of the specified values are&#xA;set then the generated key will be empty, so such documents won&apos;t be&#xA;collapsed (which is consistent with the behaviour in the &quot;collapse on&#xA;a value&quot; case). If you&apos;d prefer that documents with none of the keys&#xA;set are collapsed together, then you can set reverse for at least one&#xA;of the values. Other than this, it isn&apos;t useful to set reverse for&#xA;collapsing. " ilk="class" line="5958" lineend="5992" name="MultiValueKeyMaker"><variable citdl="_swig_property()" line="5976" name="thisown" /><variable citdl="_swig_repr" line="5977" name="__repr__" /><scope attributes="__ctor__" doc="Xapian::MultiValueKeyMaker::MultiValueKeyMaker(Iterator begin,&#xA;Iterator end) " ilk="function" line="5978" lineend="5983" name="__init__" signature="MultiValueKeyMaker()"><variable citdl="MultiValueKeyMaker" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::MultiValueKeyMaker::add_value(Xapian::valueno slot, bool&#xA;reverse=false) " line="5984" name="add_value" /><variable citdl="_xapian.delete_MultiValueKeyMaker" line="5992" name="__swig_destroy__" /></scope><variable citdl="_xapian.MultiValueKeyMaker_swigregister" line="5994" name="MultiValueKeyMaker_swigregister" /><scope classrefs="KeyMaker" doc="Virtual base class for sorter functor. " ilk="class" line="5997" lineend="6004" name="Sorter"><variable citdl="_swig_property()" line="6001" name="thisown" /><scope attributes="__ctor__" ilk="function" line="6002" lineend="6002" name="__init__" signature="Sorter(*args, **kwargs)"><variable citdl="Sorter" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope><variable citdl="_swig_repr" line="6003" name="__repr__" /><variable citdl="_xapian.delete_Sorter" line="6004" name="__swig_destroy__" /></scope><variable citdl="_xapian.Sorter_swigregister" line="6005" name="Sorter_swigregister" /><scope classrefs="Sorter" doc="Sorter subclass which sorts by a several values.&#xA;&#xA;Results are ordered by the first value. In the event of a tie, the&#xA;second is used. If this is the same for both, the third is used, and&#xA;so on.&#xA;&#xA;Deprecated This class is deprecated - you should migrate to using&#xA;MultiValueKeyMaker instead. Note that MultiValueSorter::add() becomes&#xA;MultiValueKeyMaker::add_value(), but the sense of the direction flag&#xA;is reversed (to be consistent with Enquire::set_sort_by_value()), so:&#xA;MultiValueSorter sorter; // Primary ordering is forwards on value 4.&#xA;sorter.add(4); // Secondary ordering is reverse on value 5.&#xA;sorter.add(5, false);&#xA;&#xA;becomes:&#xA;&#xA;MultiValueKeyMaker sorter; // Primary ordering is forwards on value 4.&#xA;sorter.add_value(4); // Secondary ordering is reverse on value 5.&#xA;sorter.add_value(5, true); " ilk="class" line="6008" lineend="6046" name="MultiValueSorter"><variable citdl="_swig_property()" line="6030" name="thisown" /><variable citdl="_swig_repr" line="6031" name="__repr__" /><scope attributes="__ctor__" doc="Xapian::MultiValueSorter::MultiValueSorter(Iterator begin, Iterator&#xA;end) " ilk="function" line="6032" lineend="6037" name="__init__" signature="MultiValueSorter()"><variable citdl="MultiValueSorter" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="function" doc="void&#xA;Xapian::MultiValueSorter::add(Xapian::valueno slot, bool forward=true)&#xA;" line="6038" name="add" /><variable citdl="_xapian.delete_MultiValueSorter" line="6046" name="__swig_destroy__" /></scope><variable citdl="_xapian.MultiValueSorter_swigregister" line="6048" name="MultiValueSorter_swigregister" /><scope classrefs="MatchDecider" doc="MatchDecider filtering results based on whether document values are in&#xA;a user- defined set. " ilk="class" line="6051" lineend="6103" name="ValueSetMatchDecider"><variable citdl="_swig_property()" line="6056" name="thisown" /><variable citdl="_swig_repr" line="6057" name="__repr__" /><scope attributes="__ctor__" doc="Construct a ValueSetMatchDecider.&#xA;&#xA;Xapian::ValueSetMatchDecider::ValueSetMatchDecider(Xapian::valueno&#xA;slot, bool inclusive_)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;slot:  The value slot number to look in.&#xA;&#xA;inclusive_:  If true, match decider accepts documents which have a&#xA;value in the specified slot which is a member of the test set; if&#xA;false, match decider accepts documents which do not have a value in&#xA;the specified slot. " ilk="function" line="6058" lineend="6075" name="__init__" signature="ValueSetMatchDecider(*args)"><variable citdl="ValueSetMatchDecider" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /></scope><variable attributes="__instancevar__" citdl="function" doc="Add a value to the test set.&#xA;&#xA;void Xapian::ValueSetMatchDecider::add_value(const std::string &amp;value)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;value:  The value to add to the test set. " line="6076" name="add_value" /><variable attributes="__instancevar__" citdl="function" doc="Remove a value from the test set.&#xA;&#xA;void Xapian::ValueSetMatchDecider::remove_value(const std::string&#xA;&amp;value)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;value:  The value to remove from the test set. " line="6089" name="remove_value" /><variable citdl="_xapian.delete_ValueSetMatchDecider" line="6103" name="__swig_destroy__" /></scope><variable citdl="_xapian.ValueSetMatchDecider_swigregister" line="6106" name="ValueSetMatchDecider_swigregister" /><scope classrefs="object" doc="Compact a database, or merge and compact several. " ilk="class" line="6109" lineend="6286" name="Compactor"><variable citdl="_swig_property()" line="6113" name="thisown" /><variable citdl="_swig_repr" line="6114" name="__repr__" /><variable citdl="_xapian.Compactor_STANDARD" line="6115" name="STANDARD" /><variable citdl="_xapian.Compactor_FULL" line="6116" name="FULL" /><variable citdl="_xapian.Compactor_FULLER" line="6117" name="FULLER" /><scope attributes="__ctor__" doc="Xapian::Compactor::Compactor() " ilk="function" line="6118" lineend="6124" name="__init__" signature="Compactor()"><variable citdl="Compactor" ilk="argument" name="self" /><variable attributes="protected" citdl="Compactor" line="6121" name="_self" /></scope><variable citdl="_xapian.delete_Compactor" line="6125" name="__swig_destroy__" /><variable attributes="__instancevar__" citdl="function" doc="Set the block size to use for tables in the output database.&#xA;&#xA;void Xapian::Compactor::set_block_size(size_t block_size)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;block_size:  The block size to use. Valid block sizes are currently&#xA;powers of two between 2048 and 65536, with the default being 8192, but&#xA;the valid sizes and default may change in the future. " line="6126" name="set_block_size" /><variable attributes="__instancevar__" citdl="function" doc="Set whether to preserve existing document id values.&#xA;&#xA;void Xapian::Compactor::set_renumber(bool renumber)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;renumber:  The default is true, which means that document ids will be&#xA;renumbered - currently by applying the same offset to all the document&#xA;ids in a particular source database.&#xA;&#xA;If false, then the document ids must be unique over all source&#xA;databases. Currently the ranges of document ids in each source must&#xA;not overlap either, though this restriction may be removed in the&#xA;future. " line="6141" name="set_renumber" /><variable attributes="__instancevar__" citdl="function" doc="Set whether to merge postlists in multiple passes.&#xA;&#xA;void Xapian::Compactor::set_multipass(bool multipass)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;multipass:  If true and merging more than 3 databases, merge the&#xA;postlists in multiple passes, which is generally faster but requires&#xA;more disk space for temporary files. By default we don&apos;t do this. " line="6161" name="set_multipass" /><variable attributes="__instancevar__" citdl="function" doc="Set the compaction level.&#xA;&#xA;void Xapian::Compactor::set_compaction_level(compaction_level&#xA;compaction)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;compaction:  Available values are: - Xapian::Compactor::STANDARD -&#xA;Don&apos;t split items unnecessarily. - Xapian::Compactor::FULL - Split&#xA;items whenever it saves space (the default). -&#xA;Xapian::Compactor::FULLER - Allow oversize items to save more space&#xA;(not recommended if you ever plan to update the compacted database).&#xA;" line="6176" name="set_compaction_level" /><variable attributes="__instancevar__" citdl="function" doc="Set where to write the output.&#xA;&#xA;void Xapian::Compactor::set_destdir(const std::string &amp;destdir)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;destdir:  Output path. This can be the same as an input if that input&#xA;is a stub database (in which case the database(s) listed in the stub&#xA;will be compacted to a new database and then the stub will be&#xA;atomically updated to point to this new database). " line="6195" name="set_destdir" /><variable attributes="__instancevar__" citdl="function" doc="Add a source database.&#xA;&#xA;void Xapian::Compactor::add_source(const std::string &amp;srcdir)&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;srcdir:  The path to the source database to add. " line="6211" name="add_source" /><variable attributes="__instancevar__" citdl="function" doc="Perform the actual compaction/merging operation.&#xA;&#xA;void Xapian::Compactor::compact() " line="6224" name="compact" /><variable attributes="__instancevar__" citdl="function" doc="Update progress.&#xA;&#xA;virtual void Xapian::Compactor::set_status(const std::string &amp;table,&#xA;const std::string &amp;status)&#xA;&#xA;Subclass this method if you want to get progress updates during&#xA;compaction. This is called for each table first with empty status, And&#xA;then one or more times with non-empty status.&#xA;&#xA;The default implementation does nothing.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;table:  The table currently being compacted.&#xA;&#xA;status:  A status message. " line="6232" name="set_status" /><variable attributes="__instancevar__" citdl="function" doc="Resolve multiple user metadata entries with the same key.&#xA;&#xA;virtual std::string&#xA;Xapian::Compactor::resolve_duplicate_metadata(const std::string &amp;key,&#xA;size_t num_tags, const std::string tags[])&#xA;&#xA;When merging, if the same user metadata key is set in more than one&#xA;input, then this method is called to allow this to be resolving in an&#xA;appropriate way.&#xA;&#xA;The default implementation just returns tags[0].&#xA;&#xA;For multipass this will currently get called multiple times for the&#xA;same key if there are duplicates to resolve in each pass, but this may&#xA;change in the future.&#xA;&#xA;Parameters:&#xA;-----------&#xA;&#xA;key:  The metadata key with duplicate entries.&#xA;&#xA;num_tags:  How many tags there are.&#xA;&#xA;tags:  An array of num_tags strings containing the tags to merge. " line="6254" name="resolve_duplicate_metadata" /><scope ilk="function" line="6283" lineend="6286" name="__disown__" returns="weakref_proxy()" signature="__disown__()"><variable citdl="Compactor" ilk="argument" name="self" /></scope></scope><variable citdl="_xapian.Compactor_swigregister" line="6296" name="Compactor_swigregister" /><variable citdl="str" line="6301" name="__docformat__" /><scope classrefs="object" doc="An item returned from iteration of the MSet.&#xA;&#xA;The item supports access to the following attributes and properties:&#xA;&#xA; - `docid`: The Xapian document ID corresponding to this MSet item.&#xA; - `weight`: The weight corresponding to this MSet item.&#xA; - `rank`: The rank of this MSet item.  The rank is the position in the&#xA;   total set of matching documents of this item.  The highest document is&#xA;   given a rank of 0.  If the MSet did not start at the highest matching&#xA;   document, because a non-zero &apos;start&apos; parameter was supplied to&#xA;   get_mset(), the first document in the MSet will have a rank greater than&#xA;   0 (in fact, it will be equal to the value of &apos;start&apos; supplied to&#xA;   get_mset()).&#xA; - `percent`: The percentage score assigned to this MSet item.&#xA; - `document`: The document for this MSet item.  This can be used to access&#xA;   the document data, or any other information stored in the document (such&#xA;   as term lists).  It is lazily evaluated.&#xA; - `collapse_key`: The value of the key which was used for collapsing.&#xA; - `collapse_count`: An estimate of the number of documents that have been&#xA;   collapsed into this one.&#xA;&#xA;The collapse count estimate will always be less than or equal to the actual&#xA;number of other documents satisfying the match criteria with the same&#xA;collapse key as this document.  If may be 0 even though there are other&#xA;documents with the same collapse key which satisfying the match criteria.&#xA;However if this method returns non-zero, there definitely are other such&#xA;documents.  So this method may be used to inform the user that there are&#xA;&quot;at least N other matches in this group&quot;, or to control whether to offer a&#xA;&quot;show other documents in this group&quot; feature (but note that it may not&#xA;offer it in every case where it would show other documents).&#xA;" ilk="class" line="6307" lineend="6360" name="MSetItem"><variable citdl="tuple" line="6341" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="6344" lineend="6353" name="__init__" signature="MSetItem(iter, mset)"><variable citdl="MSetItem" ilk="argument" name="self" /><variable ilk="argument" name="iter" /><variable ilk="argument" name="mset" /></scope><variable attributes="protected __instancevar__" line="6345" name="_mset" /><variable attributes="protected __instancevar__" citdl="self._mset.get_firstitem()" line="6346" name="_firstitem" /><variable attributes="__instancevar__" citdl="iter.get_docid()" line="6347" name="docid" /><variable attributes="__instancevar__" citdl="iter.get_weight()" line="6348" name="weight" /><variable attributes="__instancevar__" citdl="iter.get_rank()" line="6349" name="rank" /><variable attributes="__instancevar__" citdl="iter.get_percent()" line="6350" name="percent" /><variable attributes="__instancevar__" citdl="iter.get_collapse_key()" line="6351" name="collapse_key" /><variable attributes="__instancevar__" citdl="iter.get_collapse_count()" line="6352" name="collapse_count" /><variable attributes="protected __instancevar__" line="6353" name="_document" /><scope attributes="protected" ilk="function" line="6355" lineend="6358" name="_get_document" signature="_get_document()"><variable citdl="MSetItem" ilk="argument" name="self" /></scope><variable citdl="property()" line="6360" name="document" /></scope><scope classrefs="object" doc="An iterator over the items in an MSet.&#xA;&#xA;The iterator will return MSetItem objects, which will be evaluated lazily&#xA;where appropriate.&#xA;" ilk="class" line="6362" lineend="6394" name="MSetIter"><variable citdl="tuple" line="6369" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="6370" lineend="6373" name="__init__" signature="MSetIter(mset)"><variable citdl="MSetIter" ilk="argument" name="self" /><variable ilk="argument" name="mset" /></scope><variable attributes="protected __instancevar__" citdl="mset.begin()" line="6371" name="_iter" /><variable attributes="protected __instancevar__" citdl="mset.end()" line="6372" name="_end" /><variable attributes="protected __instancevar__" line="6373" name="_mset" /><scope ilk="function" line="6375" lineend="6376" name="__iter__" returns="MSetIter" signature="__iter__()"><variable citdl="MSetIter" ilk="argument" name="self" /></scope><scope ilk="function" line="6379" lineend="6385" name="next" returns="MSetItem" signature="next()"><variable citdl="MSetIter" ilk="argument" name="self" /><variable citdl="MSetItem" line="6383" name="r" /></scope><scope ilk="function" line="6388" lineend="6394" name="__next__" returns="MSetItem" signature="__next__()"><variable citdl="MSetIter" ilk="argument" name="self" /><variable citdl="MSetItem" line="6392" name="r" /></scope></scope><scope attributes="protected" doc="Return an iterator over the MSet.&#xA;&#xA;The iterator will return MSetItem objects, which will be evaluated lazily&#xA;where appropriate.&#xA;" ilk="function" line="6400" lineend="6407" name="_mset_gen_iter" returns="MSetIter" signature="_mset_gen_iter(self)"><variable ilk="argument" name="self" /></scope><scope attributes="protected" doc="Get an item from the MSet.&#xA;&#xA;The supplied index is relative to the start of the MSet, not the absolute&#xA;rank of the item.&#xA;&#xA;Returns an MSetItem.&#xA;" ilk="function" line="6412" lineend="6425" name="_mset_getitem" returns="MSetItem" signature="_mset_getitem(self, index)"><variable ilk="argument" name="self" /><variable ilk="argument" name="index" /></scope><scope classrefs="object" doc="An item returned from iteration of the ESet.&#xA;&#xA;The item supports access to the following attributes:&#xA;&#xA; - `term`: The term corresponding to this ESet item.&#xA; - `weight`: The weight corresponding to this ESet item.&#xA;" ilk="class" line="6434" lineend="6447" name="ESetItem"><variable citdl="tuple" line="6443" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="6445" lineend="6447" name="__init__" signature="ESetItem(iter)"><variable citdl="ESetItem" ilk="argument" name="self" /><variable ilk="argument" name="iter" /></scope><variable attributes="__instancevar__" citdl="iter.get_term()" line="6446" name="term" /><variable attributes="__instancevar__" citdl="iter.get_weight()" line="6447" name="weight" /></scope><scope classrefs="object" doc="An iterator over the items in an ESet.&#xA;&#xA;The iterator will return ESetItem objects.&#xA;" ilk="class" line="6449" lineend="6479" name="ESetIter"><variable citdl="tuple" line="6455" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="6456" lineend="6458" name="__init__" signature="ESetIter(eset)"><variable citdl="ESetIter" ilk="argument" name="self" /><variable ilk="argument" name="eset" /></scope><variable attributes="protected __instancevar__" citdl="eset.begin()" line="6457" name="_iter" /><variable attributes="protected __instancevar__" citdl="eset.end()" line="6458" name="_end" /><scope ilk="function" line="6460" lineend="6461" name="__iter__" returns="ESetIter" signature="__iter__()"><variable citdl="ESetIter" ilk="argument" name="self" /></scope><scope ilk="function" line="6464" lineend="6470" name="next" returns="ESetItem" signature="next()"><variable citdl="ESetIter" ilk="argument" name="self" /><variable citdl="ESetItem" line="6468" name="r" /></scope><scope ilk="function" line="6473" lineend="6479" name="__next__" returns="ESetItem" signature="__next__()"><variable citdl="ESetIter" ilk="argument" name="self" /><variable citdl="ESetItem" line="6477" name="r" /></scope></scope><scope attributes="protected" doc="Return an iterator over the ESet.&#xA;&#xA;The iterator will return ESetItem objects.&#xA;" ilk="function" line="6484" lineend="6490" name="_eset_gen_iter" returns="ESetIter" signature="_eset_gen_iter(self)"><variable ilk="argument" name="self" /></scope><scope classrefs="object" doc="An item returned from iteration of a term list.&#xA;&#xA;The item supports access to the following attributes and properties:&#xA;&#xA; - `term`: The term corresponding to this TermListItem.&#xA; - `wdf`: The within document frequency of this term.&#xA; - `termfreq`: The number of documents in the collection which are indexed&#xA;   by the term&#xA; - `positer`: An iterator over the positions which the term appears at in&#xA;   the document.  This is only available until the iterator which returned&#xA;   this item next moves.&#xA;" ilk="class" line="6500" lineend="6615" name="TermListItem"><variable citdl="tuple" line="6514" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="6516" lineend="6534" name="__init__" signature="TermListItem(iter, term)"><variable citdl="TermListItem" ilk="argument" name="self" /><variable ilk="argument" name="iter" /><variable ilk="argument" name="term" /><variable citdl="list" line="6528" name="sequence" /></scope><variable attributes="protected __instancevar__" line="6517" name="_iter" /><variable attributes="__instancevar__" line="6518" name="term" /><variable attributes="protected __instancevar__" citdl="iter._iter.get_wdf()" line="6519" name="_wdf" /><variable attributes="protected __instancevar__" citdl="self._iter._iter.get_termfreq()" line="6520" name="_termfreq" /><scope attributes="protected" doc="Get the within-document-frequency of the current term.&#xA;&#xA;This will raise a InvalidOperationError exception if the iterator this&#xA;item came from doesn&apos;t support within-document-frequencies.&#xA;" ilk="function" line="6536" lineend="6549" name="_get_wdf" returns="self._iter._iter.get_wdf()" signature="_get_wdf()"><variable citdl="TermListItem" ilk="argument" name="self" /></scope><variable citdl="property()" line="6550" name="wdf" /><scope attributes="protected" doc="Get the term frequency.&#xA;&#xA;This is the number of documents in the collection which are indexed by&#xA;the term.&#xA;&#xA;This will raise a InvalidOperationError exception if the iterator this&#xA;item came from doesn&apos;t support term frequencies.&#xA;" ilk="function" line="6558" lineend="6574" name="_get_termfreq" returns="iter._iter.get_termfreq()" signature="_get_termfreq()"><variable citdl="TermListItem" ilk="argument" name="self" /></scope><variable citdl="property()" line="6575" name="termfreq" /><scope attributes="protected" doc="Get a position list iterator.&#xA;&#xA;The iterator will return integers representing the positions that the&#xA;term occurs at.&#xA;&#xA;This will raise a InvalidOperationError exception if the iterator this&#xA;item came from doesn&apos;t support position lists, or if the iterator has&#xA;moved on since the item was returned from it.&#xA;" ilk="function" line="6586" lineend="6604" name="_get_positer" returns="PositionIter()" signature="_get_positer()"><variable citdl="TermListItem" ilk="argument" name="self" /></scope><variable citdl="property()" line="6605" name="positer" /></scope><scope classrefs="object" doc="An iterator over a term list.&#xA;&#xA;The iterator will return TermListItem objects, which will be evaluated&#xA;lazily where appropriate.&#xA;" ilk="class" line="6618" lineend="6718" name="TermIter"><variable citdl="tuple" line="6625" name="__slots__" /><variable citdl="int" line="6628" name="INVALID" /><variable citdl="int" line="6629" name="LAZY" /><variable citdl="int" line="6630" name="EAGER" /><scope attributes="__ctor__" ilk="function" line="6632" lineend="6649" name="__init__" signature="TermIter(start, end, has_termfreq=INVALID, has_wdf=INVALID, has_positions=INVALID, return_strings=False)"><variable citdl="TermIter" ilk="argument" name="self" /><variable ilk="argument" name="start" /><variable ilk="argument" name="end" /><variable citdl="int" ilk="argument" name="has_termfreq" /><variable citdl="int" ilk="argument" name="has_wdf" /><variable citdl="int" ilk="argument" name="has_positions" /><variable citdl="False" ilk="argument" name="return_strings" /></scope><variable attributes="protected __instancevar__" line="6635" name="_iter" /><variable attributes="protected __instancevar__" line="6636" name="_end" /><variable attributes="protected __instancevar__" citdl="int" line="6637" name="_has_termfreq" /><variable attributes="protected __instancevar__" citdl="int" line="6638" name="_has_wdf" /><variable attributes="protected __instancevar__" citdl="int" line="6639" name="_has_positions" /><variable attributes="protected __instancevar__" citdl="False" line="6641" name="_return_strings" /><variable attributes="protected __instancevar__" citdl="self._iter.get_term()" line="6642" name="_lastterm" /><variable attributes="protected __instancevar__" citdl="False" line="6649" name="_moved" /><scope ilk="function" line="6651" lineend="6652" name="__iter__" returns="TermIter" signature="__iter__()"><variable citdl="TermIter" ilk="argument" name="self" /></scope><scope ilk="function" line="6655" lineend="6668" name="next" returns="self._iter.get_term()" signature="next()"><variable citdl="TermIter" ilk="argument" name="self" /></scope><scope ilk="function" line="6671" lineend="6684" name="__next__" returns="self._iter.get_term()" signature="__next__()"><variable citdl="TermIter" ilk="argument" name="self" /></scope><scope doc="Skip the iterator forward.&#xA;&#xA;The iterator is advanced to the first term at or after the current&#xA;position which is greater than or equal to the supplied term.&#xA;&#xA;If there are no such items, this will raise StopIteration.&#xA;&#xA;This returns the item which the iterator is moved to.  The subsequent&#xA;item will be returned the next time that next() is called (unless&#xA;skip_to() is called again first).&#xA;" ilk="function" line="6686" lineend="6718" name="skip_to" returns="self._iter.get_term()" signature="skip_to(term)"><variable citdl="TermIter" ilk="argument" name="self" /><variable ilk="argument" name="term" /><variable citdl="self._iter.get_term()" line="6711" name="newterm" /></scope></scope><scope attributes="protected" doc="Get an iterator over the terms which match a given match set item.&#xA;&#xA;The match set item to consider is specified by the `which` parameter, which&#xA;may be a document ID, or an MSetItem object.&#xA;&#xA;The iterator will return string objects.&#xA;" ilk="function" line="6721" lineend="6734" name="_enquire_gen_iter" returns="TermIter" signature="_enquire_gen_iter(self, which)"><variable ilk="argument" name="self" /><variable citdl="which.docid" ilk="argument" name="which" /></scope><scope attributes="protected" doc="Get an iterator over the terms in a query.&#xA;&#xA;The iterator will return string objects.&#xA;" ilk="function" line="6738" lineend="6746" name="_query_gen_iter" returns="TermIter" signature="_query_gen_iter(self)"><variable ilk="argument" name="self" /></scope><scope attributes="protected" doc="Get an iterator over all the terms in the database.&#xA;&#xA;The iterator will return TermListItem objects, but these will not support&#xA;access to wdf, or position information.&#xA;&#xA;Access to term frequency information is only available until the iterator&#xA;has moved on.&#xA;&#xA;If prefix is supplied, only terms which start with that prefix will be&#xA;returned.&#xA;" ilk="function" line="6750" lineend="6768" name="_database_gen_allterms_iter" returns="TermIter" signature="_database_gen_allterms_iter(self, prefix=None)"><variable ilk="argument" name="self" /><variable ilk="argument" name="prefix" /></scope><scope attributes="protected" doc="Get an iterator over all the terms which index a given document ID.&#xA;&#xA;The iterator will return TermListItem objects.&#xA;&#xA;Access to term frequency and position information is only available until&#xA;the iterator has moved on.&#xA;" ilk="function" line="6773" lineend="6789" name="_database_gen_termlist_iter" returns="TermIter" signature="_database_gen_termlist_iter(self, docid)"><variable ilk="argument" name="self" /><variable ilk="argument" name="docid" /></scope><scope attributes="protected" doc="Get an iterator which returns all the spelling correction targets&#xA;&#xA;The iterator will return TermListItem objects.  Only the term frequency is&#xA;available; wdf and positions are not meaningful.&#xA;" ilk="function" line="6793" lineend="6803" name="_database_gen_spellings_iter" returns="TermIter" signature="_database_gen_spellings_iter(self)"><variable ilk="argument" name="self" /></scope><scope attributes="protected" doc="Get an iterator which returns all the synonyms for a given term.&#xA;&#xA;The term to return synonyms for is specified by the `term` parameter.&#xA;&#xA;The iterator will return string objects.&#xA;" ilk="function" line="6807" lineend="6817" name="_database_gen_synonyms_iter" returns="TermIter" signature="_database_gen_synonyms_iter(self, term)"><variable ilk="argument" name="self" /><variable ilk="argument" name="term" /></scope><scope attributes="protected" doc="Get an iterator which returns all the terms which have synonyms.&#xA;&#xA;The iterator will return string objects.&#xA;&#xA;If `prefix` is non-empty, only terms with this prefix are returned.&#xA;" ilk="function" line="6821" lineend="6831" name="_database_gen_synonym_keys_iter" returns="TermIter" signature="_database_gen_synonym_keys_iter(self, prefix=&apos;&apos;)"><variable ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="prefix" /></scope><scope attributes="protected" doc="Get an iterator which returns all the metadata keys.&#xA;&#xA;The iterator will return string objects.&#xA;&#xA;If `prefix` is non-empty, only metadata keys with this prefix are returned.&#xA;" ilk="function" line="6836" lineend="6846" name="_database_gen_metadata_keys_iter" returns="TermIter" signature="_database_gen_metadata_keys_iter(self, prefix=&apos;&apos;)"><variable ilk="argument" name="self" /><variable citdl="str" ilk="argument" name="prefix" /></scope><scope attributes="protected" doc="Get an iterator over all the terms in a document.&#xA;&#xA;The iterator will return TermListItem objects.&#xA;&#xA;Access to term frequency and position information is only available until&#xA;the iterator has moved on.&#xA;&#xA;Note that term frequency information is only meaningful for a document&#xA;retrieved from a database.  If term frequency information is requested for&#xA;a document which was freshly created, an InvalidOperationError will be&#xA;raised.&#xA;" ilk="function" line="6850" lineend="6873" name="_document_gen_termlist_iter" returns="TermIter" signature="_document_gen_termlist_iter(self)"><variable ilk="argument" name="self" /></scope><scope attributes="protected" doc="Get an iterator over all the stopped terms from the previous query.&#xA;&#xA;This returns an iterator over all the terms which were omitted from the&#xA;previously parsed query due to being considered to be stopwords.  Each&#xA;instance of a word omitted from the query is represented in the returned&#xA;list, in the order in which the&#xA;&#xA;The iterator will return string objects.&#xA;" ilk="function" line="6878" lineend="6890" name="_queryparser_gen_stoplist_iter" returns="TermIter" signature="_queryparser_gen_stoplist_iter(self)"><variable ilk="argument" name="self" /></scope><scope attributes="protected" doc="Get an iterator over all the unstemmed forms of a stemmed term.&#xA;&#xA;This returns an iterator which returns all the unstemmed words which were&#xA;stemmed to the stemmed form specifed by `tname` when parsing the previous&#xA;query.  Each instance of a word which stems to `tname` is returned by the&#xA;iterator in the order in which the words appeared in the query - an&#xA;individual unstemmed word may thus occur multiple times.&#xA;&#xA;The iterator will return string objects.&#xA;" ilk="function" line="6894" lineend="6907" name="_queryparser_gen_unstemlist_iter" returns="TermIter" signature="_queryparser_gen_unstemlist_iter(self, tname)"><variable ilk="argument" name="self" /><variable ilk="argument" name="tname" /></scope><variable attributes="private" citdl="Query.__init__" line="6956" name="__query_init_orig" /><scope attributes="protected" doc="Make a new query object.&#xA;&#xA;Many possible arguments are possible - see the documentation for details.&#xA;" ilk="function" line="6957" lineend="6975" name="_query_init" signature="_query_init(self, *args)"><variable ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable citdl="list" line="6963" name="ps" /></scope><variable attributes="private" citdl="function" line="6982" name="__enquire_set_query_orig" /><scope attributes="protected" ilk="function" line="6983" lineend="6985" name="_enquire_set_query" returns="__enquire_set_query_orig()" signature="_enquire_set_query(self, query, qlen=0)"><variable ilk="argument" name="self" /><variable ilk="argument" name="query" /><variable citdl="int" ilk="argument" name="qlen" /><variable citdl="__enquire_set_query_orig.__doc__" line="6986" name="__doc__" /></scope><variable attributes="private" citdl="function" line="6993" name="__enquire_get_query_orig" /><scope attributes="protected" ilk="function" line="6994" lineend="6997" name="_enquire_get_query" returns="__enquire_get_query_orig()" signature="_enquire_get_query(self)"><variable ilk="argument" name="self" /><variable citdl="__enquire_get_query_orig()" line="6995" name="query" /><variable citdl="__enquire_get_query_orig.__doc__" line="6998" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7005" name="__queryparser_add_valuerangeprocessor_orig" /><scope attributes="protected" ilk="function" line="7006" lineend="7010" name="_queryparser_add_valuerangeprocessor" returns="__queryparser_add_valuerangeprocessor_orig()" signature="_queryparser_add_valuerangeprocessor(self, vrproc)"><variable ilk="argument" name="self" /><variable ilk="argument" name="vrproc" /><variable citdl="__queryparser_add_valuerangeprocessor_orig.__doc__" line="7011" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7018" name="__queryparser_set_stopper_orig" /><scope attributes="protected" ilk="function" line="7019" lineend="7021" name="_queryparser_set_stopper" returns="__queryparser_set_stopper_orig()" signature="_queryparser_set_stopper(self, stopper)"><variable ilk="argument" name="self" /><variable ilk="argument" name="stopper" /><variable citdl="__queryparser_set_stopper_orig.__doc__" line="7022" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7029" name="__termgenerator_set_stopper_orig" /><scope attributes="protected" ilk="function" line="7030" lineend="7032" name="_termgenerator_set_stopper" returns="__termgenerator_set_stopper_orig()" signature="_termgenerator_set_stopper(self, stopper)"><variable ilk="argument" name="self" /><variable ilk="argument" name="stopper" /><variable citdl="__termgenerator_set_stopper_orig.__doc__" line="7033" name="__doc__" /></scope><scope attributes="protected" doc="Check the keyword arguments to one of the enquire set_sort_* methods.&#xA;    &#xA;    " ilk="function" line="7037" lineend="7061" name="_enquire_check_deprec_args" returns="kwargs.get()" signature="_enquire_check_deprec_args(reverse, kwargs, methodname)"><import line="7047" module="warnings" /><variable citdl="True" ilk="argument" name="reverse" /><variable ilk="argument" name="kwargs" /><variable ilk="argument" name="methodname" /></scope><variable attributes="private" citdl="function" line="7065" name="__enquire_set_sort_by_key_orig" /><scope attributes="protected" ilk="function" line="7066" lineend="7069" name="_enquire_set_sort_by_key" returns="__enquire_set_sort_by_key_orig()" signature="_enquire_set_sort_by_key(self, sorter, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sorter" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_key_orig.__doc__" line="7070" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7074" name="__enquire_set_sort_by_key_then_relevance_orig" /><scope attributes="protected" ilk="function" line="7075" lineend="7078" name="_enquire_set_sort_by_key_then_relevance" returns="__enquire_set_sort_by_key_then_relevance_orig()" signature="_enquire_set_sort_by_key_then_relevance(self, sorter, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sorter" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_key_then_relevance_orig.__doc__" line="7079" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7083" name="__enquire_set_sort_by_relevance_then_key_orig" /><scope attributes="protected" ilk="function" line="7084" lineend="7087" name="_enquire_set_sort_by_relevance_then_key" returns="__enquire_set_sort_by_relevance_then_key_orig()" signature="_enquire_set_sort_by_relevance_then_key(self, sorter, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sorter" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_relevance_then_key_orig.__doc__" line="7088" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7093" name="__enquire_set_sort_by_value_orig" /><scope attributes="protected" ilk="function" line="7094" lineend="7096" name="_enquire_set_sort_by_value" returns="__enquire_set_sort_by_value_orig()" signature="_enquire_set_sort_by_value(self, sort_key, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sort_key" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_value_orig.__doc__" line="7097" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7102" name="__enquire_set_sort_by_relevance_then_value_orig" /><scope attributes="protected" ilk="function" line="7103" lineend="7105" name="_enquire_set_sort_by_relevance_then_value" returns="__enquire_set_sort_by_relevance_then_value_orig()" signature="_enquire_set_sort_by_relevance_then_value(self, sort_key, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sort_key" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_relevance_then_value_orig.__doc__" line="7106" name="__doc__" /></scope><variable attributes="private" citdl="function" line="7111" name="__enquire_set_sort_by_value_then_relevance_orig" /><scope attributes="protected" ilk="function" line="7112" lineend="7114" name="_enquire_set_sort_by_value_then_relevance" returns="__enquire_set_sort_by_value_then_relevance_orig()" signature="_enquire_set_sort_by_value_then_relevance(self, sort_key, reverse=None, **kwargs)"><variable ilk="argument" name="self" /><variable ilk="argument" name="sort_key" /><variable citdl="_enquire_check_deprec_args()" ilk="argument" name="reverse" /><variable attributes="kwargs" ilk="argument" name="kwargs" /><variable citdl="__enquire_set_sort_by_value_then_relevance_orig.__doc__" line="7115" name="__doc__" /></scope><scope classrefs="object" doc="An item returned from iteration of a posting list.&#xA;&#xA;The item supports access to the following attributes and properties:&#xA;&#xA; - `docid`: The document ID corresponding to this PostingItem.&#xA; - `doclength`: The length of the document corresponding to this&#xA;   PostingItem.&#xA; - `wdf`: The within document frequency of the term which the posting list&#xA;   is for in the document corresponding to this PostingItem.&#xA; - `positer`: An iterator over the positions which the term corresponing to&#xA;   this posting list occurs at in the document corresponding to this&#xA;   PostingItem.  This is only available until the iterator which returned&#xA;   this item next moves.&#xA;" ilk="class" line="7124" lineend="7181" name="PostingItem"><variable citdl="tuple" line="7140" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="7142" lineend="7151" name="__init__" signature="PostingItem(iter)"><variable citdl="PostingItem" ilk="argument" name="self" /><variable ilk="argument" name="iter" /><variable citdl="list" line="7149" name="sequence" /></scope><variable attributes="protected __instancevar__" line="7143" name="_iter" /><variable attributes="__instancevar__" citdl="iter._iter.get_docid()" line="7144" name="docid" /><variable attributes="__instancevar__" citdl="iter._iter.get_doclength()" line="7145" name="doclength" /><variable attributes="__instancevar__" citdl="iter._iter.get_wdf()" line="7146" name="wdf" /><scope attributes="protected" doc="Get a position list iterator.&#xA;&#xA;The iterator will return integers representing the positions that the&#xA;term occurs at in the document corresponding to this PostingItem.&#xA;&#xA;This will raise a InvalidOperationError exception if the iterator this&#xA;item came from doesn&apos;t support position lists, or if the iterator has&#xA;moved on since the item was returned from it.&#xA;" ilk="function" line="7153" lineend="7170" name="_get_positer" returns="PositionIter()" signature="_get_positer()"><variable citdl="PostingItem" ilk="argument" name="self" /></scope><variable citdl="property()" line="7171" name="positer" /></scope><scope classrefs="object" doc="An iterator over a posting list.&#xA;&#xA;The iterator will return PostingItem objects, which will be evaluated&#xA;lazily where appropriate.&#xA;" ilk="class" line="7184" lineend="7251" name="PostingIter"><variable citdl="tuple" line="7191" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="7193" lineend="7203" name="__init__" signature="PostingIter(start, end, has_positions=False)"><variable citdl="PostingIter" ilk="argument" name="self" /><variable ilk="argument" name="start" /><variable ilk="argument" name="end" /><variable citdl="False" ilk="argument" name="has_positions" /></scope><variable attributes="protected __instancevar__" line="7194" name="_iter" /><variable attributes="protected __instancevar__" line="7195" name="_end" /><variable attributes="protected __instancevar__" citdl="False" line="7196" name="_has_positions" /><variable attributes="protected __instancevar__" citdl="True" line="7203" name="_moved" /><scope ilk="function" line="7205" lineend="7206" name="__iter__" returns="PostingIter" signature="__iter__()"><variable citdl="PostingIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7209" lineend="7218" name="next" returns="PostingItem" signature="next()"><variable citdl="PostingIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7221" lineend="7230" name="__next__" returns="PostingItem" signature="__next__()"><variable citdl="PostingIter" ilk="argument" name="self" /></scope><scope doc="Skip the iterator forward.&#xA;&#xA;The iterator is advanced to the first document with a document ID&#xA;which is greater than or equal to the supplied document ID.&#xA;&#xA;If there are no such items, this will raise StopIteration.&#xA;&#xA;This returns the item which the iterator is moved to.  The subsequent&#xA;item will be returned the next time that next() is called (unless&#xA;skip_to() is called again first).&#xA;" ilk="function" line="7232" lineend="7251" name="skip_to" returns="PostingItem" signature="skip_to(docid)"><variable citdl="PostingIter" ilk="argument" name="self" /><variable ilk="argument" name="docid" /></scope></scope><scope attributes="protected" doc="Get an iterator over the postings which are indexed by a given term.&#xA;&#xA;If `tname` is empty, an iterator over all the documents will be returned&#xA;(this will contain one entry for each document, will always return a wdf of&#xA;1, and will not allow access to a position iterator).&#xA;" ilk="function" line="7253" lineend="7265" name="_database_gen_postlist_iter" returns="PostingIter" signature="_database_gen_postlist_iter(self, tname)"><variable ilk="argument" name="self" /><variable ilk="argument" name="tname" /></scope><scope classrefs="object" doc="An iterator over a position list.&#xA;&#xA;The iterator will return integers, in ascending order.&#xA;" ilk="class" line="7273" lineend="7302" name="PositionIter"><scope attributes="__ctor__" ilk="function" line="7279" lineend="7281" name="__init__" signature="PositionIter(start=0, end=0)"><variable citdl="PositionIter" ilk="argument" name="self" /><variable citdl="int" ilk="argument" name="start" /><variable citdl="int" ilk="argument" name="end" /></scope><variable attributes="__instancevar__" citdl="int" line="7280" name="iter" /><variable attributes="__instancevar__" citdl="int" line="7281" name="end" /><scope ilk="function" line="7283" lineend="7284" name="__iter__" returns="PositionIter" signature="__iter__()"><variable citdl="PositionIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7287" lineend="7293" name="next" returns="self.iter.get_termpos()" signature="next()"><variable citdl="PositionIter" ilk="argument" name="self" /><variable citdl="self.iter.get_termpos()" line="7291" name="r" /></scope><scope ilk="function" line="7296" lineend="7302" name="__next__" returns="self.iter.get_termpos()" signature="__next__()"><variable citdl="PositionIter" ilk="argument" name="self" /><variable citdl="self.iter.get_termpos()" line="7300" name="r" /></scope></scope><scope attributes="protected" doc="Get an iterator over all the positions in a given document of a term.&#xA;&#xA;The iterator will return integers, in ascending order.&#xA;" ilk="function" line="7305" lineend="7311" name="_database_gen_positionlist_iter" returns="PositionIter" signature="_database_gen_positionlist_iter(self, docid, tname)"><variable ilk="argument" name="self" /><variable ilk="argument" name="docid" /><variable ilk="argument" name="tname" /></scope><scope classrefs="object" doc="An item returned from iteration of the values in a document.&#xA;&#xA;The item supports access to the following attributes:&#xA;&#xA; - `num`: The number of the value.&#xA; - `value`: The contents of the value.&#xA;" ilk="class" line="7318" lineend="7332" name="ValueItem"><variable citdl="tuple" line="7328" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="7330" lineend="7332" name="__init__" signature="ValueItem(num, value)"><variable citdl="ValueItem" ilk="argument" name="self" /><variable ilk="argument" name="num" /><variable ilk="argument" name="value" /></scope><variable attributes="__instancevar__" line="7331" name="num" /><variable attributes="__instancevar__" line="7332" name="value" /></scope><scope classrefs="object" doc="An iterator over all the values stored in a document.&#xA;&#xA;The iterator will return ValueItem objects, in ascending order of value number.&#xA;" ilk="class" line="7334" lineend="7363" name="ValueIter"><scope attributes="__ctor__" ilk="function" line="7340" lineend="7342" name="__init__" signature="ValueIter(start, end)"><variable citdl="ValueIter" ilk="argument" name="self" /><variable ilk="argument" name="start" /><variable ilk="argument" name="end" /></scope><variable attributes="__instancevar__" line="7341" name="iter" /><variable attributes="__instancevar__" line="7342" name="end" /><scope ilk="function" line="7344" lineend="7345" name="__iter__" returns="ValueIter" signature="__iter__()"><variable citdl="ValueIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7348" lineend="7354" name="next" returns="ValueItem" signature="next()"><variable citdl="ValueIter" ilk="argument" name="self" /><variable citdl="ValueItem" line="7352" name="r" /></scope><scope ilk="function" line="7357" lineend="7363" name="__next__" returns="ValueItem" signature="__next__()"><variable citdl="ValueIter" ilk="argument" name="self" /><variable citdl="ValueItem" line="7361" name="r" /></scope></scope><scope attributes="protected" doc="Get an iterator over all the values stored in a document.&#xA;&#xA;The iterator will return ValueItem objects, in ascending order of value number.&#xA;" ilk="function" line="7366" lineend="7372" name="_document_gen_values_iter" returns="ValueIter" signature="_document_gen_values_iter(self)"><variable ilk="argument" name="self" /></scope><scope classrefs="object" doc="An item returned from iteration of the values in a document.&#xA;&#xA;The item supports access to the following attributes:&#xA;&#xA; - `docid`: The docid for the item.&#xA; - `value`: The contents of the value.&#xA;" ilk="class" line="7380" lineend="7394" name="ValueStreamItem"><variable citdl="tuple" line="7390" name="__slots__" /><scope attributes="__ctor__" ilk="function" line="7392" lineend="7394" name="__init__" signature="ValueStreamItem(docid, value)"><variable citdl="ValueStreamItem" ilk="argument" name="self" /><variable ilk="argument" name="docid" /><variable ilk="argument" name="value" /></scope><variable attributes="__instancevar__" line="7393" name="docid" /><variable attributes="__instancevar__" line="7394" name="value" /></scope><scope classrefs="object" doc="An iterator over all the values stored in a document.&#xA;&#xA;The iterator will return ValueStreamItem objects, in ascending order of value number.&#xA;" ilk="class" line="7396" lineend="7453" name="ValueStreamIter"><scope attributes="__ctor__" ilk="function" line="7402" lineend="7405" name="__init__" signature="ValueStreamIter(start, end)"><variable citdl="ValueStreamIter" ilk="argument" name="self" /><variable ilk="argument" name="start" /><variable ilk="argument" name="end" /></scope><variable attributes="__instancevar__" line="7403" name="iter" /><variable attributes="__instancevar__" line="7404" name="end" /><variable attributes="__instancevar__" citdl="False" line="7405" name="moved" /><scope ilk="function" line="7407" lineend="7408" name="__iter__" returns="ValueStreamIter" signature="__iter__()"><variable citdl="ValueStreamIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7411" lineend="7420" name="next" returns="ValueStreamItem" signature="next()"><variable citdl="ValueStreamIter" ilk="argument" name="self" /></scope><scope ilk="function" line="7423" lineend="7432" name="__next__" returns="ValueStreamItem" signature="__next__()"><variable citdl="ValueStreamIter" ilk="argument" name="self" /></scope><scope doc="Skip the iterator forward.&#xA;&#xA;The iterator is advanced to the first document with a document ID&#xA;which is greater than or equal to the supplied document ID.&#xA;&#xA;If there are no such items, this will raise StopIteration.&#xA;&#xA;This returns the item which the iterator is moved to.  The subsequent&#xA;item will be returned the next time that next() is called (unless&#xA;skip_to() is called again first).&#xA;" ilk="function" line="7434" lineend="7453" name="skip_to" returns="ValueStreamItem" signature="skip_to(docid)"><variable citdl="ValueStreamIter" ilk="argument" name="self" /><variable ilk="argument" name="docid" /></scope></scope><scope ilk="function" line="7457" lineend="7468" name="wrapper" returns="wrapper._database_gen_valuestream_iter" signature="wrapper()"><variable citdl="function" line="7458" name="vs_begin" /><variable citdl="function" line="7459" name="vs_end" /><scope attributes="protected" doc="Get an iterator over all the values stored in a slot in the database.&#xA;&#xA;The iterator will return ValueStreamItem objects, in ascending order of&#xA;document id.&#xA;" ilk="function" line="7460" lineend="7467" name="_database_gen_valuestream_iter" returns="ValueStreamIter" signature="_database_gen_valuestream_iter(self, slot)"><variable ilk="argument" name="self" /><variable ilk="argument" name="slot" /></scope></scope><variable attributes="protected" citdl="function" line="7477" name="_enquire_add_matchspy_orig" /><scope attributes="protected" ilk="function" line="7478" lineend="7482" name="_enquire_match_spy_add" signature="_enquire_match_spy_add(self, decider)"><variable ilk="argument" name="self" /><variable ilk="argument" name="decider" /><variable citdl="Enquire.add_matchspy.__doc__" line="7483" name="__doc__" /></scope><variable attributes="protected" citdl="function" line="7486" name="_enquire_clear_matchspies_orig" /><scope attributes="protected" ilk="function" line="7487" lineend="7490" name="_enquire_match_spies_clear" signature="_enquire_match_spies_clear(self)"><variable ilk="argument" name="self" /><variable citdl="Enquire.clear_matchspies.__doc__" line="7491" name="__doc__" /></scope><variable attributes="protected" citdl="Stem.__init__" line="7497" name="_stem_init_orig" /><scope attributes="protected" ilk="function" line="7498" lineend="7501" name="_stem_init" signature="_stem_init(self, *args)"><variable ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable citdl="Stem.__init__.__doc__" line="7502" name="__doc__" /></scope><variable citdl="tuple()" line="7526" name="__all__" /></scope>