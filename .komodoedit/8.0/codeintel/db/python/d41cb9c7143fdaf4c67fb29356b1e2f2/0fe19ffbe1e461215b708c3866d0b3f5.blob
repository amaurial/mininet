<scope doc="Logging functions for Mininet." ilk="blob" lang="Python" name="log" src="/home/mininet/mininet/mininet/log.py"><import line="3" module="logging" /><import line="4" module="logging" symbol="Logger" /><import line="5" module="types" /><variable citdl="int" line="11" name="OUTPUT" /><variable citdl="dict" line="13" name="LEVELS" /><variable citdl="int" line="21" name="LOGLEVELDEFAULT" /><variable citdl="str" line="24" name="LOGMSGFORMAT" /><scope classrefs="logging.StreamHandler" doc="StreamHandler that doesn&apos;t print newlines by default.&#xA;Since StreamHandler automatically adds newlines, define a mod to more&#xA;easily support interactive mode when we want it, or errors-only logging&#xA;for running unit tests." ilk="class" line="28" lineend="55" name="StreamHandlerNoNewline"><scope doc="Emit a record.&#xA;If a formatter is specified, it is used to format the record.&#xA;The record is then written to the stream with a trailing newline&#xA;[ N.B. this may be removed depending on feedback ]. If exception&#xA;information is present, it is formatted using&#xA;traceback.printException and appended to the stream." ilk="function" line="34" lineend="55" name="emit" signature="emit(record)"><variable citdl="StreamHandlerNoNewline" ilk="argument" name="self" /><variable ilk="argument" name="record" /><variable citdl="self.format()" line="42" name="msg" /><variable citdl="str" line="43" name="fs" /></scope></scope><scope classrefs="type" doc="Singleton pattern from Wikipedia&#xA;See http://en.wikipedia.org/wiki/SingletonPattern#Python&#xA;&#xA;Intended to be used as a __metaclass_ param, as shown for the class&#xA;below.&#xA;&#xA;Changed cls first args to mcs to satisfy pylint." ilk="class" line="58" lineend="74" name="Singleton"><scope attributes="__ctor__" ilk="function" line="67" lineend="69" name="__init__" signature="Singleton(name, bases, dict_)"><variable citdl="Singleton" ilk="argument" name="mcs" /><variable ilk="argument" name="name" /><variable ilk="argument" name="bases" /><variable ilk="argument" name="dict_" /></scope><variable attributes="__instancevar__" line="69" name="instance" /><scope ilk="function" line="71" lineend="74" name="__call__" signature="__call__(*args, **kw)"><variable citdl="Singleton" ilk="argument" name="mcs" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope></scope><scope classrefs="Logger object" doc="Mininet-specific logger&#xA;Enable each mininet .py file to with one import:&#xA;&#xA;from mininet.log import [lg, info, error]&#xA;&#xA;...get a default logger that doesn&apos;t require one newline per logging&#xA;call.&#xA;&#xA;Inherit from object to ensure that we have at least one new-style base&#xA;class, and can then use the __metaclass__ directive, to prevent this&#xA;error:&#xA;&#xA;TypeError: Error when calling the metaclass bases&#xA;a new-style class can&apos;t have only classic bases&#xA;&#xA;If Python2.5/logging/__init__.py defined Filterer as a new-style class,&#xA;via Filterer( object ): rather than Filterer, we wouldn&apos;t need this.&#xA;&#xA;Use singleton pattern to ensure only one logger is ever created." ilk="class" line="77" lineend="145" name="MininetLogger"><variable citdl="Singleton" line="98" name="__metaclass__" /><scope attributes="__ctor__" ilk="function" line="100" lineend="113" name="__init__" signature="MininetLogger()"><variable citdl="MininetLogger" ilk="argument" name="self" /><variable citdl="StreamHandlerNoNewline" line="105" name="ch" /><variable citdl="logging.Formatter()" line="107" name="formatter" /></scope><scope doc="Setup loglevel.&#xA;Convenience function to support lowercase names.&#xA;levelName: level name from LEVELS" ilk="function" line="115" lineend="127" name="setLogLevel" signature="setLogLevel(levelname=None)"><variable citdl="MininetLogger" ilk="argument" name="self" /><variable ilk="argument" name="levelname" /><variable citdl="int" line="119" name="level" /></scope><scope doc="Log &apos;msg % args&apos; with severity &apos;OUTPUT&apos;.&#xA;&#xA;To pass exception information, use the keyword argument exc_info&#xA;with a true value, e.g.&#xA;&#xA;logger.warning(&quot;Houston, we have a %s&quot;, &quot;cli output&quot;, exc_info=1)" ilk="function" line="134" lineend="145" name="output" signature="output(msg, *args, **kwargs)"><variable citdl="MininetLogger" ilk="argument" name="self" /><variable ilk="argument" name="msg" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kwargs" /></scope></scope><variable citdl="MininetLogger" line="149" name="lg" /><scope doc="Return a new function allowing fn( &apos;a 1 b&apos; ) to be called as&#xA;newfn( &apos;a&apos;, 1, &apos;b&apos; )" ilk="function" line="157" lineend="171" name="makeListCompatible" returns="makeListCompatible.newfn" signature="makeListCompatible(fn)"><variable ilk="argument" name="fn" /><scope doc="Generated function. Closure-ish." ilk="function" line="161" lineend="166" name="newfn" returns="makeListCompatible.fn()" signature="newfn(*args)"><variable attributes="varargs" citdl="__builtins__.str.join()" ilk="argument" name="args" /></scope></scope><variable citdl="lg.setLogLevel" line="178" name="setLogLevel" /></scope>