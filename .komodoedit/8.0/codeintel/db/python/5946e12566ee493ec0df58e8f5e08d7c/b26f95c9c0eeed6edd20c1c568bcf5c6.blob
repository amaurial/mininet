<scope doc="Base class for directed graphs." ilk="blob" lang="Python" name="digraph" src="/usr/lib/pymodules/python2.7/networkx/classes/digraph.py"><import line="8" module="copy" symbol="deepcopy" /><import alias="nx" line="9" module="networkx" /><import line="10" module="networkx.classes.graph" symbol="Graph" /><import line="11" module="networkx.exception" symbol="NetworkXError" /><import alias="convert" line="12" module="networkx.convert" /><variable citdl="__builtins__.str.join()" line="13" name="__author__" /><scope classrefs="Graph" doc="Base class for directed graphs.&#xA;&#xA;A DiGraph stores nodes and edges with optional data, or attributes.&#xA;&#xA;DiGraphs hold directed edges.  Self loops are allowed but multiple&#xA;(parallel) edges are not.&#xA;&#xA;Nodes can be arbitrary (hashable) Python objects with optional&#xA;key/value attributes.&#xA;&#xA;Edges are represented as links between nodes with optional&#xA;key/value attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;Graph&#xA;MultiGraph&#xA;MultiDiGraph&#xA;&#xA;Examples&#xA;--------&#xA;Create an empty graph structure (a &quot;null graph&quot;) with no nodes and&#xA;no edges.&#xA;&#xA;&gt;&gt;&gt; G = nx.DiGraph()&#xA;&#xA;G can be grown in several ways.&#xA;&#xA;**Nodes:**&#xA;&#xA;Add one node at a time:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&#xA;Add the nodes from any container (a list, dict, set or&#xA;even the lines from a file or the nodes from another graph).&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([2,3])&#xA;&gt;&gt;&gt; G.add_nodes_from(range(100,110))&#xA;&gt;&gt;&gt; H=nx.Graph()&#xA;&gt;&gt;&gt; H.add_path([0,1,2,3,4,5,6,7,8,9])&#xA;&gt;&gt;&gt; G.add_nodes_from(H)&#xA;&#xA;In addition to strings and integers any hashable Python object&#xA;(except None) can represent a node, e.g. a customized node object,&#xA;or even another Graph.&#xA;&#xA;&gt;&gt;&gt; G.add_node(H)&#xA;&#xA;**Edges:**&#xA;&#xA;G can also be grown by adding edges.&#xA;&#xA;Add one edge,&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2)&#xA;&#xA;a list of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,3)])&#xA;&#xA;or a collection of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from(H.edges())&#xA;&#xA;If some edges connect nodes not yet in the graph, the nodes&#xA;are added automatically.  There are no errors when adding&#xA;nodes or edges that already exist.&#xA;&#xA;**Attributes:**&#xA;&#xA;Each graph, node, and edge can hold key/value attribute pairs&#xA;in an associated attribute dictionary (the keys must be hashable).&#xA;By default these are empty, but can be added or changed using&#xA;add_edge, add_node or direct manipulation of the attribute&#xA;dictionaries named graph, node and edge respectively.&#xA;&#xA;&gt;&gt;&gt; G = nx.DiGraph(day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;&#xA;Add node attributes using add_node(), add_nodes_from() or G.node&#xA;&#xA;&gt;&gt;&gt; G.add_node(1, time=&apos;5pm&apos;)&#xA;&gt;&gt;&gt; G.add_nodes_from([3], time=&apos;2pm&apos;)&#xA;&gt;&gt;&gt; G.node[1]&#xA;{&apos;time&apos;: &apos;5pm&apos;}&#xA;&gt;&gt;&gt; G.node[1][&apos;room&apos;] = 714&#xA;&gt;&gt;&gt; del G.node[1][&apos;room&apos;] # remove attribute&#xA;&gt;&gt;&gt; G.nodes(data=True)&#xA;[(1, {&apos;time&apos;: &apos;5pm&apos;}), (3, {&apos;time&apos;: &apos;2pm&apos;})]&#xA;&#xA;Warning: adding a node to G.node does not add it to the graph.&#xA;&#xA;Add edge attributes using add_edge(), add_edges_from(), subscript&#xA;notation, or G.edge.&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=4.7 )&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(4,5)], color=&apos;red&apos;)&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2,{&apos;color&apos;:&apos;blue&apos;}), (2,3,{&apos;weight&apos;:8})])&#xA;&gt;&gt;&gt; G[1][2][&apos;weight&apos;] = 4.7&#xA;&gt;&gt;&gt; G.edge[1][2][&apos;weight&apos;] = 4&#xA;&#xA;**Shortcuts:**&#xA;&#xA;Many common graph features allow python syntax to speed reporting.&#xA;&#xA;&gt;&gt;&gt; 1 in G     # check if node in graph&#xA;True&#xA;&gt;&gt;&gt; [n for n in G if n&lt;3]   # iterate through nodes&#xA;[1, 2]&#xA;&gt;&gt;&gt; len(G)  # number of nodes in graph&#xA;5&#xA;&gt;&gt;&gt; G[1] # adjacency dict keyed by neighbor to edge attributes&#xA;...            # Note: you should not change this dict manually!&#xA;{2: {&apos;color&apos;: &apos;blue&apos;, &apos;weight&apos;: 4}}&#xA;&#xA;The fastest way to traverse all edges of a graph is via&#xA;adjacency_iter(), but the edges() method is often more convenient.&#xA;&#xA;&gt;&gt;&gt; for n,nbrsdict in G.adjacency_iter():&#xA;...     for nbr,eattr in nbrsdict.items():&#xA;...        if &apos;weight&apos; in eattr:&#xA;...            (n,nbr,eattr[&apos;weight&apos;])&#xA;(1, 2, 4)&#xA;(2, 3, 8)&#xA;&gt;&gt;&gt; [ (u,v,edata[&apos;weight&apos;]) for u,v,edata in G.edges(data=True) if &apos;weight&apos; in edata ]&#xA;[(1, 2, 4), (2, 3, 8)]&#xA;&#xA;**Reporting:**&#xA;&#xA;Simple graph information is obtained using methods.&#xA;Iterator versions of many reporting methods exist for efficiency.&#xA;Methods exist for reporting nodes(), edges(), neighbors() and degree()&#xA;as well as the number of nodes and edges.&#xA;&#xA;For details on these and other miscellaneous methods, see below." ilk="class" line="17" lineend="1239" name="DiGraph"><scope attributes="__ctor__" doc="Initialize a graph with edges, name, graph attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;name : string, optional (default=&apos;&apos;)&#xA;    An optional name for the graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;convert&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G = nx.Graph(name=&apos;my graph&apos;)&#xA;&gt;&gt;&gt; e = [(1,2),(2,3),(3,4)] # list of edges&#xA;&gt;&gt;&gt; G = nx.Graph(e)&#xA;&#xA;Arbitrary graph attribute pairs (key=value) may be assigned&#xA;&#xA;&gt;&gt;&gt; G=nx.Graph(e, day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;" ilk="function" line="168" lineend="216" name="__init__" signature="DiGraph(data=None, **attr)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="data" /><variable attributes="kwargs" ilk="argument" name="attr" /></scope><variable attributes="__instancevar__" citdl="dict" line="202" name="graph" /><variable attributes="__instancevar__" citdl="dict" line="203" name="node" /><variable attributes="__instancevar__" citdl="dict" line="207" name="adj" /><variable attributes="__instancevar__" citdl="dict" line="208" name="pred" /><variable attributes="__instancevar__" citdl="dict" line="209" name="succ" /><variable attributes="__instancevar__" citdl="dict" line="216" name="edge" /><scope doc="Add a single node n and update node attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;    A node can be any hashable Python object except None.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of node attributes.  Key/value pairs will&#xA;    update existing data associated with the node.&#xA;attr : keyword arguments, optional&#xA;    Set or change attributes using key=value.&#xA;&#xA;See Also&#xA;--------&#xA;add_nodes_from&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&gt;&gt;&gt; G.add_node(&apos;Hello&apos;)&#xA;&gt;&gt;&gt; K3 = nx.Graph([(0,1),(1,2),(2,0)])&#xA;&gt;&gt;&gt; G.add_node(K3)&#xA;&gt;&gt;&gt; G.number_of_nodes()&#xA;3&#xA;&#xA;Use keywords set/change node attributes:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1,size=10)&#xA;&gt;&gt;&gt; G.add_node(3,weight=0.4,UTM=(&apos;13S&apos;,382871,3972649))&#xA;&#xA;Notes&#xA;-----&#xA;A hashable object is one that can be used as a key in a Python&#xA;dictionary. This includes strings, numbers, tuples of strings&#xA;and numbers, etc.&#xA;&#xA;On many platforms hashable items also include mutables such as&#xA;NetworkX Graphs, though one should be careful that the hash&#xA;doesn&apos;t change on mutables." ilk="function" line="219" lineend="275" name="add_node" signature="add_node(n, attr_dict=None, **attr)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /></scope><scope doc="Add multiple nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes (list, dict, set, etc.).&#xA;    OR&#xA;    A container of (node, attribute dict) tuples.&#xA;    Node attributes are updated using the attribute dict.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Update attributes for all nodes in nodes.&#xA;    Node attributes specified in nodes as a tuple&#xA;    take precedence over attributes specified generally.&#xA;&#xA;See Also&#xA;--------&#xA;add_node&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_nodes_from(&apos;Hello&apos;)&#xA;&gt;&gt;&gt; K3 = nx.Graph([(0,1),(1,2),(2,0)])&#xA;&gt;&gt;&gt; G.add_nodes_from(K3)&#xA;&gt;&gt;&gt; sorted(G.nodes(),key=str)&#xA;[0, 1, 2, &apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;]&#xA;&#xA;Use keywords to update specific node attributes for every node.&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([1,2], size=10)&#xA;&gt;&gt;&gt; G.add_nodes_from([3,4], weight=0.4)&#xA;&#xA;Use (node, attrdict) tuples to update attributes for specific&#xA;nodes.&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([(1,dict(size=11)), (2,{&apos;color&apos;:&apos;blue&apos;})])&#xA;&gt;&gt;&gt; G.node[1][&apos;size&apos;]&#xA;11&#xA;&gt;&gt;&gt; H = nx.Graph()&#xA;&gt;&gt;&gt; H.add_nodes_from(G.nodes(data=True))&#xA;&gt;&gt;&gt; H.node[1][&apos;size&apos;]&#xA;11&#xA;" ilk="function" line="278" lineend="344" name="add_nodes_from" signature="add_nodes_from(nodes, **attr)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="bool" line="325" name="newnode" /><variable citdl="attr.copy()" line="331" name="newdict" /><variable line="335" name="olddict" /></scope><scope doc="Remove node n.&#xA;&#xA;Removes the node n and all adjacent edges.&#xA;Attempting to remove a non-existent node will raise an exception.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;   A node in the graph&#xA;&#xA;Raises&#xA;-------&#xA;NetworkXError&#xA;   If n is not in the graph.&#xA;&#xA;See Also&#xA;--------&#xA;remove_nodes_from&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; G.edges()&#xA;[(0, 1), (1, 2)]&#xA;&gt;&gt;&gt; G.remove_node(1)&#xA;&gt;&gt;&gt; G.edges()&#xA;[]&#xA;" ilk="function" line="346" lineend="387" name="remove_node" signature="remove_node(n)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /><variable line="378" name="nbrs" /></scope><scope doc="Remove multiple nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes (list, dict, set, etc.).  If a node&#xA;    in the container is not in the graph it is silently&#xA;    ignored.&#xA;&#xA;See Also&#xA;--------&#xA;remove_node&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; e = G.nodes()&#xA;&gt;&gt;&gt; e&#xA;[0, 1, 2]&#xA;&gt;&gt;&gt; G.remove_nodes_from(e)&#xA;&gt;&gt;&gt; G.nodes()&#xA;[]&#xA;" ilk="function" line="390" lineend="427" name="remove_nodes_from" signature="remove_nodes_from(nbunch)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable line="418" name="succs" /></scope><scope doc="Add an edge between u and v.&#xA;&#xA;The nodes u and v will be automatically added if they are&#xA;not already in the graph.&#xA;&#xA;Edge attributes can be specified with keywords or by providing&#xA;a dictionary with key/value pairs.  See examples below.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;    Nodes must be hashable (and not None) Python objects.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with the edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;See Also&#xA;--------&#xA;add_edges_from : add a collection of edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding an edge that already exists updates the edge data.&#xA;&#xA;Many NetworkX algorithms designed for weighted graphs use as&#xA;the edge weight a numerical value assigned to a keyword&#xA;which by default is &apos;weight&apos;.&#xA;&#xA;Examples&#xA;--------&#xA;The following all add the edge e=(1,2) to graph G:&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.add_edge(1, 2)           # explicit two-node form&#xA;&gt;&gt;&gt; G.add_edge(*e)             # single edge as tuple of two nodes&#xA;&gt;&gt;&gt; G.add_edges_from( [(1,2)] ) # add edges from iterable container&#xA;&#xA;Associate data to edges using keywords:&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=3)&#xA;&gt;&gt;&gt; G.add_edge(1, 3, weight=7, capacity=15, length=342.7)" ilk="function" line="430" lineend="500" name="add_edge" signature="add_edge(u, v, attr_dict=None, **attr)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable line="497" name="datadict" /></scope><scope doc="Add all the edges in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch : container of edges&#xA;    Each edge given in the container will be added to the&#xA;    graph. The edges must be given as as 2-tuples (u,v) or&#xA;    3-tuples (u,v,d) where d is a dictionary containing edge&#xA;    data.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with each edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;&#xA;See Also&#xA;--------&#xA;add_edge : add a single edge&#xA;add_weighted_edges_from : convenient way to add weighted edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding the same edge twice has no effect but any edge data&#xA;will be updated when each duplicate edge is added.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edges_from([(0,1),(1,2)]) # using a list of edge tuples&#xA;&gt;&gt;&gt; e = zip(range(0,3),range(1,4))&#xA;&gt;&gt;&gt; G.add_edges_from(e) # Add the path graph 0-1-2-3&#xA;&#xA;Associate data to edges&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(2,3)], weight=3)&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(1,4)], label=&apos;WN2898&apos;)" ilk="function" line="502" lineend="575" name="add_edges_from" signature="add_edges_from(ebunch, attr_dict=None, **attr)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="len()" line="553" name="ne" /><variable citdl="dict" line="559" name="dd" /><variable line="571" name="datadict" /></scope><scope doc="Remove the edge between u and v.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v: nodes&#xA;    Remove the edge between nodes u and v.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If there is not an edge between u and v.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edges_from : remove a collection of edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.remove_edge(0,1)&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.remove_edge(*e) # unpacks e from an edge tuple&#xA;&gt;&gt;&gt; e = (2,3,{&apos;weight&apos;:7}) # an edge with attribute data&#xA;&gt;&gt;&gt; G.remove_edge(*e[:2]) # select first part of edge tuple" ilk="function" line="578" lineend="609" name="remove_edge" signature="remove_edge(u, v)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Remove all edges specified in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch: list or container of edge tuples&#xA;    Each edge given in the list or container will be removed&#xA;    from the graph. The edges can be:&#xA;&#xA;        - 2-tuples (u,v) edge between u and v.&#xA;        - 3-tuples (u,v,k) where k is ignored.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edge : remove a single edge&#xA;&#xA;Notes&#xA;-----&#xA;Will fail silently if an edge in ebunch is not in the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; ebunch=[(1,2),(2,3)]&#xA;&gt;&gt;&gt; G.remove_edges_from(ebunch)" ilk="function" line="612" lineend="643" name="remove_edges_from" signature="remove_edges_from(ebunch)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /></scope><scope doc="Return True if node u has successor v.&#xA;&#xA;This is true if graph has the edge u-&gt;v." ilk="function" line="646" lineend="651" name="has_successor" returns="bool" signature="has_successor(u, v)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Return True if node u has predecessor v.&#xA;&#xA;This is true if graph has the edge u&lt;-v." ilk="function" line="653" lineend="658" name="has_predecessor" returns="bool" signature="has_predecessor(u, v)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Return an iterator over successor nodes of n.&#xA;&#xA;neighbors_iter() and successors_iter() are the same." ilk="function" line="660" lineend="668" name="successors_iter" returns="iter()" signature="successors_iter(n)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return an iterator over predecessor nodes of n." ilk="function" line="670" lineend="675" name="predecessors_iter" returns="iter()" signature="predecessors_iter(n)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return a list of successor nodes of n.&#xA;&#xA;neighbors() and successors() are the same function." ilk="function" line="677" lineend="682" name="successors" returns="list()" signature="successors(n)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return a list of predecessor nodes of n." ilk="function" line="684" lineend="686" name="predecessors" returns="list()" signature="predecessors(n)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><variable citdl="DiGraph.successors" line="690" name="neighbors" /><variable citdl="DiGraph.successors_iter" line="691" name="neighbors_iter" /><scope doc="Return an iterator over the edges.&#xA;&#xA;Edges are returned as tuples with optional data&#xA;in the order (node, neighbor, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict in 3-tuple (u,v,data).&#xA;&#xA;Returns&#xA;-------&#xA;edge_iter : iterator&#xA;    An iterator of (u,v) or (u,v,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges : return a list of edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [e for e in G.edges_iter()]&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(data=True)) # default data is {} (empty dict)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; list(G.edges_iter([0,2]))&#xA;[(0, 1), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(0))&#xA;[(0, 1)]&#xA;" ilk="function" line="693" lineend="746" name="edges_iter" signature="edges_iter(nbunch=None, data=False)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="self.adj.items()" line="736" name="nodes_nbrs" /></scope><variable citdl="DiGraph.edges_iter" line="749" name="out_edges_iter" /><variable citdl="Graph.edges" line="750" name="out_edges" /><scope doc="Return an iterator over the incoming edges.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict in 3-tuple (u,v,data).&#xA;&#xA;Returns&#xA;-------&#xA;in_edge_iter : iterator&#xA;    An iterator of (u,v) or (u,v,d) tuples of incoming edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges_iter : return an iterator of edges" ilk="function" line="752" lineend="783" name="in_edges_iter" signature="in_edges_iter(nbunch=None, data=False)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="self.pred.items()" line="773" name="nodes_nbrs" /></scope><scope doc="Return a list of the incoming edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges : return a list of edges" ilk="function" line="785" lineend="792" name="in_edges" returns="list()" signature="in_edges(nbunch=None, data=False)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return an iterator for (node, degree).&#xA;&#xA;The node degree is the number of edges adjacent to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree, in_degree, out_degree, in_degree_iter, out_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.degree_iter([0,1]))&#xA;[(0, 1), (1, 2)]&#xA;" ilk="function" line="794" lineend="844" name="degree_iter" signature="degree_iter(nbunch=None, weight=None)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="zip()" line="830" name="nodes_nbrs" /></scope><scope doc="Return an iterator for (node, in-degree).&#xA;&#xA;The node in-degree is the number of edges pointing in to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, in-degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree, in_degree, out_degree, out_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.in_degree_iter(0)) # node 0 with degree 0&#xA;[(0, 0)]&#xA;&gt;&gt;&gt; list(G.in_degree_iter([0,1]))&#xA;[(0, 0), (1, 1)]&#xA;" ilk="function" line="847" lineend="893" name="in_degree_iter" signature="in_degree_iter(nbunch=None, weight=None)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.pred.items()" line="883" name="nodes_nbrs" /></scope><scope doc="Return an iterator for (node, out-degree).&#xA;&#xA;The node out-degree is the number of edges pointing out of the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, out-degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree, in_degree, out_degree, in_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.out_degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.out_degree_iter([0,1]))&#xA;[(0, 1), (1, 1)]&#xA;" ilk="function" line="896" lineend="942" name="out_degree_iter" signature="out_degree_iter(nbunch=None, weight=None)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.succ.items()" line="932" name="nodes_nbrs" /></scope><scope doc="Return the in-degree of a node or nodes.&#xA;&#xA;The node in-degree is the number of edges pointing in to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd : dictionary, or number&#xA;    A dictionary with nodes as keys and in-degree as values or&#xA;    a number if a single node is specified.&#xA;&#xA;See Also&#xA;--------&#xA;degree, out_degree, in_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.in_degree(0)&#xA;0&#xA;&gt;&gt;&gt; G.in_degree([0,1])&#xA;{0: 0, 1: 1}&#xA;&gt;&gt;&gt; list(G.in_degree([0,1]).values())&#xA;[0, 1]" ilk="function" line="945" lineend="985" name="in_degree" returns="dict()" signature="in_degree(nbunch=None, weight=None)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /></scope><scope doc="Return the out-degree of a node or nodes.&#xA;&#xA;The node out-degree is the number of edges pointing out of the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd : dictionary, or number&#xA;    A dictionary with nodes as keys and out-degree as values or&#xA;    a number if a single node is specified.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.out_degree(0)&#xA;1&#xA;&gt;&gt;&gt; G.out_degree([0,1])&#xA;{0: 1, 1: 1}&#xA;&gt;&gt;&gt; list(G.out_degree([0,1]).values())&#xA;[1, 1]&#xA;&#xA;" ilk="function" line="987" lineend="1025" name="out_degree" returns="dict()" signature="out_degree(nbunch=None, weight=None)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /></scope><scope doc="Remove all nodes and edges from the graph.&#xA;&#xA;This also removes the name, and all graph, node, and edge attributes.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.clear()&#xA;&gt;&gt;&gt; G.nodes()&#xA;[]&#xA;&gt;&gt;&gt; G.edges()&#xA;[]&#xA;" ilk="function" line="1027" lineend="1046" name="clear" signature="clear()"><variable citdl="DiGraph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is a multigraph, False otherwise." ilk="function" line="1049" lineend="1051" name="is_multigraph" returns="bool" signature="is_multigraph()"><variable citdl="DiGraph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is directed, False otherwise." ilk="function" line="1054" lineend="1056" name="is_directed" returns="bool" signature="is_directed()"><variable citdl="DiGraph" ilk="argument" name="self" /></scope><scope doc="Return a directed copy of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : DiGraph&#xA;    A deepcopy of the graph.&#xA;&#xA;Notes&#xA;-----&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar D=DiGraph(G) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 0)]&#xA;&#xA;If already directed, return a (deep) copy&#xA;&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1)]" ilk="function" line="1058" lineend="1094" name="to_directed" returns="deepcopy()" signature="to_directed()"><variable citdl="DiGraph" ilk="argument" name="self" /></scope><scope doc="Return an undirected representation of the digraph.&#xA;&#xA;Parameters&#xA;----------&#xA;reciprocal : bool (optional)&#xA;  If True only keep edges that appear in both directions &#xA;  in the original digraph. &#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    An undirected graph with the same name and nodes and&#xA;    with edge (u,v,data) if either (u,v,data) or (v,u,data)&#xA;    is in the digraph.  If both edges exist in digraph and&#xA;    their edge data is different, only one edge is created&#xA;    with an arbitrary choice of which edge data to use.&#xA;    You must check and correct for this manually if desired.&#xA;&#xA;Notes&#xA;-----&#xA;If edges in both directions (u,v) and (v,u) exist in the&#xA;graph, attributes for the new undirected edge will be a combination of&#xA;the attributes of the directed edges.  The edge data is updated&#xA;in the (arbitrary) order that the edges are encountered.  For&#xA;more customized control of the edge attributes use add_edge().&#xA;&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar G=DiGraph(D) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html." ilk="function" line="1096" lineend="1147" name="to_undirected" returns="Graph()" signature="to_undirected(reciprocal=False)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="reciprocal" /><variable citdl="Graph()" line="1133" name="H" /></scope><scope doc="Return the reverse of the graph.&#xA;&#xA;The reverse is a graph with the same nodes and edges&#xA;but with the directions of the edges reversed.&#xA;&#xA;Parameters&#xA;----------&#xA;copy : bool optional (default=True)&#xA;    If True, return a new DiGraph holding the reversed edges.&#xA;    If False, reverse the reverse graph is created using&#xA;    the original graph (this changes the original graph)." ilk="function" line="1150" lineend="1174" name="reverse" returns="self.__class__()" signature="reverse(copy=True)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable citdl="True" ilk="argument" name="copy" /><variable citdl="DiGraph" line="1164" name="H" /></scope><scope doc="Return the subgraph induced on nodes in nbunch.&#xA;&#xA;The induced subgraph of the graph contains the nodes in nbunch&#xA;and the edges between those nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : list, iterable&#xA;    A container of nodes which will be iterated through once.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    A subgraph of the graph with the same edge attributes.&#xA;&#xA;Notes&#xA;-----&#xA;The graph, edge or node attributes just point to the original graph.&#xA;So changes to the node or edge structure will not be reflected in&#xA;the original graph while changes to the attributes will.&#xA;&#xA;To create a subgraph with its own copy of the edge/node attributes use:&#xA;nx.Graph(G.subgraph(nbunch))&#xA;&#xA;If edge attributes are containers, a deep copy can be obtained using:&#xA;G.subgraph(nbunch).copy()&#xA;&#xA;For an inplace reduction of a graph to a subgraph you can remove nodes:&#xA;G.remove_nodes_from([ n in G if n not in set(nbunch)])&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; H = G.subgraph([0,1,2])&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 2)]" ilk="function" line="1177" lineend="1239" name="subgraph" returns="self.__class__()" signature="subgraph(nbunch)"><variable citdl="DiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="self.nbunch_iter()" line="1216" name="bunch" /><variable citdl="self.__class__()" line="1218" name="H" /><variable citdl="H.succ" line="1223" name="H_succ" /><variable citdl="H.pred" line="1224" name="H_pred" /><variable citdl="dict" line="1225" name="self_succ" /><variable line="1232" name="Hnbrs" /></scope></scope></scope>