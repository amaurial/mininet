<scope doc="Base class for undirected graphs." ilk="blob" lang="Python" name="graph" src="/usr/lib/pymodules/python2.7/networkx/classes/graph.py"><import line="16" module="copy" symbol="deepcopy" /><import alias="nx" line="17" module="networkx" /><import line="18" module="networkx.exception" symbol="NetworkXError" /><import alias="convert" line="19" module="networkx.convert" /><variable citdl="__builtins__.str.join()" line="21" name="__author__" /><scope classrefs="object" doc="Base class for undirected graphs.&#xA;&#xA;A Graph stores nodes and edges with optional data, or attributes.&#xA;&#xA;Graphs hold undirected edges.  Self loops are allowed but multiple&#xA;(parallel) edges are not.&#xA;&#xA;Nodes can be arbitrary (hashable) Python objects with optional&#xA;key/value attributes.&#xA;&#xA;Edges are represented as links between nodes with optional&#xA;key/value attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;DiGraph&#xA;MultiGraph&#xA;MultiDiGraph&#xA;&#xA;Examples&#xA;--------&#xA;Create an empty graph structure (a &quot;null graph&quot;) with no nodes and&#xA;no edges.&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()&#xA;&#xA;G can be grown in several ways.&#xA;&#xA;**Nodes:**&#xA;&#xA;Add one node at a time:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&#xA;Add the nodes from any container (a list, dict, set or&#xA;even the lines from a file or the nodes from another graph).&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([2,3])&#xA;&gt;&gt;&gt; G.add_nodes_from(range(100,110))&#xA;&gt;&gt;&gt; H=nx.Graph()&#xA;&gt;&gt;&gt; H.add_path([0,1,2,3,4,5,6,7,8,9])&#xA;&gt;&gt;&gt; G.add_nodes_from(H)&#xA;&#xA;In addition to strings and integers any hashable Python object&#xA;(except None) can represent a node, e.g. a customized node object,&#xA;or even another Graph.&#xA;&#xA;&gt;&gt;&gt; G.add_node(H)&#xA;&#xA;**Edges:**&#xA;&#xA;G can also be grown by adding edges.&#xA;&#xA;Add one edge,&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2)&#xA;&#xA;a list of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,3)])&#xA;&#xA;or a collection of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from(H.edges())&#xA;&#xA;If some edges connect nodes not yet in the graph, the nodes&#xA;are added automatically.  There are no errors when adding&#xA;nodes or edges that already exist.&#xA;&#xA;**Attributes:**&#xA;&#xA;Each graph, node, and edge can hold key/value attribute pairs&#xA;in an associated attribute dictionary (the keys must be hashable).&#xA;By default these are empty, but can be added or changed using&#xA;add_edge, add_node or direct manipulation of the attribute&#xA;dictionaries named graph, node and edge respectively.&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph(day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;&#xA;Add node attributes using add_node(), add_nodes_from() or G.node&#xA;&#xA;&gt;&gt;&gt; G.add_node(1, time=&apos;5pm&apos;)&#xA;&gt;&gt;&gt; G.add_nodes_from([3], time=&apos;2pm&apos;)&#xA;&gt;&gt;&gt; G.node[1]&#xA;{&apos;time&apos;: &apos;5pm&apos;}&#xA;&gt;&gt;&gt; G.node[1][&apos;room&apos;] = 714&#xA;&gt;&gt;&gt; del G.node[1][&apos;room&apos;] # remove attribute&#xA;&gt;&gt;&gt; G.nodes(data=True)&#xA;[(1, {&apos;time&apos;: &apos;5pm&apos;}), (3, {&apos;time&apos;: &apos;2pm&apos;})]&#xA;&#xA;Warning: adding a node to G.node does not add it to the graph.&#xA;&#xA;Add edge attributes using add_edge(), add_edges_from(), subscript&#xA;notation, or G.edge.&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=4.7 )&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(4,5)], color=&apos;red&apos;)&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2,{&apos;color&apos;:&apos;blue&apos;}), (2,3,{&apos;weight&apos;:8})])&#xA;&gt;&gt;&gt; G[1][2][&apos;weight&apos;] = 4.7&#xA;&gt;&gt;&gt; G.edge[1][2][&apos;weight&apos;] = 4&#xA;&#xA;**Shortcuts:**&#xA;&#xA;Many common graph features allow python syntax to speed reporting.&#xA;&#xA;&gt;&gt;&gt; 1 in G     # check if node in graph&#xA;True&#xA;&gt;&gt;&gt; [n for n in G if n&lt;3]   # iterate through nodes&#xA;[1, 2]&#xA;&gt;&gt;&gt; len(G)  # number of nodes in graph&#xA;5&#xA;&gt;&gt;&gt; G[1] # adjacency dict keyed by neighbor to edge attributes&#xA;...            # Note: you should not change this dict manually!&#xA;{2: {&apos;color&apos;: &apos;blue&apos;, &apos;weight&apos;: 4}}&#xA;&#xA;The fastest way to traverse all edges of a graph is via&#xA;adjacency_iter(), but the edges() method is often more convenient.&#xA;&#xA;&gt;&gt;&gt; for n,nbrsdict in G.adjacency_iter():&#xA;...     for nbr,eattr in nbrsdict.items():&#xA;...        if &apos;weight&apos; in eattr:&#xA;...            (n,nbr,eattr[&apos;weight&apos;])&#xA;(1, 2, 4)&#xA;(2, 1, 4)&#xA;(2, 3, 8)&#xA;(3, 2, 8)&#xA;&gt;&gt;&gt; [ (u,v,edata[&apos;weight&apos;]) for u,v,edata in G.edges(data=True) if &apos;weight&apos; in edata ]&#xA;[(1, 2, 4), (2, 3, 8)]&#xA;&#xA;**Reporting:**&#xA;&#xA;Simple graph information is obtained using methods.&#xA;Iterator versions of many reporting methods exist for efficiency.&#xA;Methods exist for reporting nodes(), edges(), neighbors() and degree()&#xA;as well as the number of nodes and edges.&#xA;&#xA;For details on these and other miscellaneous methods, see below." ilk="class" line="25" lineend="1819" name="Graph"><scope attributes="__ctor__" doc="Initialize a graph with edges, name, graph attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;name : string, optional (default=&apos;&apos;)&#xA;    An optional name for the graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;convert&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G = nx.Graph(name=&apos;my graph&apos;)&#xA;&gt;&gt;&gt; e = [(1,2),(2,3),(3,4)] # list of edges&#xA;&gt;&gt;&gt; G = nx.Graph(e)&#xA;&#xA;Arbitrary graph attribute pairs (key=value) may be assigned&#xA;&#xA;&gt;&gt;&gt; G=nx.Graph(e, day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;" ilk="function" line="178" lineend="220" name="__init__" signature="Graph(data=None, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="data" /><variable attributes="kwargs" ilk="argument" name="attr" /></scope><variable attributes="__instancevar__" citdl="dict" line="212" name="graph" /><variable attributes="__instancevar__" citdl="dict" line="213" name="node" /><variable attributes="__instancevar__" citdl="dict" line="214" name="adj" /><variable attributes="__instancevar__" citdl="dict" line="220" name="edge" /><variable attributes="property" citdl="str" line="223" name="name" /><scope attributes="__hidden__" ilk="function" line="223" lineend="224" name="name (property getter)" returns="self.graph.get()" signature="name (property getter)()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope attributes="__hidden__" ilk="function" line="226" lineend="227" name="name (property setter)" signature="name (property setter)(s)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="s" /></scope><scope doc="Return the graph name.&#xA;&#xA;Returns&#xA;-------&#xA;name : string&#xA;    The name of the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph(name=&apos;foo&apos;)&#xA;&gt;&gt;&gt; str(G)&#xA;&apos;foo&apos;" ilk="function" line="229" lineend="243" name="__str__" returns="self.graph.get()" signature="__str__()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Iterate over the nodes. Use the expression &apos;for n in G&apos;.&#xA;&#xA;Returns&#xA;-------&#xA;niter : iterator&#xA;    An iterator over all nodes in the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])" ilk="function" line="245" lineend="258" name="__iter__" returns="iter()" signature="__iter__()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return True if n is a node, False otherwise. Use the expression&#xA;&apos;n in G&apos;.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; 1 in G&#xA;True" ilk="function" line="260" lineend="274" name="__contains__" returns="bool" signature="__contains__(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return the number of nodes. Use the expression &apos;len(G)&apos;.&#xA;&#xA;Returns&#xA;-------&#xA;nnodes : int&#xA;    The number of nodes in the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; len(G)&#xA;4&#xA;" ilk="function" line="276" lineend="292" name="__len__" returns="len()" signature="__len__()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return a dict of neighbors of node n.  Use the expression &apos;G[n]&apos;.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;   A node in the graph.&#xA;&#xA;Returns&#xA;-------&#xA;adj_dict : dictionary&#xA;   The adjacency dictionary for nodes connected to n.&#xA;&#xA;Notes&#xA;-----&#xA;G[n] is similar to G.neighbors(n) but the internal data dictionary&#xA;is returned instead of a list.&#xA;&#xA;Assigning G[n] will corrupt the internal graph data structure.&#xA;Use G[n] for reading data only.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G[0]&#xA;{1: {}}" ilk="function" line="294" lineend="322" name="__getitem__" signature="__getitem__(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Add a single node n and update node attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;    A node can be any hashable Python object except None.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of node attributes.  Key/value pairs will&#xA;    update existing data associated with the node.&#xA;attr : keyword arguments, optional&#xA;    Set or change attributes using key=value.&#xA;&#xA;See Also&#xA;--------&#xA;add_nodes_from&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&gt;&gt;&gt; G.add_node(&apos;Hello&apos;)&#xA;&gt;&gt;&gt; K3 = nx.Graph([(0,1),(1,2),(2,0)])&#xA;&gt;&gt;&gt; G.add_node(K3)&#xA;&gt;&gt;&gt; G.number_of_nodes()&#xA;3&#xA;&#xA;Use keywords set/change node attributes:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1,size=10)&#xA;&gt;&gt;&gt; G.add_node(3,weight=0.4,UTM=(&apos;13S&apos;,382871,3972649))&#xA;&#xA;Notes&#xA;-----&#xA;A hashable object is one that can be used as a key in a Python&#xA;dictionary. This includes strings, numbers, tuples of strings&#xA;and numbers, etc.&#xA;&#xA;On many platforms hashable items also include mutables such as&#xA;NetworkX Graphs, though one should be careful that the hash&#xA;doesn&apos;t change on mutables." ilk="function" line="325" lineend="380" name="add_node" signature="add_node(n, attr_dict=None, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /></scope><scope doc="Add multiple nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes (list, dict, set, etc.).&#xA;    OR&#xA;    A container of (node, attribute dict) tuples.&#xA;    Node attributes are updated using the attribute dict.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Update attributes for all nodes in nodes.&#xA;    Node attributes specified in nodes as a tuple&#xA;    take precedence over attributes specified generally.&#xA;&#xA;See Also&#xA;--------&#xA;add_node&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_nodes_from(&apos;Hello&apos;)&#xA;&gt;&gt;&gt; K3 = nx.Graph([(0,1),(1,2),(2,0)])&#xA;&gt;&gt;&gt; G.add_nodes_from(K3)&#xA;&gt;&gt;&gt; sorted(G.nodes(),key=str)&#xA;[0, 1, 2, &apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;]&#xA;&#xA;Use keywords to update specific node attributes for every node.&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([1,2], size=10)&#xA;&gt;&gt;&gt; G.add_nodes_from([3,4], weight=0.4)&#xA;&#xA;Use (node, attrdict) tuples to update attributes for specific&#xA;nodes.&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([(1,dict(size=11)), (2,{&apos;color&apos;:&apos;blue&apos;})])&#xA;&gt;&gt;&gt; G.node[1][&apos;size&apos;]&#xA;11&#xA;&gt;&gt;&gt; H = nx.Graph()&#xA;&gt;&gt;&gt; H.add_nodes_from(G.nodes(data=True))&#xA;&gt;&gt;&gt; H.node[1][&apos;size&apos;]&#xA;11&#xA;" ilk="function" line="383" lineend="447" name="add_nodes_from" signature="add_nodes_from(nodes, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="bool" line="430" name="newnode" /><variable citdl="attr.copy()" line="435" name="newdict" /><variable line="439" name="olddict" /></scope><scope doc="Remove node n.&#xA;&#xA;Removes the node n and all adjacent edges.&#xA;Attempting to remove a non-existent node will raise an exception.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;   A node in the graph&#xA;&#xA;Raises&#xA;-------&#xA;NetworkXError&#xA;   If n is not in the graph.&#xA;&#xA;See Also&#xA;--------&#xA;remove_nodes_from&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; G.edges()&#xA;[(0, 1), (1, 2)]&#xA;&gt;&gt;&gt; G.remove_node(1)&#xA;&gt;&gt;&gt; G.edges()&#xA;[]&#xA;" ilk="function" line="449" lineend="488" name="remove_node" signature="remove_node(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /><variable citdl="dict" line="480" name="adj" /><variable citdl="list()" line="482" name="nbrs" /></scope><scope doc="Remove multiple nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes (list, dict, set, etc.).  If a node&#xA;    in the container is not in the graph it is silently&#xA;    ignored.&#xA;&#xA;See Also&#xA;--------&#xA;remove_node&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; e = G.nodes()&#xA;&gt;&gt;&gt; e&#xA;[0, 1, 2]&#xA;&gt;&gt;&gt; G.remove_nodes_from(e)&#xA;&gt;&gt;&gt; G.nodes()&#xA;[]&#xA;" ilk="function" line="491" lineend="525" name="remove_nodes_from" signature="remove_nodes_from(nodes)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable citdl="dict" line="517" name="adj" /></scope><scope doc="Return an iterator over the nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : boolean, optional (default=False)&#xA;       If False the iterator returns nodes.  If True&#xA;       return a two-tuple of node and node data dictionary&#xA;&#xA;Returns&#xA;-------&#xA;niter : iterator&#xA;    An iterator over nodes.  If data=True the iterator gives&#xA;    two-tuples containing (node, node data, dictionary)&#xA;&#xA;Notes&#xA;-----&#xA;If the node data is not required it is simpler and equivalent&#xA;to use the expression &apos;for n in G&apos;.&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&#xA;&gt;&gt;&gt; [d for n,d in G.nodes_iter(data=True)]&#xA;[{}, {}, {}]" ilk="function" line="528" lineend="561" name="nodes_iter" returns="iter()" signature="nodes_iter(data=False)"><variable citdl="Graph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return a list of the nodes in the graph.&#xA;&#xA;Parameters&#xA;----------&#xA;data : boolean, optional (default=False)&#xA;       If False return a list of nodes.  If True return a&#xA;       two-tuple of node and node data dictionary&#xA;&#xA;Returns&#xA;-------&#xA;nlist : list&#xA;    A list of nodes.  If data=True a list of two-tuples containing&#xA;    (node, node data dictionary).&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; G.nodes()&#xA;[0, 1, 2]&#xA;&gt;&gt;&gt; G.add_node(1, time=&apos;5pm&apos;)&#xA;&gt;&gt;&gt; G.nodes(data=True)&#xA;[(0, {}), (1, {&apos;time&apos;: &apos;5pm&apos;}), (2, {})]" ilk="function" line="563" lineend="588" name="nodes" returns="list()" signature="nodes(data=False)"><variable citdl="Graph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return the number of nodes in the graph.&#xA;&#xA;Returns&#xA;-------&#xA;nnodes : int&#xA;    The number of nodes in the graph.&#xA;&#xA;See Also&#xA;--------&#xA;order, __len__  which are identical&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; len(G)&#xA;3" ilk="function" line="590" lineend="609" name="number_of_nodes" returns="len()" signature="number_of_nodes()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return the number of nodes in the graph.&#xA;&#xA;Returns&#xA;-------&#xA;nnodes : int&#xA;    The number of nodes in the graph.&#xA;&#xA;See Also&#xA;--------&#xA;number_of_nodes, __len__  which are identical&#xA;" ilk="function" line="611" lineend="624" name="order" returns="len()" signature="order()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return True if the graph contains the node n.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2])&#xA;&gt;&gt;&gt; G.has_node(0)&#xA;True&#xA;&#xA;It is more readable and simpler to use&#xA;&#xA;&gt;&gt;&gt; 0 in G&#xA;True&#xA;" ilk="function" line="626" lineend="649" name="has_node" returns="bool" signature="has_node(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Add an edge between u and v.&#xA;&#xA;The nodes u and v will be automatically added if they are&#xA;not already in the graph.&#xA;&#xA;Edge attributes can be specified with keywords or by providing&#xA;a dictionary with key/value pairs.  See examples below.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;    Nodes must be hashable (and not None) Python objects.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with the edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;See Also&#xA;--------&#xA;add_edges_from : add a collection of edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding an edge that already exists updates the edge data.&#xA;&#xA;Many NetworkX algorithms designed for weighted graphs use as&#xA;the edge weight a numerical value assigned to a keyword&#xA;which by default is &apos;weight&apos;.&#xA;&#xA;Examples&#xA;--------&#xA;The following all add the edge e=(1,2) to graph G:&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.add_edge(1, 2)           # explicit two-node form&#xA;&gt;&gt;&gt; G.add_edge(*e)             # single edge as tuple of two nodes&#xA;&gt;&gt;&gt; G.add_edges_from( [(1,2)] ) # add edges from iterable container&#xA;&#xA;Associate data to edges using keywords:&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=3)&#xA;&gt;&gt;&gt; G.add_edge(1, 3, weight=7, capacity=15, length=342.7)" ilk="function" line="651" lineend="719" name="add_edge" signature="add_edge(u, v, attr_dict=None, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable line="716" name="datadict" /></scope><scope doc="Add all the edges in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch : container of edges&#xA;    Each edge given in the container will be added to the&#xA;    graph. The edges must be given as as 2-tuples (u,v) or&#xA;    3-tuples (u,v,d) where d is a dictionary containing edge&#xA;    data.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with each edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;&#xA;See Also&#xA;--------&#xA;add_edge : add a single edge&#xA;add_weighted_edges_from : convenient way to add weighted edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding the same edge twice has no effect but any edge data&#xA;will be updated when each duplicate edge is added.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edges_from([(0,1),(1,2)]) # using a list of edge tuples&#xA;&gt;&gt;&gt; e = zip(range(0,3),range(1,4))&#xA;&gt;&gt;&gt; G.add_edges_from(e) # Add the path graph 0-1-2-3&#xA;&#xA;Associate data to edges&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(2,3)], weight=3)&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(1,4)], label=&apos;WN2898&apos;)" ilk="function" line="722" lineend="792" name="add_edges_from" signature="add_edges_from(ebunch, attr_dict=None, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="len()" line="773" name="ne" /><variable citdl="dict" line="778" name="dd" /><variable line="788" name="datadict" /></scope><scope doc="Add all the edges in ebunch as weighted edges with specified&#xA;weights.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch : container of edges&#xA;    Each edge given in the list or container will be added&#xA;    to the graph. The edges must be given as 3-tuples (u,v,w)&#xA;    where w is a number.&#xA;weight : string, optional (default= &apos;weight&apos;)&#xA;    The attribute name for the edge weights to be added.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Edge attributes to add/update for all edges.&#xA;&#xA;See Also&#xA;--------&#xA;add_edge : add a single edge&#xA;add_edges_from : add multiple edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding the same edge twice for Graph/DiGraph simply updates &#xA;the edge data.  For MultiGraph/MultiDiGraph, duplicate edges &#xA;are stored.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_weighted_edges_from([(0,1,3.0),(1,2,7.5)])" ilk="function" line="795" lineend="826" name="add_weighted_edges_from" signature="add_weighted_edges_from(ebunch, weight=&apos;weight&apos;, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /><variable citdl="str" ilk="argument" name="weight" /><variable attributes="kwargs" ilk="argument" name="attr" /></scope><scope doc="Remove the edge between u and v.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v: nodes&#xA;    Remove the edge between nodes u and v.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If there is not an edge between u and v.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edges_from : remove a collection of edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.remove_edge(0,1)&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.remove_edge(*e) # unpacks e from an edge tuple&#xA;&gt;&gt;&gt; e = (2,3,{&apos;weight&apos;:7}) # an edge with attribute data&#xA;&gt;&gt;&gt; G.remove_edge(*e[:2]) # select first part of edge tuple" ilk="function" line="828" lineend="860" name="remove_edge" signature="remove_edge(u, v)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Remove all edges specified in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch: list or container of edge tuples&#xA;    Each edge given in the list or container will be removed&#xA;    from the graph. The edges can be:&#xA;&#xA;        - 2-tuples (u,v) edge between u and v.&#xA;        - 3-tuples (u,v,k) where k is ignored.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edge : remove a single edge&#xA;&#xA;Notes&#xA;-----&#xA;Will fail silently if an edge in ebunch is not in the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; ebunch=[(1,2),(2,3)]&#xA;&gt;&gt;&gt; G.remove_edges_from(ebunch)" ilk="function" line="864" lineend="897" name="remove_edges_from" signature="remove_edges_from(ebunch)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /><variable citdl="dict" line="891" name="adj" /></scope><scope doc="Return True if the edge (u,v) is in the graph.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;    Nodes must be hashable (and not None) Python objects.&#xA;&#xA;Returns&#xA;-------&#xA;edge_ind : bool&#xA;    True if edge is in the graph, False otherwise.&#xA;&#xA;Examples&#xA;--------&#xA;Can be called either using two nodes u,v or edge tuple (u,v)&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.has_edge(0,1)  # using two nodes&#xA;True&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.has_edge(*e)  #  e is a 2-tuple (u,v)&#xA;True&#xA;&gt;&gt;&gt; e = (0,1,{&apos;weight&apos;:7})&#xA;&gt;&gt;&gt; G.has_edge(*e[:2])  # e is a 3-tuple (u,v,data_dictionary)&#xA;True&#xA;&#xA;The following syntax are all equivalent:&#xA;&#xA;&gt;&gt;&gt; G.has_edge(0,1)&#xA;True&#xA;&gt;&gt;&gt; 1 in G[0]  # though this gives KeyError if 0 not in G&#xA;True&#xA;" ilk="function" line="900" lineend="940" name="has_edge" returns="bool" signature="has_edge(u, v)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Return a list of the nodes connected to the node n.&#xA;&#xA;Parameters&#xA;----------&#xA;n : node&#xA;   A node in the graph&#xA;&#xA;Returns&#xA;-------&#xA;nlist : list&#xA;    A list of nodes that are adjacent to n.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If the node n is not in the graph.&#xA;&#xA;Notes&#xA;-----&#xA;It is usually more convenient (and faster) to access the&#xA;adjacency dictionary as G[n]:&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(&apos;a&apos;,&apos;b&apos;,weight=7)&#xA;&gt;&gt;&gt; G[&apos;a&apos;]&#xA;{&apos;b&apos;: {&apos;weight&apos;: 7}}&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.neighbors(0)&#xA;[1]&#xA;" ilk="function" line="943" lineend="982" name="neighbors" returns="list()" signature="neighbors(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return an iterator over all neighbors of node n.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [n for n in G.neighbors_iter(0)]&#xA;[1]&#xA;&#xA;Notes&#xA;-----&#xA;It is faster to use the idiom &quot;in G[0]&quot;, e.g.&#xA;&#xA;&gt;&gt;&gt; G = nx.path_graph(4)&#xA;&gt;&gt;&gt; [n for n in G[0]]&#xA;[1]" ilk="function" line="984" lineend="1005" name="neighbors_iter" returns="iter()" signature="neighbors_iter(n)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="n" /></scope><scope doc="Return a list of edges.&#xA;&#xA;Edges are returned as tuples with optional data&#xA;in the order (node, neighbor, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    Return two tuples (u,v) (False) or three-tuples (u,v,data) (True).&#xA;&#xA;Returns&#xA;--------&#xA;edge_list: list of edge tuples&#xA;    Edges that are adjacent to any node in nbunch, or a list&#xA;    of all edges if nbunch is not specified.&#xA;&#xA;See Also&#xA;--------&#xA;edges_iter : return an iterator over the edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.edges()&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; G.edges(data=True) # default edge data is {} (empty dictionary)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; G.edges([0,3])&#xA;[(0, 1), (3, 2)]&#xA;&gt;&gt;&gt; G.edges(0)&#xA;[(0, 1)]&#xA;" ilk="function" line="1007" lineend="1050" name="edges" returns="list()" signature="edges(nbunch=None, data=False)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return an iterator over the edges.&#xA;&#xA;Edges are returned as tuples with optional data&#xA;in the order (node, neighbor, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict in 3-tuple (u,v,data).&#xA;&#xA;Returns&#xA;-------&#xA;edge_iter : iterator&#xA;    An iterator of (u,v) or (u,v,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges : return a list of edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [e for e in G.edges_iter()]&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(data=True)) # default data is {} (empty dict)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; list(G.edges_iter([0,3]))&#xA;[(0, 1), (3, 2)]&#xA;&gt;&gt;&gt; list(G.edges_iter(0))&#xA;[(0, 1)]&#xA;" ilk="function" line="1052" lineend="1111" name="edges_iter" signature="edges_iter(nbunch=None, data=False)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="dict" line="1094" name="seen" /><variable citdl="self.adj.items()" line="1096" name="nodes_nbrs" /></scope><scope doc="Return the attribute dictionary associated with edge (u,v).&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;default:  any Python object (default=None)&#xA;    Value to return if the edge (u,v) is not found.&#xA;&#xA;Returns&#xA;-------&#xA;edge_dict : dictionary&#xA;    The edge attribute dictionary.&#xA;&#xA;Notes&#xA;-----&#xA;It is faster to use G[u][v].&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G[0][1]&#xA;{}&#xA;&#xA;Warning: Assigning G[u][v] corrupts the graph data structure.&#xA;But it is safe to assign attributes to that dictionary,&#xA;&#xA;&gt;&gt;&gt; G[0][1][&apos;weight&apos;] = 7&#xA;&gt;&gt;&gt; G[0][1][&apos;weight&apos;]&#xA;7&#xA;&gt;&gt;&gt; G[1][0][&apos;weight&apos;]&#xA;7&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.get_edge_data(0,1) # default edge data is {}&#xA;{}&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.get_edge_data(*e) # tuple form&#xA;{}&#xA;&gt;&gt;&gt; G.get_edge_data(&apos;a&apos;,&apos;b&apos;,default=0) # edge not in graph, return 0&#xA;0" ilk="function" line="1114" lineend="1161" name="get_edge_data" signature="get_edge_data(u, v, default=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="default" /></scope><scope doc="Return an adjacency list representation of the graph.&#xA;&#xA;The output adjacency list is in the order of G.nodes().&#xA;For directed graphs, only outgoing adjacencies are included.&#xA;&#xA;Returns&#xA;-------&#xA;adj_list : lists of lists&#xA;    The adjacency structure of the graph as a list of lists.&#xA;&#xA;See Also&#xA;--------&#xA;adjacency_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.adjacency_list() # in order given by G.nodes()&#xA;[[1], [0, 2], [1, 3], [2]]&#xA;" ilk="function" line="1163" lineend="1186" name="adjacency_list" returns="list()" signature="adjacency_list()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return an iterator of (node, adjacency dict) tuples for all nodes.&#xA;&#xA;This is the fastest way to look at every edge.&#xA;For directed graphs, only outgoing adjacencies are included.&#xA;&#xA;Returns&#xA;-------&#xA;adj_iter : iterator&#xA;   An iterator of (node, adjacency dictionary) for all nodes in&#xA;   the graph.&#xA;&#xA;See Also&#xA;--------&#xA;adjacency_list&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [(n,nbrdict) for n,nbrdict in G.adjacency_iter()]&#xA;[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]&#xA;" ilk="function" line="1188" lineend="1212" name="adjacency_iter" returns="iter()" signature="adjacency_iter()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return the degree of a node or nodes.&#xA;&#xA;The node degree is the number of edges adjacent to that node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd : dictionary, or number&#xA;    A dictionary with nodes as keys and degree as values or&#xA;    a number if a single node is specified.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.degree(0)&#xA;1&#xA;&gt;&gt;&gt; G.degree([0,1])&#xA;{0: 1, 1: 2}&#xA;&gt;&gt;&gt; list(G.degree([0,1]).values())&#xA;[1, 2]&#xA;" ilk="function" line="1214" lineend="1251" name="degree" returns="dict()" signature="degree(nbunch=None, weight=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /></scope><scope doc="Return an iterator for (node, degree).&#xA;&#xA;The node degree is the number of edges adjacent to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.degree_iter([0,1]))&#xA;[(0, 1), (1, 2)]&#xA;" ilk="function" line="1253" lineend="1300" name="degree_iter" signature="degree_iter(nbunch=None, weight=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.adj.items()" line="1289" name="nodes_nbrs" /></scope><scope doc="Remove all nodes and edges from the graph.&#xA;&#xA;This also removes the name, and all graph, node, and edge attributes.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.clear()&#xA;&gt;&gt;&gt; G.nodes()&#xA;[]&#xA;&gt;&gt;&gt; G.edges()&#xA;[]&#xA;" ilk="function" line="1303" lineend="1322" name="clear" signature="clear()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return a copy of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    A copy of the graph.&#xA;&#xA;See Also&#xA;--------&#xA;to_directed: return a directed copy of the graph.&#xA;&#xA;Notes&#xA;-----&#xA;This makes a complete copy of the graph including all of the&#xA;node or edge attributes.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; H = G.copy()&#xA;" ilk="function" line="1324" lineend="1348" name="copy" returns="deepcopy()" signature="copy()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is a multigraph, False otherwise." ilk="function" line="1350" lineend="1352" name="is_multigraph" returns="bool" signature="is_multigraph()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is directed, False otherwise." ilk="function" line="1355" lineend="1357" name="is_directed" returns="bool" signature="is_directed()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return a directed representation of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : DiGraph&#xA;    A directed graph with the same name, same nodes, and with&#xA;    each edge (u,v,data) replaced by two directed edges&#xA;    (u,v,data) and (v,u,data).&#xA;&#xA;Notes&#xA;-----&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar D=DiGraph(G) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 0)]&#xA;&#xA;If already directed, return a (deep) copy&#xA;&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1)]" ilk="function" line="1359" lineend="1406" name="to_directed" returns="DiGraph()" signature="to_directed()"><import line="1397" module="networkx" symbol="DiGraph" /><variable citdl="Graph" ilk="argument" name="self" /><variable citdl="DiGraph()" line="1398" name="G" /></scope><scope doc="Return an undirected copy of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph/MultiGraph&#xA;    A deepcopy of the graph.&#xA;&#xA;See Also&#xA;--------&#xA;copy, add_edge, add_edges_from&#xA;&#xA;Notes&#xA;-----&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar G=DiGraph(D) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 0)]&#xA;&gt;&gt;&gt; G2 = H.to_undirected()&#xA;&gt;&gt;&gt; G2.edges()&#xA;[(0, 1)]" ilk="function" line="1408" lineend="1443" name="to_undirected" returns="deepcopy()" signature="to_undirected()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return the subgraph induced on nodes in nbunch.&#xA;&#xA;The induced subgraph of the graph contains the nodes in nbunch&#xA;and the edges between those nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : list, iterable&#xA;    A container of nodes which will be iterated through once.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    A subgraph of the graph with the same edge attributes.&#xA;&#xA;Notes&#xA;-----&#xA;The graph, edge or node attributes just point to the original graph.&#xA;So changes to the node or edge structure will not be reflected in&#xA;the original graph while changes to the attributes will.&#xA;&#xA;To create a subgraph with its own copy of the edge/node attributes use:&#xA;nx.Graph(G.subgraph(nbunch))&#xA;&#xA;If edge attributes are containers, a deep copy can be obtained using:&#xA;G.subgraph(nbunch).copy()&#xA;&#xA;For an inplace reduction of a graph to a subgraph you can remove nodes:&#xA;G.remove_nodes_from([ n in G if n not in set(nbunch)])&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; H = G.subgraph([0,1,2])&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 2)]" ilk="function" line="1445" lineend="1503" name="subgraph" returns="self.__class__()" signature="subgraph(nbunch)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="self.nbunch_iter()" line="1484" name="bunch" /><variable citdl="self.__class__()" line="1486" name="H" /><variable citdl="H.adj" line="1491" name="H_adj" /><variable citdl="dict" line="1492" name="self_adj" /><variable citdl="dict" line="1495" name="Hnbrs" /></scope><scope doc="Return a list of nodes with self loops.&#xA;&#xA;A node with a self loop has an edge with both ends adjacent&#xA;to that node.&#xA;&#xA;Returns&#xA;-------&#xA;nodelist : list&#xA;    A list of nodes with self loops.&#xA;&#xA;See Also&#xA;--------&#xA;selfloop_edges, number_of_selfloops&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(1,1)&#xA;&gt;&gt;&gt; G.add_edge(1,2)&#xA;&gt;&gt;&gt; G.nodes_with_selfloops()&#xA;[1]" ilk="function" line="1506" lineend="1529" name="nodes_with_selfloops" returns="list" signature="nodes_with_selfloops()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return a list of selfloop edges.&#xA;&#xA;A selfloop edge has the same node at both ends.&#xA;&#xA;Parameters&#xA;-----------&#xA;data : bool, optional (default=False)&#xA;    Return selfloop edges as two tuples (u,v) (data=False)&#xA;    or three-tuples (u,v,data) (data=True)&#xA;&#xA;Returns&#xA;-------&#xA;edgelist : list of edge tuples&#xA;    A list of all selfloop edges.&#xA;&#xA;See Also&#xA;--------&#xA;nodes_with_selfloops, number_of_selfloops&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(1,1)&#xA;&gt;&gt;&gt; G.add_edge(1,2)&#xA;&gt;&gt;&gt; G.selfloop_edges()&#xA;[(1, 1)]&#xA;&gt;&gt;&gt; G.selfloop_edges(data=True)&#xA;[(1, 1, {})]" ilk="function" line="1531" lineend="1566" name="selfloop_edges" returns="list" signature="selfloop_edges(data=False)"><variable citdl="Graph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return the number of selfloop edges.&#xA;&#xA;A selfloop edge has the same node at both ends.&#xA;&#xA;Returns&#xA;-------&#xA;nloops : int&#xA;    The number of selfloops.&#xA;&#xA;See Also&#xA;--------&#xA;nodes_with_selfloops, selfloop_edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G=nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(1,1)&#xA;&gt;&gt;&gt; G.add_edge(1,2)&#xA;&gt;&gt;&gt; G.number_of_selfloops()&#xA;1" ilk="function" line="1569" lineend="1591" name="number_of_selfloops" returns="len()" signature="number_of_selfloops()"><variable citdl="Graph" ilk="argument" name="self" /></scope><scope doc="Return the number of edges.&#xA;&#xA;Parameters&#xA;----------&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;&#xA;Returns&#xA;-------&#xA;nedges : int&#xA;    The number of edges of sum of edge weights in the graph.&#xA;&#xA;See Also&#xA;--------&#xA;number_of_edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.size()&#xA;3&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(&apos;a&apos;,&apos;b&apos;,weight=2)&#xA;&gt;&gt;&gt; G.add_edge(&apos;b&apos;,&apos;c&apos;,weight=4)&#xA;&gt;&gt;&gt; G.size()&#xA;2&#xA;&gt;&gt;&gt; G.size(weight=&apos;weight&apos;)&#xA;6.0" ilk="function" line="1594" lineend="1631" name="size" returns="int()" signature="size(weight=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="weight" /><variable citdl="sum()" line="1627" name="s" /></scope><scope doc="Return the number of edges between two nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes, optional (default=all edges)&#xA;    If u and v are specified, return the number of edges between&#xA;    u and v. Otherwise return the total number of all edges.&#xA;&#xA;Returns&#xA;-------&#xA;nedges : int&#xA;    The number of edges in the graph.  If nodes u and v are specified&#xA;    return the number of edges between those nodes.&#xA;&#xA;See Also&#xA;--------&#xA;size&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.number_of_edges()&#xA;3&#xA;&gt;&gt;&gt; G.number_of_edges(0,1)&#xA;1&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.number_of_edges(*e)&#xA;1" ilk="function" line="1633" lineend="1668" name="number_of_edges" returns="int()" signature="number_of_edges(u=None, v=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /></scope><scope doc="Add a star.&#xA;&#xA;The first node in nodes is the middle of the star.  It is connected&#xA;to all other nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to every edge in star.&#xA;&#xA;See Also&#xA;--------&#xA;add_path, add_cycle&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_star([0,1,2,3])&#xA;&gt;&gt;&gt; G.add_star([10,11,12],weight=2)&#xA;" ilk="function" line="1671" lineend="1698" name="add_star" signature="add_star(nodes, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="list()" line="1695" name="nlist" /><variable line="1696" name="v" /><variable line="1697" name="edges" /></scope><scope doc="Add a path.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes : iterable container&#xA;    A container of nodes.  A path will be constructed from&#xA;    the nodes (in order) and added to the graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to every edge in path.&#xA;&#xA;See Also&#xA;--------&#xA;add_star, add_cycle&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G=nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.add_path([10,11,12],weight=7)&#xA;" ilk="function" line="1700" lineend="1724" name="add_path" signature="add_path(nodes, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="list()" line="1722" name="nlist" /><variable citdl="zip()" line="1723" name="edges" /></scope><scope doc="Add a cycle.&#xA;&#xA;Parameters&#xA;----------&#xA;nodes: iterable container&#xA;    A container of nodes.  A cycle will be constructed from&#xA;    the nodes (in order) and added to the graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to every edge in cycle.&#xA;&#xA;See Also&#xA;--------&#xA;add_path, add_star&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G=nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_cycle([0,1,2,3])&#xA;&gt;&gt;&gt; G.add_cycle([10,11,12],weight=7)&#xA;" ilk="function" line="1726" lineend="1750" name="add_cycle" signature="add_cycle(nodes, **attr)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nodes" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="list()" line="1748" name="nlist" /><variable citdl="zip()" line="1749" name="edges" /></scope><scope doc="Return an iterator of nodes contained in nbunch that are&#xA;also in the graph.&#xA;&#xA;The nodes in nbunch are checked for membership in the graph&#xA;and if not are silently ignored.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;Returns&#xA;-------&#xA;niter : iterator&#xA;    An iterator over nodes in nbunch that are also in the graph.&#xA;    If nbunch is None, iterate over all nodes in the graph.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If nbunch is not a node or or sequence of nodes.&#xA;    If a node in nbunch is not hashable.&#xA;&#xA;See Also&#xA;--------&#xA;Graph.__iter__&#xA;&#xA;Notes&#xA;-----&#xA;When nbunch is an iterator, the returned iterator yields values&#xA;directly from nbunch, becoming exhausted when nbunch is exhausted.&#xA;&#xA;To test whether nbunch is a single node, one can use&#xA;&quot;if nbunch in self:&quot;, even after processing with this routine.&#xA;&#xA;If nbunch is not a node or a (possibly empty) sequence/iterator&#xA;or None, a NetworkXError is raised.  Also, if any object in&#xA;nbunch is not hashable, a NetworkXError is raised." ilk="function" line="1753" lineend="1819" name="nbunch_iter" returns="bunch_iter()" signature="nbunch_iter(nbunch=None)"><variable citdl="Graph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="iter()" line="1795" name="bunch" /><scope ilk="function" line="1799" lineend="1817" name="bunch_iter" signature="bunch_iter(nlist, adj)"><import line="1806" module="sys" /><variable ilk="argument" name="nlist" /><variable ilk="argument" name="adj" /><variable line="1805" name="message" /></scope></scope></scope></scope>