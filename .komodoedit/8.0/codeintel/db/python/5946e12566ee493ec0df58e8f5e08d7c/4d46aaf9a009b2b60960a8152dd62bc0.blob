<scope doc="Base class for MultiDiGraph." ilk="blob" lang="Python" name="multidigraph" src="/usr/lib/pymodules/python2.7/networkx/classes/multidigraph.py"><import line="8" module="copy" symbol="deepcopy" /><import alias="nx" line="9" module="networkx" /><import line="10" module="networkx.classes.graph" symbol="Graph" /><import line="11" module="networkx.classes.digraph" symbol="DiGraph" /><import line="12" module="networkx.classes.multigraph" symbol="MultiGraph" /><import line="13" module="networkx.exception" symbol="NetworkXError" /><variable citdl="__builtins__.str.join()" line="14" name="__author__" /><scope classrefs="MultiGraph DiGraph" doc="A directed graph class that can store multiedges.&#xA;&#xA;Multiedges are multiple edges between two nodes.  Each edge&#xA;can hold optional data or attributes.&#xA;&#xA;A MultiDiGraph holds directed edges.  Self loops are allowed.&#xA;&#xA;Nodes can be arbitrary (hashable) Python objects with optional&#xA;key/value attributes.&#xA;&#xA;Edges are represented as links between nodes with optional&#xA;key/value attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;Graph&#xA;DiGraph&#xA;MultiGraph&#xA;&#xA;Examples&#xA;--------&#xA;Create an empty graph structure (a &quot;null graph&quot;) with no nodes and&#xA;no edges.&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&#xA;G can be grown in several ways.&#xA;&#xA;**Nodes:**&#xA;&#xA;Add one node at a time:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&#xA;Add the nodes from any container (a list, dict, set or&#xA;even the lines from a file or the nodes from another graph).&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([2,3])&#xA;&gt;&gt;&gt; G.add_nodes_from(range(100,110))&#xA;&gt;&gt;&gt; H=nx.Graph()&#xA;&gt;&gt;&gt; H.add_path([0,1,2,3,4,5,6,7,8,9])&#xA;&gt;&gt;&gt; G.add_nodes_from(H)&#xA;&#xA;In addition to strings and integers any hashable Python object&#xA;(except None) can represent a node, e.g. a customized node object,&#xA;or even another Graph.&#xA;&#xA;&gt;&gt;&gt; G.add_node(H)&#xA;&#xA;**Edges:**&#xA;&#xA;G can also be grown by adding edges.&#xA;&#xA;Add one edge,&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2)&#xA;&#xA;a list of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,3)])&#xA;&#xA;or a collection of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from(H.edges())&#xA;&#xA;If some edges connect nodes not yet in the graph, the nodes&#xA;are added automatically.  If an edge already exists, an additional&#xA;edge is created and stored using a key to identify the edge.&#xA;By default the key is the lowest unused integer.&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(4,5,dict(route=282)), (4,5,dict(route=37))])&#xA;&gt;&gt;&gt; G[4]&#xA;{5: {0: {}, 1: {&apos;route&apos;: 282}, 2: {&apos;route&apos;: 37}}}&#xA;&#xA;**Attributes:**&#xA;&#xA;Each graph, node, and edge can hold key/value attribute pairs&#xA;in an associated attribute dictionary (the keys must be hashable).&#xA;By default these are empty, but can be added or changed using&#xA;add_edge, add_node or direct manipulation of the attribute&#xA;dictionaries named graph, node and edge respectively.&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph(day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;&#xA;Add node attributes using add_node(), add_nodes_from() or G.node&#xA;&#xA;&gt;&gt;&gt; G.add_node(1, time=&apos;5pm&apos;)&#xA;&gt;&gt;&gt; G.add_nodes_from([3], time=&apos;2pm&apos;)&#xA;&gt;&gt;&gt; G.node[1]&#xA;{&apos;time&apos;: &apos;5pm&apos;}&#xA;&gt;&gt;&gt; G.node[1][&apos;room&apos;] = 714&#xA;&gt;&gt;&gt; del G.node[1][&apos;room&apos;] # remove attribute&#xA;&gt;&gt;&gt; G.nodes(data=True)&#xA;[(1, {&apos;time&apos;: &apos;5pm&apos;}), (3, {&apos;time&apos;: &apos;2pm&apos;})]&#xA;&#xA;Warning: adding a node to G.node does not add it to the graph.&#xA;&#xA;Add edge attributes using add_edge(), add_edges_from(), subscript&#xA;notation, or G.edge.&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=4.7 )&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(4,5)], color=&apos;red&apos;)&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2,{&apos;color&apos;:&apos;blue&apos;}), (2,3,{&apos;weight&apos;:8})])&#xA;&gt;&gt;&gt; G[1][2][0][&apos;weight&apos;] = 4.7&#xA;&gt;&gt;&gt; G.edge[1][2][0][&apos;weight&apos;] = 4&#xA;&#xA;**Shortcuts:**&#xA;&#xA;Many common graph features allow python syntax to speed reporting.&#xA;&#xA;&gt;&gt;&gt; 1 in G     # check if node in graph&#xA;True&#xA;&gt;&gt;&gt; [n for n in G if n&lt;3]   # iterate through nodes&#xA;[1, 2]&#xA;&gt;&gt;&gt; len(G)  # number of nodes in graph&#xA;5&#xA;&gt;&gt;&gt; G[1] # adjacency dict keyed by neighbor to edge attributes&#xA;...            # Note: you should not change this dict manually!&#xA;{2: {0: {&apos;weight&apos;: 4}, 1: {&apos;color&apos;: &apos;blue&apos;}}}&#xA;&#xA;The fastest way to traverse all edges of a graph is via&#xA;adjacency_iter(), but the edges() method is often more convenient.&#xA;&#xA;&gt;&gt;&gt; for n,nbrsdict in G.adjacency_iter():&#xA;...     for nbr,keydict in nbrsdict.items():&#xA;...        for key,eattr in keydict.items():&#xA;...            if &apos;weight&apos; in eattr:&#xA;...                (n,nbr,eattr[&apos;weight&apos;])&#xA;(1, 2, 4)&#xA;(2, 3, 8)&#xA;&gt;&gt;&gt; [ (u,v,edata[&apos;weight&apos;]) for u,v,edata in G.edges(data=True) if &apos;weight&apos; in edata ]&#xA;[(1, 2, 4), (2, 3, 8)]&#xA;&#xA;**Reporting:**&#xA;&#xA;Simple graph information is obtained using methods.&#xA;Iterator versions of many reporting methods exist for efficiency.&#xA;Methods exist for reporting nodes(), edges(), neighbors() and degree()&#xA;as well as the number of nodes and edges.&#xA;&#xA;For details on these and other miscellaneous methods, see below." ilk="class" line="18" lineend="851" name="MultiDiGraph"><scope doc="Add an edge between u and v.&#xA;&#xA;The nodes u and v will be automatically added if they are&#xA;not already in the graph.&#xA;&#xA;Edge attributes can be specified with keywords or by providing&#xA;a dictionary with key/value pairs.  See examples below.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;    Nodes must be hashable (and not None) Python objects.&#xA;key : hashable identifier, optional (default=lowest unused integer)&#xA;    Used to distinguish multiedges between a pair of nodes.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with the edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;See Also&#xA;--------&#xA;add_edges_from : add a collection of edges&#xA;&#xA;Notes&#xA;-----&#xA;To replace/update edge data, use the optional key argument&#xA;to identify a unique edge.  Otherwise a new edge will be created.&#xA;&#xA;NetworkX algorithms designed for weighted graphs cannot use&#xA;multigraphs directly because it is not clear how to handle&#xA;multiedge weights.  Convert to Graph using edge attribute&#xA;&apos;weight&apos; to enable weighted graph algorithms.&#xA;&#xA;Examples&#xA;--------&#xA;The following all add the edge e=(1,2) to graph G:&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.add_edge(1, 2)           # explicit two-node form&#xA;&gt;&gt;&gt; G.add_edge(*e)             # single edge as tuple of two nodes&#xA;&gt;&gt;&gt; G.add_edges_from( [(1,2)] ) # add edges from iterable container&#xA;&#xA;Associate data to edges using keywords:&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=3)&#xA;&gt;&gt;&gt; G.add_edge(1, 2, key=0, weight=4)   # update data for key=0&#xA;&gt;&gt;&gt; G.add_edge(1, 3, weight=7, capacity=15, length=342.7)" ilk="function" line="174" lineend="264" name="add_edge" signature="add_edge(u, v, key=None, attr_dict=None, **attr)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable citdl="int" ilk="argument" name="key" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="dict" line="246" name="keydict" /><variable citdl="dict" line="253" name="datadict" /></scope><scope doc="Remove an edge between u and v.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v: nodes&#xA;    Remove an edge between nodes u and v.&#xA;key : hashable identifier, optional (default=None)&#xA;    Used to distinguish multiple edges between a pair of nodes.&#xA;    If None remove a single (abritrary) edge between u and v.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If there is not an edge between u and v, or&#xA;    if there is no edge with the specified key.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edges_from : remove a collection of edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.remove_edge(0,1)&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.remove_edge(*e) # unpacks e from an edge tuple&#xA;&#xA;For multiple edges&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,2),(1,2)])&#xA;&gt;&gt;&gt; G.remove_edge(1,2) # remove a single (arbitrary) edge&#xA;&#xA;For edges with keys&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_edge(1,2,key=&apos;first&apos;)&#xA;&gt;&gt;&gt; G.add_edge(1,2,key=&apos;second&apos;)&#xA;&gt;&gt;&gt; G.remove_edge(1,2,key=&apos;second&apos;)&#xA;" ilk="function" line="266" lineend="326" name="remove_edge" signature="remove_edge(u, v, key=None)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="key" /><variable line="310" name="d" /></scope><scope doc="Return an iterator over the edges.&#xA;&#xA;Edges are returned as tuples with optional data and keys&#xA;in the order (node, neighbor, key, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict with each edge.&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;edge_iter : iterator&#xA;    An iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges : return a list of edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [e for e in G.edges_iter()]&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(data=True)) # default data is {} (empty dict)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; list(G.edges_iter([0,2]))&#xA;[(0, 1), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(0))&#xA;[(0, 1)]&#xA;" ilk="function" line="329" lineend="392" name="edges_iter" signature="edges_iter(nbunch=None, data=False, keys=False)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="False" ilk="argument" name="keys" /><variable citdl="self.adj.items()" line="374" name="nodes_nbrs" /></scope><variable citdl="MultiDiGraph.edges_iter" line="395" name="out_edges_iter" /><scope doc="Return a list of the outgoing edges.&#xA;&#xA;Edges are returned as tuples with optional data and keys&#xA;in the order (node, neighbor, key, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict with each edge.&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;out_edges : list&#xA;    An listr of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs edges() is the same as out_edges().&#xA;&#xA;See Also&#xA;--------&#xA;in_edges: return a list of incoming edges" ilk="function" line="397" lineend="427" name="out_edges" returns="list()" signature="out_edges(nbunch=None, keys=False, data=False)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="keys" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return an iterator over the incoming edges.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict with each edge.&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;in_edge_iter : iterator&#xA;    An iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges_iter : return an iterator of edges" ilk="function" line="430" lineend="471" name="in_edges_iter" signature="in_edges_iter(nbunch=None, data=False, keys=False)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="False" ilk="argument" name="keys" /><variable citdl="self.pred.items()" line="453" name="nodes_nbrs" /></scope><scope doc="Return a list of the incoming edges.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict with each edge.&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;in_edges : list&#xA;    A list  of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;out_edges: return a list of outgoing edges" ilk="function" line="473" lineend="495" name="in_edges" returns="list()" signature="in_edges(nbunch=None, keys=False, data=False)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="keys" /><variable citdl="False" ilk="argument" name="data" /></scope><scope doc="Return an iterator for (node, degree).&#xA;&#xA;The node degree is the number of edges adjacent to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.degree_iter([0,1]))&#xA;[(0, 1), (1, 2)]&#xA;" ilk="function" line="498" lineend="554" name="degree_iter" signature="degree_iter(nbunch=None, weight=None)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="zip()" line="534" name="nodes_nbrs" /><variable citdl="sum()" line="542" name="indeg" /><variable citdl="sum()" line="543" name="outdeg" /><variable citdl="sum()" line="548" name="deg" /></scope><scope doc="Return an iterator for (node, in-degree).&#xA;&#xA;The node in-degree is the number of edges pointing in to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, in-degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree, in_degree, out_degree, out_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.in_degree_iter(0)) # node 0 with degree 0&#xA;[(0, 0)]&#xA;&gt;&gt;&gt; list(G.in_degree_iter([0,1]))&#xA;[(0, 0), (1, 1)]&#xA;" ilk="function" line="557" lineend="606" name="in_degree_iter" signature="in_degree_iter(nbunch=None, weight=None)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.pred.items()" line="593" name="nodes_nbrs" /><variable citdl="sum()" line="603" name="deg" /></scope><scope doc="Return an iterator for (node, out-degree).&#xA;&#xA;The node out-degree is the number of edges pointing out of the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, out-degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree, in_degree, out_degree, in_degree_iter&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.out_degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.out_degree_iter([0,1]))&#xA;[(0, 1), (1, 1)]&#xA;" ilk="function" line="609" lineend="657" name="out_degree_iter" signature="out_degree_iter(nbunch=None, weight=None)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.succ.items()" line="645" name="nodes_nbrs" /><variable citdl="sum()" line="654" name="deg" /></scope><scope doc="Return True if graph is a multigraph, False otherwise." ilk="function" line="659" lineend="661" name="is_multigraph" returns="bool" signature="is_multigraph()"><variable citdl="MultiDiGraph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is directed, False otherwise." ilk="function" line="663" lineend="665" name="is_directed" returns="bool" signature="is_directed()"><variable citdl="MultiDiGraph" ilk="argument" name="self" /></scope><scope doc="Return a directed copy of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : MultiDiGraph&#xA;    A deepcopy of the graph.&#xA;&#xA;Notes&#xA;-----&#xA;If edges in both directions (u,v) and (v,u) exist in the&#xA;graph, attributes for the new undirected edge will be a combination of&#xA;the attributes of the directed edges.  The edge data is updated&#xA;in the (arbitrary) order that the edges are encountered.  For&#xA;more customized control of the edge attributes use add_edge().&#xA;&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar G=DiGraph(D) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 0)]&#xA;&#xA;If already directed, return a (deep) copy&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1)]" ilk="function" line="667" lineend="709" name="to_directed" returns="deepcopy()" signature="to_directed()"><variable citdl="MultiDiGraph" ilk="argument" name="self" /></scope><scope doc="Return an undirected representation of the digraph.&#xA;&#xA;Parameters&#xA;----------&#xA;reciprocal : bool (optional)&#xA;  If True only keep edges that appear in both directions &#xA;  in the original digraph. &#xA;&#xA;Returns&#xA;-------&#xA;G : MultiGraph&#xA;    An undirected graph with the same name and nodes and&#xA;    with edge (u,v,data) if either (u,v,data) or (v,u,data)&#xA;    is in the digraph.  If both edges exist in digraph and&#xA;    their edge data is different, only one edge is created&#xA;    with an arbitrary choice of which edge data to use.&#xA;    You must check and correct for this manually if desired.&#xA;&#xA;Notes&#xA;-----&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar D=DiGraph(G) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html." ilk="function" line="711" lineend="758" name="to_undirected" returns="MultiGraph()" signature="to_undirected(reciprocal=False)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="reciprocal" /><variable citdl="MultiGraph()" line="742" name="H" /></scope><scope doc="Return the subgraph induced on nodes in nbunch.&#xA;&#xA;The induced subgraph of the graph contains the nodes in nbunch&#xA;and the edges between those nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : list, iterable&#xA;    A container of nodes which will be iterated through once.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    A subgraph of the graph with the same edge attributes.&#xA;&#xA;Notes&#xA;-----&#xA;The graph, edge or node attributes just point to the original graph.&#xA;So changes to the node or edge structure will not be reflected in&#xA;the original graph while changes to the attributes will.&#xA;&#xA;To create a subgraph with its own copy of the edge/node attributes use:&#xA;nx.Graph(G.subgraph(nbunch))&#xA;&#xA;If edge attributes are containers, a deep copy can be obtained using:&#xA;G.subgraph(nbunch).copy()&#xA;&#xA;For an inplace reduction of a graph to a subgraph you can remove nodes:&#xA;G.remove_nodes_from([ n in G if n not in set(nbunch)])&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; H = G.subgraph([0,1,2])&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 2)]" ilk="function" line="760" lineend="825" name="subgraph" returns="self.__class__()" signature="subgraph(nbunch)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="self.nbunch_iter()" line="799" name="bunch" /><variable citdl="self.__class__()" line="801" name="H" /><variable citdl="H.succ" line="806" name="H_succ" /><variable citdl="H.pred" line="807" name="H_pred" /><variable citdl="self.succ" line="808" name="self_succ" /><variable citdl="self.pred" line="809" name="self_pred" /><variable line="816" name="Hnbrs" /><variable citdl="edgedict.copy()" line="821" name="ed" /></scope><scope doc="Return the reverse of the graph.&#xA;&#xA;The reverse is a graph with the same nodes and edges&#xA;but with the directions of the edges reversed.&#xA;&#xA;Parameters&#xA;----------&#xA;copy : bool optional (default=True)&#xA;    If True, return a new DiGraph holding the reversed edges.&#xA;    If False, reverse the reverse graph is created using&#xA;    the original graph (this changes the original graph)." ilk="function" line="827" lineend="851" name="reverse" returns="MultiDiGraph" signature="reverse(copy=True)"><variable citdl="MultiDiGraph" ilk="argument" name="self" /><variable citdl="True" ilk="argument" name="copy" /><variable citdl="self.__class__()" line="841" name="H" /></scope><variable attributes="__instancevar__" citdl="self.succ" line="848" name="pred" /><variable attributes="__instancevar__" citdl="self.succ" line="848" name="succ" /><variable attributes="__instancevar__" citdl="self.succ" line="849" name="adj" /></scope></scope>