<scope doc="Base class for MultiGraph." ilk="blob" lang="Python" name="multigraph" src="/usr/lib/pymodules/python2.7/networkx/classes/multigraph.py"><import line="8" module="copy" symbol="deepcopy" /><import alias="nx" line="9" module="networkx" /><import line="10" module="networkx.classes.graph" symbol="Graph" /><import line="11" module="networkx" symbol="NetworkXError" /><variable citdl="__builtins__.str.join()" line="12" name="__author__" /><scope classrefs="Graph" doc="An undirected graph class that can store multiedges.&#xA;&#xA;Multiedges are multiple edges between two nodes.  Each edge&#xA;can hold optional data or attributes.&#xA;&#xA;A MultiGraph holds undirected edges.  Self loops are allowed.&#xA;&#xA;Nodes can be arbitrary (hashable) Python objects with optional&#xA;key/value attributes.&#xA;&#xA;Edges are represented as links between nodes with optional&#xA;key/value attributes.&#xA;&#xA;Parameters&#xA;----------&#xA;data : input graph&#xA;    Data to initialize graph.  If data=None (default) an empty&#xA;    graph is created.  The data can be an edge list, or any&#xA;    NetworkX graph object.  If the corresponding optional Python&#xA;    packages are installed the data can also be a NumPy matrix&#xA;    or 2d ndarray, a SciPy sparse matrix, or a PyGraphviz graph.&#xA;attr : keyword arguments, optional (default= no attributes)&#xA;    Attributes to add to graph as key=value pairs.&#xA;&#xA;See Also&#xA;--------&#xA;Graph&#xA;DiGraph&#xA;MultiDiGraph&#xA;&#xA;Examples&#xA;--------&#xA;Create an empty graph structure (a &quot;null graph&quot;) with no nodes and&#xA;no edges.&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph()&#xA;&#xA;G can be grown in several ways.&#xA;&#xA;**Nodes:**&#xA;&#xA;Add one node at a time:&#xA;&#xA;&gt;&gt;&gt; G.add_node(1)&#xA;&#xA;Add the nodes from any container (a list, dict, set or&#xA;even the lines from a file or the nodes from another graph).&#xA;&#xA;&gt;&gt;&gt; G.add_nodes_from([2,3])&#xA;&gt;&gt;&gt; G.add_nodes_from(range(100,110))&#xA;&gt;&gt;&gt; H=nx.Graph()&#xA;&gt;&gt;&gt; H.add_path([0,1,2,3,4,5,6,7,8,9])&#xA;&gt;&gt;&gt; G.add_nodes_from(H)&#xA;&#xA;In addition to strings and integers any hashable Python object&#xA;(except None) can represent a node, e.g. a customized node object,&#xA;or even another Graph.&#xA;&#xA;&gt;&gt;&gt; G.add_node(H)&#xA;&#xA;**Edges:**&#xA;&#xA;G can also be grown by adding edges.&#xA;&#xA;Add one edge,&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2)&#xA;&#xA;a list of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,3)])&#xA;&#xA;or a collection of edges,&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from(H.edges())&#xA;&#xA;If some edges connect nodes not yet in the graph, the nodes&#xA;are added automatically.  If an edge already exists, an additional&#xA;edge is created and stored using a key to identify the edge.&#xA;By default the key is the lowest unused integer.&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(4,5,dict(route=282)), (4,5,dict(route=37))])&#xA;&gt;&gt;&gt; G[4]&#xA;{3: {0: {}}, 5: {0: {}, 1: {&apos;route&apos;: 282}, 2: {&apos;route&apos;: 37}}}&#xA;&#xA;**Attributes:**&#xA;&#xA;Each graph, node, and edge can hold key/value attribute pairs&#xA;in an associated attribute dictionary (the keys must be hashable).&#xA;By default these are empty, but can be added or changed using&#xA;add_edge, add_node or direct manipulation of the attribute&#xA;dictionaries named graph, node and edge respectively.&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph(day=&quot;Friday&quot;)&#xA;&gt;&gt;&gt; G.graph&#xA;{&apos;day&apos;: &apos;Friday&apos;}&#xA;&#xA;Add node attributes using add_node(), add_nodes_from() or G.node&#xA;&#xA;&gt;&gt;&gt; G.add_node(1, time=&apos;5pm&apos;)&#xA;&gt;&gt;&gt; G.add_nodes_from([3], time=&apos;2pm&apos;)&#xA;&gt;&gt;&gt; G.node[1]&#xA;{&apos;time&apos;: &apos;5pm&apos;}&#xA;&gt;&gt;&gt; G.node[1][&apos;room&apos;] = 714&#xA;&gt;&gt;&gt; del G.node[1][&apos;room&apos;] # remove attribute&#xA;&gt;&gt;&gt; G.nodes(data=True)&#xA;[(1, {&apos;time&apos;: &apos;5pm&apos;}), (3, {&apos;time&apos;: &apos;2pm&apos;})]&#xA;&#xA;Warning: adding a node to G.node does not add it to the graph.&#xA;&#xA;Add edge attributes using add_edge(), add_edges_from(), subscript&#xA;notation, or G.edge.&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=4.7 )&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(4,5)], color=&apos;red&apos;)&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2,{&apos;color&apos;:&apos;blue&apos;}), (2,3,{&apos;weight&apos;:8})])&#xA;&gt;&gt;&gt; G[1][2][0][&apos;weight&apos;] = 4.7&#xA;&gt;&gt;&gt; G.edge[1][2][0][&apos;weight&apos;] = 4&#xA;&#xA;**Shortcuts:**&#xA;&#xA;Many common graph features allow python syntax to speed reporting.&#xA;&#xA;&gt;&gt;&gt; 1 in G     # check if node in graph&#xA;True&#xA;&gt;&gt;&gt; [n for n in G if n&lt;3]   # iterate through nodes&#xA;[1, 2]&#xA;&gt;&gt;&gt; len(G)  # number of nodes in graph&#xA;5&#xA;&gt;&gt;&gt; G[1] # adjacency dict keyed by neighbor to edge attributes&#xA;...            # Note: you should not change this dict manually!&#xA;{2: {0: {&apos;weight&apos;: 4}, 1: {&apos;color&apos;: &apos;blue&apos;}}}&#xA;&#xA;The fastest way to traverse all edges of a graph is via&#xA;adjacency_iter(), but the edges() method is often more convenient.&#xA;&#xA;&gt;&gt;&gt; for n,nbrsdict in G.adjacency_iter():&#xA;...     for nbr,keydict in nbrsdict.items():&#xA;...        for key,eattr in keydict.items():&#xA;...            if &apos;weight&apos; in eattr:&#xA;...                (n,nbr,eattr[&apos;weight&apos;])&#xA;(1, 2, 4)&#xA;(2, 1, 4)&#xA;(2, 3, 8)&#xA;(3, 2, 8)&#xA;&gt;&gt;&gt; [ (u,v,edata[&apos;weight&apos;]) for u,v,edata in G.edges(data=True) if &apos;weight&apos; in edata ]&#xA;[(1, 2, 4), (2, 3, 8)]&#xA;&#xA;**Reporting:**&#xA;&#xA;Simple graph information is obtained using methods.&#xA;Iterator versions of many reporting methods exist for efficiency.&#xA;Methods exist for reporting nodes(), edges(), neighbors() and degree()&#xA;as well as the number of nodes and edges.&#xA;&#xA;For details on these and other miscellaneous methods, see below." ilk="class" line="16" lineend="966" name="MultiGraph"><scope doc="Add an edge between u and v.&#xA;&#xA;The nodes u and v will be automatically added if they are&#xA;not already in the graph.&#xA;&#xA;Edge attributes can be specified with keywords or by providing&#xA;a dictionary with key/value pairs.  See examples below.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;    Nodes must be hashable (and not None) Python objects.&#xA;key : hashable identifier, optional (default=lowest unused integer)&#xA;    Used to distinguish multiedges between a pair of nodes.&#xA;attr_dict : dictionary, optional (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with the edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;See Also&#xA;--------&#xA;add_edges_from : add a collection of edges&#xA;&#xA;Notes&#xA;-----&#xA;To replace/update edge data, use the optional key argument&#xA;to identify a unique edge.  Otherwise a new edge will be created.&#xA;&#xA;NetworkX algorithms designed for weighted graphs cannot use&#xA;multigraphs directly because it is not clear how to handle&#xA;multiedge weights.  Convert to Graph using edge attribute&#xA;&apos;weight&apos; to enable weighted graph algorithms.&#xA;&#xA;Examples&#xA;--------&#xA;The following all add the edge e=(1,2) to graph G:&#xA;&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.add_edge(1, 2)           # explicit two-node form&#xA;&gt;&gt;&gt; G.add_edge(*e)             # single edge as tuple of two nodes&#xA;&gt;&gt;&gt; G.add_edges_from( [(1,2)] ) # add edges from iterable container&#xA;&#xA;Associate data to edges using keywords:&#xA;&#xA;&gt;&gt;&gt; G.add_edge(1, 2, weight=3)&#xA;&gt;&gt;&gt; G.add_edge(1, 2, key=0, weight=4)   # update data for key=0&#xA;&gt;&gt;&gt; G.add_edge(1, 3, weight=7, capacity=15, length=342.7)" ilk="function" line="175" lineend="263" name="add_edge" signature="add_edge(u, v, key=None, attr_dict=None, **attr)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable citdl="int" ilk="argument" name="key" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="dict" line="245" name="keydict" /><variable citdl="dict" line="252" name="datadict" /></scope><scope doc="Add all the edges in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch : container of edges&#xA;    Each edge given in the container will be added to the&#xA;    graph. The edges can be:&#xA;&#xA;        - 2-tuples (u,v) or&#xA;        - 3-tuples (u,v,d) for an edge attribute dict d, or&#xA;        - 4-tuples (u,v,k,d) for an edge identified by key k&#xA;&#xA;attr_dict : dictionary, optional  (default= no attributes)&#xA;    Dictionary of edge attributes.  Key/value pairs will&#xA;    update existing data associated with each edge.&#xA;attr : keyword arguments, optional&#xA;    Edge data (or labels or objects) can be assigned using&#xA;    keyword arguments.&#xA;&#xA;&#xA;See Also&#xA;--------&#xA;add_edge : add a single edge&#xA;add_weighted_edges_from : convenient way to add weighted edges&#xA;&#xA;Notes&#xA;-----&#xA;Adding the same edge twice has no effect but any edge data&#xA;will be updated when each duplicate edge is added.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edges_from([(0,1),(1,2)]) # using a list of edge tuples&#xA;&gt;&gt;&gt; e = zip(range(0,3),range(1,4))&#xA;&gt;&gt;&gt; G.add_edges_from(e) # Add the path graph 0-1-2-3&#xA;&#xA;Associate data to edges&#xA;&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(2,3)], weight=3)&#xA;&gt;&gt;&gt; G.add_edges_from([(3,4),(1,4)], label=&apos;WN2898&apos;)" ilk="function" line="266" lineend="346" name="add_edges_from" signature="add_edges_from(ebunch, attr_dict=None, **attr)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /><variable ilk="argument" name="attr_dict" /><variable attributes="kwargs" ilk="argument" name="attr" /><variable citdl="len()" line="320" name="ne" /><variable citdl="len()" line="325" name="key" /><variable citdl="dict" line="328" name="dd" /><variable citdl="dict" line="334" name="keydict" /><variable citdl="keydict.get()" line="343" name="datadict" /></scope><scope doc="Remove an edge between u and v.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v: nodes&#xA;    Remove an edge between nodes u and v.&#xA;key : hashable identifier, optional (default=None)&#xA;    Used to distinguish multiple edges between a pair of nodes.&#xA;    If None remove a single (abritrary) edge between u and v.&#xA;&#xA;Raises&#xA;------&#xA;NetworkXError&#xA;    If there is not an edge between u and v, or&#xA;    if there is no edge with the specified key.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edges_from : remove a collection of edges&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph()&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.remove_edge(0,1)&#xA;&gt;&gt;&gt; e = (1,2)&#xA;&gt;&gt;&gt; G.remove_edge(*e) # unpacks e from an edge tuple&#xA;&#xA;For multiple edges&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,2),(1,2)])&#xA;&gt;&gt;&gt; G.remove_edge(1,2) # remove a single (arbitrary) edge&#xA;&#xA;For edges with keys&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_edge(1,2,key=&apos;first&apos;)&#xA;&gt;&gt;&gt; G.add_edge(1,2,key=&apos;second&apos;)&#xA;&gt;&gt;&gt; G.remove_edge(1,2,key=&apos;second&apos;)&#xA;" ilk="function" line="349" lineend="410" name="remove_edge" signature="remove_edge(u, v, key=None)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="key" /><variable line="393" name="d" /></scope><scope doc="Remove all edges specified in ebunch.&#xA;&#xA;Parameters&#xA;----------&#xA;ebunch: list or container of edge tuples&#xA;    Each edge given in the list or container will be removed&#xA;    from the graph. The edges can be:&#xA;&#xA;        - 2-tuples (u,v) All edges between u and v are removed.&#xA;        - 3-tuples (u,v,key) The edge identified by key is removed.&#xA;        - 4-tuples (u,v,key,data) where data is ignored.&#xA;&#xA;See Also&#xA;--------&#xA;remove_edge : remove a single edge&#xA;&#xA;Notes&#xA;-----&#xA;Will fail silently if an edge in ebunch is not in the graph.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph() # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; ebunch=[(1,2),(2,3)]&#xA;&gt;&gt;&gt; G.remove_edges_from(ebunch)&#xA;&#xA;Removing multiple copies of edges&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph()&#xA;&gt;&gt;&gt; G.add_edges_from([(1,2),(1,2),(1,2)])&#xA;&gt;&gt;&gt; G.remove_edges_from([(1,2),(1,2)])&#xA;&gt;&gt;&gt; G.edges()&#xA;[(1, 2)]&#xA;&gt;&gt;&gt; G.remove_edges_from([(1,2),(1,2)]) # silently ignore extra copy&#xA;&gt;&gt;&gt; G.edges() # now empty graph&#xA;[]" ilk="function" line="413" lineend="456" name="remove_edges_from" signature="remove_edges_from(ebunch)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="ebunch" /></scope><scope doc="Return True if the graph has an edge between nodes u and v.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;    Nodes can be, for example, strings or numbers.&#xA;&#xA;key : hashable identifier, optional (default=None)&#xA;    If specified return True only if the edge with&#xA;    key is found.&#xA;&#xA;Returns&#xA;-------&#xA;edge_ind : bool&#xA;    True if edge is in the graph, False otherwise.&#xA;&#xA;Examples&#xA;--------&#xA;Can be called either using two nodes u,v, an edge tuple (u,v),&#xA;or an edge tuple (u,v,key).&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.has_edge(0,1)  # using two nodes&#xA;True&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.has_edge(*e)  #  e is a 2-tuple (u,v)&#xA;True&#xA;&gt;&gt;&gt; G.add_edge(0,1,key=&apos;a&apos;)&#xA;&gt;&gt;&gt; G.has_edge(0,1,key=&apos;a&apos;)  # specify key&#xA;True&#xA;&gt;&gt;&gt; e=(0,1,&apos;a&apos;)&#xA;&gt;&gt;&gt; G.has_edge(*e) # e is a 3-tuple (u,v,&apos;a&apos;)&#xA;True&#xA;&#xA;The following syntax are equivalent:&#xA;&#xA;&gt;&gt;&gt; G.has_edge(0,1)&#xA;True&#xA;&gt;&gt;&gt; 1 in G[0]  # though this gives KeyError if 0 not in G&#xA;True&#xA;&#xA;&#xA;" ilk="function" line="459" lineend="511" name="has_edge" returns="bool" signature="has_edge(u, v, key=None)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="key" /></scope><scope doc="Return a list of edges.&#xA;&#xA;Edges are returned as tuples with optional data and keys&#xA;in the order (node, neighbor, key, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    Return two tuples (u,v) (False) or three-tuples (u,v,data) (True).&#xA;keys : bool, optional (default=False)&#xA;    Return two tuples (u,v) (False) or three-tuples (u,v,key) (True).&#xA;&#xA;Returns&#xA;--------&#xA;edge_list: list of edge tuples&#xA;    Edges that are adjacent to any node in nbunch, or a list&#xA;    of all edges if nbunch is not specified.&#xA;&#xA;See Also&#xA;--------&#xA;edges_iter : return an iterator over the edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph()  # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.edges()&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; G.edges(data=True) # default edge data is {} (empty dictionary)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; G.edges(keys=True) # default keys are integers&#xA;[(0, 1, 0), (1, 2, 0), (2, 3, 0)]&#xA;&gt;&gt;&gt; G.edges(data=True,keys=True) # default keys are integers&#xA;[(0, 1, 0, {}), (1, 2, 0, {}), (2, 3, 0, {})]&#xA;&gt;&gt;&gt; G.edges([0,3])&#xA;[(0, 1), (3, 2)]&#xA;&gt;&gt;&gt; G.edges(0)&#xA;[(0, 1)]&#xA;" ilk="function" line="513" lineend="562" name="edges" returns="list()" signature="edges(nbunch=None, data=False, keys=False)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="False" ilk="argument" name="keys" /></scope><scope doc="Return an iterator over the edges.&#xA;&#xA;Edges are returned as tuples with optional data and keys&#xA;in the order (node, neighbor, key, data).&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default= all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;data : bool, optional (default=False)&#xA;    If True, return edge attribute dict with each edge.&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;edge_iter : iterator&#xA;    An iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges.&#xA;&#xA;See Also&#xA;--------&#xA;edges : return a list of edges&#xA;&#xA;Notes&#xA;-----&#xA;Nodes in nbunch that are not in the graph will be (quietly) ignored.&#xA;For directed graphs this returns the out-edges.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; [e for e in G.edges_iter()]&#xA;[(0, 1), (1, 2), (2, 3)]&#xA;&gt;&gt;&gt; list(G.edges_iter(data=True)) # default data is {} (empty dict)&#xA;[(0, 1, {}), (1, 2, {}), (2, 3, {})]&#xA;&gt;&gt;&gt; list(G.edges(keys=True)) # default keys are integers&#xA;[(0, 1, 0), (1, 2, 0), (2, 3, 0)]&#xA;&gt;&gt;&gt; list(G.edges(data=True,keys=True)) # default keys are integers&#xA;[(0, 1, 0, {}), (1, 2, 0, {}), (2, 3, 0, {})]&#xA;&gt;&gt;&gt; list(G.edges_iter([0,3]))&#xA;[(0, 1), (3, 2)]&#xA;&gt;&gt;&gt; list(G.edges_iter(0))&#xA;[(0, 1)]&#xA;" ilk="function" line="564" lineend="638" name="edges_iter" signature="edges_iter(nbunch=None, data=False, keys=False)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="False" ilk="argument" name="keys" /><variable citdl="dict" line="612" name="seen" /><variable citdl="self.adj.items()" line="614" name="nodes_nbrs" /></scope><scope doc="Return the attribute dictionary associated with edge (u,v).&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes&#xA;default:  any Python object (default=None)&#xA;    Value to return if the edge (u,v) is not found.&#xA;key : hashable identifier, optional (default=None)&#xA;    Return data only for the edge with specified key.&#xA;&#xA;Returns&#xA;-------&#xA;edge_dict : dictionary&#xA;    The edge attribute dictionary.&#xA;&#xA;Notes&#xA;-----&#xA;It is faster to use G[u][v][key].&#xA;&#xA;&gt;&gt;&gt; G = nx.MultiGraph() # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_edge(0,1,key=&apos;a&apos;,weight=7)&#xA;&gt;&gt;&gt; G[0][1][&apos;a&apos;]  # key=&apos;a&apos;&#xA;{&apos;weight&apos;: 7}&#xA;&#xA;Warning: Assigning G[u][v][key] corrupts the graph data structure.&#xA;But it is safe to assign attributes to that dictionary,&#xA;&#xA;&gt;&gt;&gt; G[0][1][&apos;a&apos;][&apos;weight&apos;] = 10&#xA;&gt;&gt;&gt; G[0][1][&apos;a&apos;][&apos;weight&apos;]&#xA;10&#xA;&gt;&gt;&gt; G[1][0][&apos;a&apos;][&apos;weight&apos;]&#xA;10&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph() # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.get_edge_data(0,1)&#xA;{0: {}}&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.get_edge_data(*e) # tuple form&#xA;{0: {}}&#xA;&gt;&gt;&gt; G.get_edge_data(&apos;a&apos;,&apos;b&apos;,default=0) # edge not in graph, return 0&#xA;0" ilk="function" line="641" lineend="693" name="get_edge_data" signature="get_edge_data(u, v, key=None, default=None)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable ilk="argument" name="key" /><variable ilk="argument" name="default" /></scope><scope doc="Return an iterator for (node, degree).&#xA;&#xA;The node degree is the number of edges adjacent to the node.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : iterable container, optional (default=all nodes)&#xA;    A container of nodes.  The container will be iterated&#xA;    through once.&#xA;&#xA;weight : string or None, optional (default=None)&#xA;   The edge attribute that holds the numerical value used &#xA;   as a weight.  If None, then each edge has weight 1.&#xA;   The degree is the sum of the edge weights adjacent to the node.&#xA;&#xA;Returns&#xA;-------&#xA;nd_iter : an iterator&#xA;    The iterator returns two-tuples of (node, degree).&#xA;&#xA;See Also&#xA;--------&#xA;degree&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; list(G.degree_iter(0)) # node 0 with degree 1&#xA;[(0, 1)]&#xA;&gt;&gt;&gt; list(G.degree_iter([0,1]))&#xA;[(0, 1), (1, 2)]&#xA;" ilk="function" line="695" lineend="748" name="degree_iter" signature="degree_iter(nbunch=None, weight=None)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable ilk="argument" name="weight" /><variable citdl="self.adj.items()" line="731" name="nodes_nbrs" /><variable citdl="sum()" line="737" name="deg" /></scope><scope doc="Return True if graph is a multigraph, False otherwise." ilk="function" line="751" lineend="753" name="is_multigraph" returns="bool" signature="is_multigraph()"><variable citdl="MultiGraph" ilk="argument" name="self" /></scope><scope doc="Return True if graph is directed, False otherwise." ilk="function" line="755" lineend="757" name="is_directed" returns="bool" signature="is_directed()"><variable citdl="MultiGraph" ilk="argument" name="self" /></scope><scope doc="Return a directed representation of the graph.&#xA;&#xA;Returns&#xA;-------&#xA;G : MultiDiGraph&#xA;    A directed graph with the same name, same nodes, and with&#xA;    each edge (u,v,data) replaced by two directed edges&#xA;    (u,v,data) and (v,u,data).&#xA;&#xA;Notes&#xA;-----&#xA;This returns a &quot;deepcopy&quot; of the edge, node, and&#xA;graph attributes which attempts to completely copy&#xA;all of the data and references.&#xA;&#xA;This is in contrast to the similar D=DiGraph(G) which returns a&#xA;shallow copy of the data.&#xA;&#xA;See the Python copy module for more information on shallow&#xA;and deep copies, http://docs.python.org/library/copy.html.&#xA;&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or MultiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 0)]&#xA;&#xA;If already directed, return a (deep) copy&#xA;&#xA;&gt;&gt;&gt; G = nx.DiGraph()   # or MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1])&#xA;&gt;&gt;&gt; H = G.to_directed()&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1)]" ilk="function" line="759" lineend="807" name="to_directed" returns="MultiDiGraph()" signature="to_directed()"><import line="798" module="networkx.classes.multidigraph" symbol="MultiDiGraph" /><variable citdl="MultiGraph" ilk="argument" name="self" /><variable citdl="MultiDiGraph()" line="799" name="G" /></scope><scope doc="Return a list of selfloop edges.&#xA;&#xA;A selfloop edge has the same node at both ends.&#xA;&#xA;Parameters&#xA;-----------&#xA;data : bool, optional (default=False)&#xA;    Return selfloop edges as two tuples (u,v) (data=False)&#xA;    or three-tuples (u,v,data) (data=True)&#xA;keys : bool, optional (default=False)&#xA;    If True, return edge keys with each edge.&#xA;&#xA;Returns&#xA;-------&#xA;edgelist : list of edge tuples&#xA;    A list of all selfloop edges.&#xA;&#xA;See Also&#xA;--------&#xA;nodes_with_selfloops, number_of_selfloops&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiGraph()   # or MultiDiGraph&#xA;&gt;&gt;&gt; G.add_edge(1,1)&#xA;&gt;&gt;&gt; G.add_edge(1,2)&#xA;&gt;&gt;&gt; G.selfloop_edges()&#xA;[(1, 1)]&#xA;&gt;&gt;&gt; G.selfloop_edges(data=True)&#xA;[(1, 1, {})]&#xA;&gt;&gt;&gt; G.selfloop_edges(keys=True)&#xA;[(1, 1, 0)]&#xA;&gt;&gt;&gt; G.selfloop_edges(keys=True, data=True)&#xA;[(1, 1, 0, {})]" ilk="function" line="810" lineend="864" name="selfloop_edges" returns="list" signature="selfloop_edges(data=False, keys=False)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="data" /><variable citdl="False" ilk="argument" name="keys" /></scope><scope doc="Return the number of edges between two nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;u,v : nodes, optional (default=all edges)&#xA;    If u and v are specified, return the number of edges between&#xA;    u and v. Otherwise return the total number of all edges.&#xA;&#xA;Returns&#xA;-------&#xA;nedges : int&#xA;    The number of edges in the graph.  If nodes u and v are specified&#xA;    return the number of edges between those nodes.&#xA;&#xA;See Also&#xA;--------&#xA;size&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; G.number_of_edges()&#xA;3&#xA;&gt;&gt;&gt; G.number_of_edges(0,1)&#xA;1&#xA;&gt;&gt;&gt; e = (0,1)&#xA;&gt;&gt;&gt; G.number_of_edges(*e)&#xA;1" ilk="function" line="867" lineend="903" name="number_of_edges" returns="self.size()" signature="number_of_edges(u=None, v=None)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="u" /><variable ilk="argument" name="v" /><variable line="900" name="edgedata" /></scope><scope doc="Return the subgraph induced on nodes in nbunch.&#xA;&#xA;The induced subgraph of the graph contains the nodes in nbunch&#xA;and the edges between those nodes.&#xA;&#xA;Parameters&#xA;----------&#xA;nbunch : list, iterable&#xA;    A container of nodes which will be iterated through once.&#xA;&#xA;Returns&#xA;-------&#xA;G : Graph&#xA;    A subgraph of the graph with the same edge attributes.&#xA;&#xA;Notes&#xA;-----&#xA;The graph, edge or node attributes just point to the original graph.&#xA;So changes to the node or edge structure will not be reflected in&#xA;the original graph while changes to the attributes will.&#xA;&#xA;To create a subgraph with its own copy of the edge/node attributes use:&#xA;nx.Graph(G.subgraph(nbunch))&#xA;&#xA;If edge attributes are containers, a deep copy can be obtained using:&#xA;G.subgraph(nbunch).copy()&#xA;&#xA;For an inplace reduction of a graph to a subgraph you can remove nodes:&#xA;G.remove_nodes_from([ n in G if n not in set(nbunch)])&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()   # or DiGraph, MultiGraph, MultiDiGraph, etc&#xA;&gt;&gt;&gt; G.add_path([0,1,2,3])&#xA;&gt;&gt;&gt; H = G.subgraph([0,1,2])&#xA;&gt;&gt;&gt; H.edges()&#xA;[(0, 1), (1, 2)]" ilk="function" line="906" lineend="966" name="subgraph" returns="self.__class__()" signature="subgraph(nbunch)"><variable citdl="MultiGraph" ilk="argument" name="self" /><variable ilk="argument" name="nbunch" /><variable citdl="self.nbunch_iter()" line="945" name="bunch" /><variable citdl="self.__class__()" line="947" name="H" /><variable citdl="H.adj" line="952" name="H_adj" /><variable citdl="self.adj" line="953" name="self_adj" /><variable citdl="dict" line="956" name="Hnbrs" /><variable citdl="edgedict.copy()" line="962" name="ed" /></scope></scope></scope>