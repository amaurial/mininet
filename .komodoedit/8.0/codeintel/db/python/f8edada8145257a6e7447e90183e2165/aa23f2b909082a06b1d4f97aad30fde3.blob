<scope doc="An L2 learning switch." ilk="blob" lang="Python" name="l2_learning" src="/home/mininet/new_pox/pox/pox/forwarding/l2_learning.py"><import line="26" module="pox.core" symbol="core" /><import alias="of" line="27" module="pox.openflow.libopenflow_01" /><import line="28" module="pox.lib.util" symbol="dpid_to_str" /><import line="29" module="pox.lib.util" symbol="str_to_bool" /><import line="30" module="time" /><variable citdl="core.getLogger()" line="32" name="log" /><variable attributes="protected" citdl="int" line="36" name="_flood_delay" /><scope classrefs="object" doc="The learning switch &quot;brain&quot; associated with a single OpenFlow switch.&#xA;&#xA;When we see a packet, we&apos;d like to output it on a port which will&#xA;eventually lead to the destination.  To accomplish this, we build a&#xA;table that maps addresses to ports.&#xA;&#xA;We populate the table by observing traffic.  When we see a packet&#xA;from some source coming from some port, we know that source is out&#xA;that port.&#xA;&#xA;When we want to forward traffic, we look up the desintation in our&#xA;table.  If we don&apos;t know the port, we simply send the message out&#xA;all ports except the one it came in on.  (In the presence of loops,&#xA;this is bad!).&#xA;&#xA;In short, our algorithm looks like this:&#xA;&#xA;For each packet from the switch:&#xA;1) Use source address and switch port to update address/port table&#xA;2) Is transparent = False and either Ethertype is LLDP or the packet&apos;s&#xA;   destination address is a Bridge Filtered address?&#xA;   Yes:&#xA;      2a) Drop packet -- don&apos;t forward link-local traffic (LLDP, 802.1x)&#xA;          DONE&#xA;3) Is destination multicast?&#xA;   Yes:&#xA;      3a) Flood the packet&#xA;          DONE&#xA;4) Port for destination address in our address/port table?&#xA;   No:&#xA;      4a) Flood the packet&#xA;          DONE&#xA;5) Is output port the same as input port?&#xA;   Yes:&#xA;      5a) Drop packet and similar ones for a while&#xA;6) Install flow table entry in the switch so that this&#xA;   flow goes out the appopriate port&#xA;   6a) Send the packet out appropriate port" ilk="class" line="38" lineend="192" name="LearningSwitch"><scope attributes="__ctor__" ilk="function" line="79" lineend="92" name="__init__" signature="LearningSwitch(connection, transparent)"><variable citdl="LearningSwitch" ilk="argument" name="self" /><variable ilk="argument" name="connection" /><variable ilk="argument" name="transparent" /></scope><variable attributes="__instancevar__" line="81" name="connection" /><variable attributes="__instancevar__" line="82" name="transparent" /><variable attributes="__instancevar__" citdl="dict" line="85" name="macToPort" /><variable attributes="__instancevar__" citdl="True" line="92" name="hold_down_expired" /><scope attributes="protected" doc="Handle packet in messages from the switch to implement above algorithm." ilk="function" line="97" lineend="192" name="_handle_PacketIn" signature="_handle_PacketIn(event)"><variable citdl="LearningSwitch" ilk="argument" name="self" /><variable ilk="argument" name="event" /><variable citdl="event.parsed" line="102" name="packet" /><scope doc="Floods the packet " ilk="function" line="104" lineend="126" name="flood" signature="flood(message=None)"><variable ilk="argument" name="message" /><variable citdl="of.ofp_packet_out()" line="106" name="msg" /></scope><scope doc="Drops this packet and optionally installs a flow to continue&#xA;dropping similar ones for a while" ilk="function" line="128" lineend="146" name="drop" signature="drop(duration=None)"><variable citdl="tuple" ilk="argument" name="duration" /><variable citdl="of.ofp_flow_mod()" line="136" name="msg" /></scope><variable line="175" name="port" /><variable citdl="of.ofp_flow_mod()" line="185" name="msg" /></scope></scope><scope classrefs="object" doc="Waits for OpenFlow switches to connect and makes them learning switches." ilk="class" line="195" lineend="205" name="l2_learning"><scope attributes="__ctor__" ilk="function" line="199" lineend="201" name="__init__" signature="l2_learning(transparent)"><variable citdl="l2_learning" ilk="argument" name="self" /><variable ilk="argument" name="transparent" /></scope><variable attributes="__instancevar__" line="201" name="transparent" /><scope attributes="protected" ilk="function" line="203" lineend="205" name="_handle_ConnectionUp" signature="_handle_ConnectionUp(event)"><variable citdl="l2_learning" ilk="argument" name="self" /><variable ilk="argument" name="event" /></scope></scope><scope doc="Starts an L2 learning switch." ilk="function" line="208" lineend="219" name="launch" signature="launch(transparent=False, hold_down=_flood_delay)"><variable citdl="False" ilk="argument" name="transparent" /><variable citdl="int" ilk="argument" name="hold_down" /><variable attributes="protected" citdl="int()" line="214" name="_flood_delay" /></scope></scope>