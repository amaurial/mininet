<scope doc="This module provides functions to convert NetworkX graphs to&#xA;and from other formats." ilk="blob" lang="Python" name="convert" src="/usr/lib/pymodules/python2.7/networkx/convert.py"><import line="44" module="warnings" /><import alias="nx" line="45" module="networkx" /><variable citdl="__builtins__.str.join()" line="34" name="__author__" /><variable citdl="list" line="47" name="__all__" /><scope attributes="protected" doc="Return a graph object ready to be populated.&#xA;&#xA;If create_using is None return the default (just networkx.Graph())&#xA;If create_using.clear() works, assume it returns a graph object.&#xA;Otherwise raise an exception because create_using is not a networkx graph.&#xA;" ilk="function" line="55" lineend="71" name="_prep_create_using" returns="nx.Graph()" signature="_prep_create_using(create_using)"><variable ilk="argument" name="create_using" /><variable citdl="nx.Graph()" line="64" name="G" /></scope><scope doc="Make a NetworkX graph from a known data structure.&#xA;&#xA;The preferred way to call this is automatically&#xA;from the class constructor&#xA;&#xA;&gt;&gt;&gt; d={0: {1: {&apos;weight&apos;:1}}} # dict-of-dicts single edge (0,1)&#xA;&gt;&gt;&gt; G=nx.Graph(d)&#xA;&#xA;instead of the equivalent&#xA;&#xA;&gt;&gt;&gt; G=nx.from_dict_of_dicts(d)&#xA;&#xA;Parameters&#xA;----------&#xA;data : a object to be converted&#xA;   Current known types are:&#xA;     any NetworkX graph&#xA;     dict-of-dicts&#xA;     dist-of-lists&#xA;     list of edges&#xA;     numpy matrix&#xA;     numpy ndarray&#xA;     scipy sparse matrix&#xA;     pygraphviz agraph&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  Otherwise a new graph is created.&#xA;&#xA;multigraph_input : bool (default False)&#xA;  If True and  data is a dict_of_dicts,&#xA;  try to create a multigraph assuming dict_of_dict_of_lists.&#xA;  If data and create_using are both multigraphs then create&#xA;  a multigraph from a multigraph.&#xA;" ilk="function" line="73" name="to_networkx_graph" returns="from_dict_of_lists()" signature="to_networkx_graph(data, create_using=None, multigraph_input=False)"><import line="152" module="numpy" /><import line="166" module="scipy" /><variable ilk="argument" name="data" /><variable ilk="argument" name="create_using" /><variable citdl="False" ilk="argument" name="multigraph_input" /><variable citdl="from_dict_of_dicts()" line="112" name="result" /></scope><scope doc="Return a new undirected representation of the graph G." ilk="function" line="184" lineend="186" name="convert_to_undirected" returns="G.to_undirected()" signature="convert_to_undirected(G)"><variable ilk="argument" name="G" /></scope><scope doc="Return a new directed representation of the graph G." ilk="function" line="189" lineend="191" name="convert_to_directed" returns="G.to_directed()" signature="convert_to_directed(G)"><variable ilk="argument" name="G" /></scope><scope doc="Return adjacency representation of graph as a dictionary of lists.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;   A NetworkX graph&#xA;&#xA;nodelist : list&#xA;   Use only nodes specified in nodelist&#xA;&#xA;Notes&#xA;-----&#xA;Completely ignores edge data for MultiGraph and MultiDiGraph.&#xA;" ilk="function" line="194" lineend="216" name="to_dict_of_lists" returns="dict" signature="to_dict_of_lists(G, nodelist=None)"><variable ilk="argument" name="G" /><variable ilk="argument" name="nodelist" /><variable citdl="dict" line="213" name="d" /></scope><scope doc="Return a graph from a dictionary of lists.&#xA;&#xA;Parameters&#xA;----------&#xA;d : dictionary of lists&#xA;  A dictionary of lists adjacency representation.&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  Otherwise a new graph is created.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; dol= {0:[1]} # single edge (0,1)&#xA;&gt;&gt;&gt; G=nx.from_dict_of_lists(dol)&#xA;&#xA;or&#xA;&gt;&gt;&gt; G=nx.Graph(dol) # use Graph constructor&#xA;" ilk="function" line="218" lineend="253" name="from_dict_of_lists" returns="_prep_create_using()" signature="from_dict_of_lists(d, create_using=None)"><variable ilk="argument" name="d" /><variable ilk="argument" name="create_using" /><variable citdl="_prep_create_using()" line="238" name="G" /><variable citdl="dict" line="244" name="seen" /></scope><scope doc="Return adjacency representation of graph as a dictionary of dictionaries.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;   A NetworkX graph&#xA;&#xA;nodelist : list&#xA;   Use only nodes specified in nodelist&#xA;&#xA;edge_data : list, optional&#xA;   If provided,  the value of the dictionary will be&#xA;   set to edge_data for all edges.  This is useful to make&#xA;   an adjacency matrix type representation with 1 as the edge data.&#xA;   If edgedata is None, the edgedata in G is used to fill the values.&#xA;   If G is a multigraph, the edgedata is a dict for each pair (u,v)." ilk="function" line="256" lineend="293" name="to_dict_of_dicts" returns="dict" signature="to_dict_of_dicts(G, nodelist=None, edge_data=None)"><variable ilk="argument" name="G" /><variable ilk="argument" name="nodelist" /><variable ilk="argument" name="edge_data" /><variable citdl="dict" line="274" name="dod" /></scope><scope doc="Return a graph from a dictionary of dictionaries.&#xA;&#xA;Parameters&#xA;----------&#xA;d : dictionary of dictionaries&#xA;  A dictionary of dictionaries adjacency representation.&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  Otherwise a new graph is created.&#xA;&#xA;multigraph_input : bool (default False)&#xA;   When True, the values of the inner dict are assumed&#xA;   to be containers of edge data for multiple edges.&#xA;   Otherwise this routine assumes the edge data are singletons.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; dod= {0: {1:{&apos;weight&apos;:1}}} # single edge (0,1)&#xA;&gt;&gt;&gt; G=nx.from_dict_of_dicts(dod)&#xA;&#xA;or&#xA;&gt;&gt;&gt; G=nx.Graph(dod) # use Graph constructor&#xA;" ilk="function" line="295" lineend="372" name="from_dict_of_dicts" returns="_prep_create_using()" signature="from_dict_of_dicts(d, create_using=None, multigraph_input=False)"><variable ilk="argument" name="d" /><variable ilk="argument" name="create_using" /><variable citdl="False" ilk="argument" name="multigraph_input" /><variable citdl="_prep_create_using()" line="320" name="G" /><variable citdl="set()" line="340" name="seen" /></scope><scope doc="Return a list of edges in the graph.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;   A NetworkX graph&#xA;&#xA;nodelist : list&#xA;   Use only nodes specified in nodelist&#xA;" ilk="function" line="374" lineend="389" name="to_edgelist" returns="G.edges()" signature="to_edgelist(G, nodelist=None)"><variable ilk="argument" name="G" /><variable ilk="argument" name="nodelist" /></scope><scope doc="Return a graph from a list of edges.&#xA;&#xA;Parameters&#xA;----------&#xA;edgelist : list or iterator&#xA;  Edge tuples&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  Otherwise a new graph is created.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; edgelist= [(0,1)] # single edge (0,1)&#xA;&gt;&gt;&gt; G=nx.from_edgelist(edgelist)&#xA;&#xA;or&#xA;&gt;&gt;&gt; G=nx.Graph(edgelist) # use Graph constructor&#xA;" ilk="function" line="391" lineend="413" name="from_edgelist" returns="_prep_create_using()" signature="from_edgelist(edgelist, create_using=None)"><variable ilk="argument" name="edgelist" /><variable ilk="argument" name="create_using" /><variable citdl="_prep_create_using()" line="411" name="G" /></scope><scope doc="Return the graph adjacency matrix as a NumPy matrix.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;    The NetworkX graph used to construct the NumPy matrix.&#xA;&#xA;nodelist : list, optional&#xA;   The rows and columns are ordered according to the nodes in `nodelist`.&#xA;   If `nodelist` is None, then the ordering is produced by G.nodes().&#xA;&#xA;dtype : NumPy data type, optional&#xA;    A valid single NumPy data type used to initialize the array. &#xA;    This must be a simple type such as int or numpy.float64 and&#xA;    not a compound data type (see to_numpy_recarray)&#xA;    If None, then the NumPy default is used.&#xA;&#xA;order : {&apos;C&apos;, &apos;F&apos;}, optional&#xA;    Whether to store multidimensional data in C- or Fortran-contiguous&#xA;    (row- or column-wise) order in memory. If None, then the NumPy default &#xA;    is used.&#xA;&#xA;multigraph_weight : {sum, min, max}, optional&#xA;    An operator that determines how weights in multigraphs are handled.&#xA;    The default is to sum the weights of the multiple edges.&#xA;&#xA;weight : string or None   optional (default=&apos;weight&apos;)&#xA;    The edge attribute that holds the numerical value used for &#xA;    the edge weight.  If None then all edge weights are 1.&#xA;&#xA;&#xA;Returns&#xA;-------&#xA;M : NumPy matrix&#xA;   Graph adjacency matrix.&#xA;&#xA;See Also&#xA;--------&#xA;to_numpy_recarray, from_numpy_matrix&#xA;&#xA;Notes&#xA;-----&#xA;The matrix entries are assigned with weight edge attribute. When&#xA;an edge does not have the weight attribute, the value of the entry is 1.&#xA;For multiple edges, the values of the entries are the sums of the edge&#xA;attributes for each edge.&#xA;&#xA;When `nodelist` does not contain every node in `G`, the matrix is built &#xA;from the subgraph of `G` that is induced by the nodes in `nodelist`.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_edge(0,1,weight=2)&#xA;&gt;&gt;&gt; G.add_edge(1,0)&#xA;&gt;&gt;&gt; G.add_edge(2,2,weight=3)&#xA;&gt;&gt;&gt; G.add_edge(2,2)&#xA;&gt;&gt;&gt; nx.to_numpy_matrix(G, nodelist=[0,1,2])&#xA;matrix([[ 0.,  2.,  0.],&#xA;        [ 1.,  0.,  0.],&#xA;        [ 0.,  0.,  4.]])" ilk="function" line="415" lineend="528" name="to_numpy_matrix" returns="np.asmatrix()" signature="to_numpy_matrix(G, nodelist=None, dtype=None, order=None, multigraph_weight=sum, weight=&apos;weight&apos;)"><import alias="np" line="480" module="numpy" /><variable ilk="argument" name="G" /><variable citdl="G.nodes()" ilk="argument" name="nodelist" /><variable ilk="argument" name="dtype" /><variable ilk="argument" name="order" /><variable citdl="sum" ilk="argument" name="multigraph_weight" /><variable citdl="str" ilk="argument" name="weight" /><variable citdl="set()" line="488" name="nodeset" /><variable citdl="str" line="490" name="msg" /><variable citdl="len()" line="493" name="nlen" /><variable citdl="bool" line="494" name="undirected" /><variable citdl="dict()" line="495" name="index" /><variable citdl="np.asmatrix()" line="501" name="M" /><variable citdl="dict" line="503" name="operator" /><variable line="505" name="op" /><variable line="511" name="i" /><variable line="511" name="j" /><variable citdl="attrs.get()" line="512" name="e_weight" /></scope><scope doc="Return a graph from numpy matrix.&#xA;&#xA;The numpy matrix is interpreted as an adjacency matrix for the graph.&#xA;&#xA;Parameters&#xA;----------&#xA;A : numpy matrix&#xA;  An adjacency matrix representation of a graph&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  The default is Graph()&#xA;&#xA;Notes&#xA;-----&#xA;If the numpy matrix has a single data type for each matrix entry it&#xA;will be converted to an appropriate Python data type.&#xA;&#xA;If the numpy matrix has a user-specified compound data type the names&#xA;of the data fields will be used as attribute keys in the resulting&#xA;NetworkX graph.&#xA;&#xA;See Also&#xA;--------&#xA;to_numpy_matrix, to_numpy_recarray&#xA;&#xA;Examples&#xA;--------&#xA;Simple integer weights on edges:&#xA;&#xA;&gt;&gt;&gt; import numpy&#xA;&gt;&gt;&gt; A=numpy.matrix([[1,1],[2,1]])&#xA;&gt;&gt;&gt; G=nx.from_numpy_matrix(A)&#xA;&#xA;User defined compound data type on edges:&#xA;&#xA;&gt;&gt;&gt; import numpy&#xA;&gt;&gt;&gt; dt=[(&apos;weight&apos;,float),(&apos;cost&apos;,int)]&#xA;&gt;&gt;&gt; A=numpy.matrix([[(1.0,2)]],dtype=dt)&#xA;&gt;&gt;&gt; G=nx.from_numpy_matrix(A)&#xA;&gt;&gt;&gt; G.edges(data=True)&#xA;[(0, 0, {&apos;cost&apos;: 2, &apos;weight&apos;: 1.0})]" ilk="function" line="531" lineend="623" name="from_numpy_matrix" returns="_prep_create_using()" signature="from_numpy_matrix(A, create_using=None)"><import alias="np" line="590" module="numpy" /><variable ilk="argument" name="A" /><variable ilk="argument" name="create_using" /><variable citdl="dict" line="574" name="kind_to_python_type" /><variable citdl="chr()" line="583" name="blurb" /><variable citdl="_prep_create_using()" line="595" name="G" /><variable citdl="A.dtype" line="600" name="dt" /><variable line="602" name="python_type" /><variable line="609" name="y" /><variable line="609" name="x" /><variable citdl="sorted()" line="613" name="fields" /><variable citdl="dict" line="616" name="attr" /></scope><scope doc="Return the graph adjacency matrix as a NumPy recarray.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;    The NetworkX graph used to construct the NumPy matrix.&#xA;&#xA;nodelist : list, optional&#xA;   The rows and columns are ordered according to the nodes in `nodelist`.&#xA;   If `nodelist` is None, then the ordering is produced by G.nodes().&#xA;&#xA;dtype : NumPy data-type, optional&#xA;    A valid NumPy named dtype used to initialize the NumPy recarray. &#xA;    The data type names are assumed to be keys in the graph edge attribute &#xA;    dictionary.&#xA;&#xA;order : {&apos;C&apos;, &apos;F&apos;}, optional&#xA;    Whether to store multidimensional data in C- or Fortran-contiguous&#xA;    (row- or column-wise) order in memory. If None, then the NumPy default &#xA;    is used.&#xA;&#xA;Returns&#xA;-------&#xA;M : NumPy recarray&#xA;   The graph with specified edge data as a Numpy recarray &#xA;&#xA;Notes&#xA;-----&#xA;When `nodelist` does not contain every node in `G`, the matrix is built &#xA;from the subgraph of `G` that is induced by the nodes in `nodelist`.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.Graph()&#xA;&gt;&gt;&gt; G.add_edge(1,2,weight=7.0,cost=5)&#xA;&gt;&gt;&gt; A=nx.to_numpy_recarray(G,dtype=[(&apos;weight&apos;,float),(&apos;cost&apos;,int)])&#xA;&gt;&gt;&gt; print(A.weight)&#xA;[[ 0.  7.]&#xA; [ 7.  0.]]&#xA;&gt;&gt;&gt; print(A.cost)&#xA;[[0 5]&#xA; [5 0]]" ilk="function" line="626" lineend="703" name="to_numpy_recarray" returns="M.view()" signature="to_numpy_recarray(G, nodelist=None, dtype=[(&apos;weight&apos;, float)], order=None)"><import alias="np" line="673" module="numpy" /><variable ilk="argument" name="G" /><variable citdl="G.nodes()" ilk="argument" name="nodelist" /><variable citdl="list" ilk="argument" name="dtype" /><variable ilk="argument" name="order" /><variable citdl="set()" line="684" name="nodeset" /><variable citdl="str" line="686" name="msg" /><variable citdl="len()" line="689" name="nlen" /><variable citdl="bool" line="690" name="undirected" /><variable citdl="dict()" line="691" name="index" /><variable citdl="np.zeros()" line="692" name="M" /><variable citdl="M.dtype.names" line="694" name="names" /><variable line="697" name="i" /><variable line="697" name="j" /><variable citdl="tuple()" line="698" name="values" /></scope><scope doc="Return the graph adjacency matrix as a SciPy sparse matrix.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;    The NetworkX graph used to construct the NumPy matrix.&#xA;&#xA;nodelist : list, optional&#xA;   The rows and columns are ordered according to the nodes in `nodelist`.&#xA;   If `nodelist` is None, then the ordering is produced by G.nodes().&#xA;&#xA;dtype : NumPy data-type, optional&#xA;    A valid NumPy dtype used to initialize the array. If None, then the&#xA;    NumPy default is used.&#xA;&#xA;weight : string or None   optional (default=&apos;weight&apos;)&#xA;    The edge attribute that holds the numerical value used for &#xA;    the edge weight.  If None then all edge weights are 1.&#xA;&#xA;format : str in {&apos;bsr&apos;, &apos;csr&apos;, &apos;csc&apos;, &apos;coo&apos;, &apos;lil&apos;, &apos;dia&apos;, &apos;dok&apos;} &#xA;    The type of the matrix to be returned (default &apos;csr&apos;).  For&#xA;    some algorithms different implementations of sparse matrices&#xA;    can perform better.  See [1]_ for details.&#xA;&#xA;Returns&#xA;-------&#xA;M : SciPy sparse matrix&#xA;   Graph adjacency matrix.&#xA;&#xA;Notes&#xA;-----&#xA;The matrix entries are populated using the edge attribute held in&#xA;parameter weight. When an edge does not have that attribute, the&#xA;value of the entry is 1.&#xA;&#xA;For multiple edges the matrix values are the sums of the edge weights.&#xA;&#xA;When `nodelist` does not contain every node in `G`, the matrix is built&#xA;from the subgraph of `G` that is induced by the nodes in `nodelist`.&#xA;&#xA;Uses coo_matrix format. To convert to other formats specify the&#xA;format= keyword.&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G = nx.MultiDiGraph()&#xA;&gt;&gt;&gt; G.add_edge(0,1,weight=2)&#xA;&gt;&gt;&gt; G.add_edge(1,0)&#xA;&gt;&gt;&gt; G.add_edge(2,2,weight=3)&#xA;&gt;&gt;&gt; G.add_edge(2,2)&#xA;&gt;&gt;&gt; S = nx.to_scipy_sparse_matrix(G, nodelist=[0,1,2])&#xA;&gt;&gt;&gt; print(S.todense())&#xA;[[0 2 0]&#xA; [1 0 0]&#xA; [0 0 4]]&#xA;&#xA;References&#xA;----------&#xA;.. [1] Scipy Dev. References, &quot;Sparse Matrices&quot;,&#xA;   http://docs.scipy.org/doc/scipy/reference/sparse.html" ilk="function" line="706" lineend="801" name="to_scipy_sparse_matrix" returns="M.asformat()" signature="to_scipy_sparse_matrix(G, nodelist=None, dtype=None, weight=&apos;weight&apos;, format=&apos;csr&apos;)"><import line="770" module="scipy" symbol="sparse" /><variable ilk="argument" name="G" /><variable ilk="argument" name="nodelist" /><variable ilk="argument" name="dtype" /><variable citdl="str" ilk="argument" name="weight" /><variable citdl="str" ilk="argument" name="format" /><variable citdl="len()" line="777" name="nlen" /><variable citdl="str" line="782" name="msg" /><variable citdl="dict()" line="785" name="index" /><variable citdl="list" line="787" name="data" /><variable citdl="list" line="787" name="col" /><variable citdl="list" line="787" name="row" /><variable citdl="sparse.coo_matrix()" line="793" name="M" /></scope><scope doc="Return a graph from scipy sparse matrix adjacency list.&#xA;&#xA;Parameters&#xA;----------&#xA;A : scipy sparse matrix&#xA;  An adjacency matrix representation of a graph&#xA;&#xA;create_using : NetworkX graph&#xA;   Use specified graph for result.  The default is Graph()&#xA;&#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; import scipy.sparse&#xA;&gt;&gt;&gt; A=scipy.sparse.eye(2,2,1)&#xA;&gt;&gt;&gt; G=nx.from_scipy_sparse_matrix(A)&#xA;" ilk="function" line="803" lineend="835" name="from_scipy_sparse_matrix" returns="_prep_create_using()" signature="from_scipy_sparse_matrix(A, create_using=None)"><variable ilk="argument" name="A" /><variable ilk="argument" name="create_using" /><variable citdl="_prep_create_using()" line="821" name="G" /><variable citdl="A.tolil()" line="824" name="AA" /></scope><scope ilk="function" line="838" lineend="847" name="setup_module" signature="setup_module(module)"><import line="839" module="nose" symbol="SkipTest" /><import line="841" module="numpy" /><import line="845" module="scipy" /><variable ilk="argument" name="module" /></scope></scope>