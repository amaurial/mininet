<scope ilk="blob" lang="Python" name="relabel" src="/usr/lib/pymodules/python2.7/networkx/relabel.py"><import alias="nx" line="7" module="networkx" /><variable citdl="__builtins__.str.join()" line="8" name="__author__" /><variable citdl="list" line="11" name="__all__" /><scope doc="Relabel the nodes of the graph G.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;   A NetworkX graph &#xA;&#xA;mapping : dictionary &#xA;   A dictionary with the old labels as keys and new labels as values.&#xA;   A partial mapping is allowed.&#xA;&#xA;copy : bool (optional, default=True)       &#xA;   If True return a copy or if False relabel the nodes in place.&#xA;   &#xA;Examples&#xA;--------&#xA;&gt;&gt;&gt; G=nx.path_graph(3)  # nodes 0-1-2&#xA;&gt;&gt;&gt; mapping={0:&apos;a&apos;,1:&apos;b&apos;,2:&apos;c&apos;}&#xA;&gt;&gt;&gt; H=nx.relabel_nodes(G,mapping)&#xA;&gt;&gt;&gt; print(H.nodes())&#xA;[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;]&#xA;&#xA;&gt;&gt;&gt; G=nx.path_graph(26) # nodes 0..25&#xA;&gt;&gt;&gt; mapping=dict(zip(G.nodes(),&quot;abcdefghijklmnopqrstuvwxyz&quot;))&#xA;&gt;&gt;&gt; H=nx.relabel_nodes(G,mapping) # nodes a..z&#xA;&gt;&gt;&gt; mapping=dict(zip(G.nodes(),range(1,27)))&#xA;&gt;&gt;&gt; G1=nx.relabel_nodes(G,mapping) # nodes 1..26&#xA;&#xA;Partial in-place mapping:&#xA;&#xA;&gt;&gt;&gt; G=nx.path_graph(3)  # nodes 0-1-2&#xA;&gt;&gt;&gt; mapping={0:&apos;a&apos;,1:&apos;b&apos;} # 0-&gt;&apos;a&apos; and 1-&gt;&apos;b&apos;&#xA;&gt;&gt;&gt; G=nx.relabel_nodes(G,mapping, copy=False)&#xA;&gt;&gt;&gt; print(G.nodes())&#xA;[2, &apos;b&apos;, &apos;a&apos;]&#xA;&#xA;Mapping as function:&#xA;&#xA;&gt;&gt;&gt; G=nx.path_graph(3)&#xA;&gt;&gt;&gt; def mapping(x):&#xA;...    return x**2&#xA;&gt;&gt;&gt; H=nx.relabel_nodes(G,mapping)&#xA;&gt;&gt;&gt; print(H.nodes())&#xA;[0, 1, 4]&#xA;&#xA;Notes&#xA;-----&#xA;Only the nodes specified in the mapping will be relabeled. &#xA;&#xA;The keyword setting copy=False modifies the graph in place.&#xA;This is not always possible if the mapping is circular.&#xA;In that case use copy=True.&#xA;&#xA;See Also&#xA;--------&#xA;convert_node_labels_to_integers" ilk="function" line="13" lineend="80" name="relabel_nodes" returns="_relabel_inplace()" signature="relabel_nodes(G, mapping, copy=True)"><variable ilk="argument" name="G" /><variable ilk="argument" name="mapping" /><variable citdl="True" ilk="argument" name="copy" /><variable citdl="dict()" line="74" name="m" /></scope><scope attributes="protected" ilk="function" line="83" lineend="130" name="_relabel_inplace" signature="_relabel_inplace(G, mapping)"><variable ilk="argument" name="G" /><variable ilk="argument" name="mapping" /><variable citdl="set()" line="84" name="old_labels" /><variable citdl="set()" line="85" name="new_labels" /><variable citdl="nx.DiGraph()" line="89" name="D" /><variable citdl="nx.topological_sort()" line="92" name="nodes" /><variable citdl="G.is_multigraph()" line="102" name="multigraph" /><variable citdl="G.is_directed()" line="103" name="directed" /><variable line="107" name="new" /><variable citdl="list" line="115" name="new_edges" /></scope><scope attributes="protected" ilk="function" line="132" lineend="146" name="_relabel_copy" returns="G.__class__()" signature="_relabel_copy(G, mapping)"><variable ilk="argument" name="G" /><variable ilk="argument" name="mapping" /><variable citdl="G.__class__()" line="133" name="H" /></scope><scope doc="Return a copy of G node labels replaced with integers.&#xA;&#xA;Parameters&#xA;----------&#xA;G : graph&#xA;   A NetworkX graph &#xA;&#xA;first_label : int, optional (default=0)       &#xA;   An integer specifying the offset in numbering nodes.&#xA;   The n new integer labels are numbered first_label, ..., n-1+first_label.&#xA;&#xA;ordering : string&#xA;    &quot;default&quot; : inherit node ordering from G.nodes() &#xA;    &quot;sorted&quot;  : inherit node ordering from sorted(G.nodes())&#xA;    &quot;increasing degree&quot; : nodes are sorted by increasing degree&#xA;    &quot;decreasing degree&quot; : nodes are sorted by decreasing degree&#xA;&#xA;discard_old_labels : bool, optional (default=True)&#xA;   If True discard old labels. If False, create a node attribute &#xA;   &apos;old_label&apos; to hold the old labels." ilk="function" line="149" lineend="212" name="convert_node_labels_to_integers" returns="relabel_nodes()" signature="convert_node_labels_to_integers(G, first_label=0, ordering=&apos;default&apos;, discard_old_labels=True)"><variable ilk="argument" name="G" /><variable citdl="int" ilk="argument" name="first_label" /><variable citdl="str" ilk="argument" name="ordering" /><variable citdl="True" ilk="argument" name="discard_old_labels" /><variable citdl="G.number_of_nodes()" line="190" name="N" /><variable citdl="dict()" line="192" name="mapping" /><variable citdl="G.nodes()" line="194" name="nlist" /><variable citdl="list" line="198" name="dv_pairs" /><variable citdl="relabel_nodes()" line="208" name="H" /></scope></scope>