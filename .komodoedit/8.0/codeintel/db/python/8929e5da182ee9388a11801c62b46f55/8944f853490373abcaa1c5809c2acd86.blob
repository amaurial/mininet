<scope ilk="blob" lang="Python" name="recoco" src="/home/mininet/new_pox/pox/pox/lib/recoco/recoco.py"><import line="18" module="__future__" symbol="print_function" /><import line="19" module="collections" symbol="deque" /><import line="20" module="Queue" symbol="PriorityQueue" /><import line="21" module="Queue" symbol="Queue" /><import line="22" module="time" /><import line="23" module="threading" /><import line="24" module="threading" symbol="Thread" /><import line="25" module="select" /><import line="26" module="traceback" /><import line="27" module="os" /><import line="28" module="socket" /><import line="29" module="pox.lib.util" /><import line="30" module="random" /><import line="31" module="pox.lib.epoll_select" symbol="EpollSelect" /><import line="841" module="code" /><variable citdl="int" line="33" name="CYCLE_MAXIMUM" /><variable citdl="object()" line="37" name="ABORT" /><variable line="39" name="defaultScheduler" /><variable citdl="int" line="41" name="nextTaskID" /><scope ilk="function" line="42" lineend="45" name="generateTaskID" returns="int" signature="generateTaskID()" /><scope classrefs="object" ilk="class" line="47" lineend="98" name="BaseTask"><variable citdl="generateTaskID()" line="48" name="id" /><variable citdl="int" line="50" name="priority" /><scope doc="Creates a task and starts it on the default scheduler with the&#xA;default priority." ilk="function" line="53" lineend="60" name="new" returns="cls()" signature="new(*args, **kw)"><variable citdl="BaseTask" ilk="argument" name="cls" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="cls()" line="58" name="o" /></scope><scope attributes="__ctor__" ilk="function" line="62" lineend="68" name="__init__" signature="BaseTask(*args, **kw)"><variable citdl="BaseTask" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><variable attributes="__instancevar__" citdl="self.run()" line="66" name="gen" /><variable attributes="__instancevar__" line="67" name="rv" /><variable attributes="__instancevar__" line="68" name="rf" /><scope doc="Schedules this task.&#xA;&#xA;See Scheduler.schedule() and Scheduler.fast_schedule() for the meaning&#xA;of the &apos;fast&apos; argument." ilk="function" line="70" lineend="82" name="start" signature="start(scheduler=None, priority=None, fast=False)"><variable citdl="BaseTask" ilk="argument" name="self" /><variable ilk="argument" name="scheduler" /><variable ilk="argument" name="priority" /><variable citdl="False" ilk="argument" name="fast" /></scope><scope ilk="function" line="84" lineend="94" name="execute" returns="bool" signature="execute()"><variable citdl="BaseTask" ilk="argument" name="self" /><variable citdl="rf()" line="86" name="v" /></scope><scope ilk="function" line="96" lineend="98" name="run" signature="run()"><variable citdl="BaseTask" ilk="argument" name="self" /></scope></scope><scope classrefs="BaseTask" doc="Provides an interface close to threading.Thread" ilk="class" line="101" lineend="131" name="Task"><scope attributes="__ctor__" ilk="function" line="106" lineend="122" name="__init__" signature="Task(group=None, target=None, name=None, args=(), kwargs={})"><variable citdl="Task" ilk="argument" name="self" /><variable ilk="argument" name="group" /><variable ilk="argument" name="target" /><variable ilk="argument" name="name" /><variable citdl="tuple" ilk="argument" name="args" /><variable citdl="dict" ilk="argument" name="kwargs" /></scope><variable attributes="__instancevar__" citdl="generateTaskID()" line="110" name="id" /><variable attributes="__instancevar__" line="111" name="rv" /><variable attributes="__instancevar__" citdl="str()" line="113" name="name" /><variable attributes="__instancevar__" line="116" name="target" /><variable attributes="__instancevar__" citdl="tuple" line="117" name="args" /><variable attributes="__instancevar__" citdl="dict" line="118" name="kwargs" /><variable attributes="__instancevar__" citdl="self.run()" line="120" name="gen" /><scope ilk="function" line="124" name="run" signature="run()"><variable citdl="Task" ilk="argument" name="self" /><variable citdl="target()" line="125" name="g" /></scope><scope ilk="function" line="130" lineend="131" name="__str__" returns="str" signature="__str__()"><variable citdl="Task" ilk="argument" name="self" /></scope></scope><scope classrefs="object" doc="Scheduler for Tasks " ilk="class" line="134" lineend="308" name="Scheduler"><scope attributes="__ctor__" ilk="function" line="136" lineend="154" name="__init__" signature="Scheduler(isDefaultScheduler=None, startInThread=True, daemon=False, useEpoll=False)"><variable citdl="Scheduler" ilk="argument" name="self" /><variable ilk="argument" name="isDefaultScheduler" /><variable citdl="True" ilk="argument" name="startInThread" /><variable citdl="False" ilk="argument" name="daemon" /><variable citdl="False" ilk="argument" name="useEpoll" /><variable citdl="Scheduler" line="151" name="defaultScheduler" /></scope><variable attributes="protected __instancevar__" citdl="deque()" line="138" name="_ready" /><variable attributes="protected __instancevar__" citdl="True" line="139" name="_hasQuit" /><variable attributes="protected __instancevar__" citdl="SelectHub()" line="140" name="_selectHub" /><variable attributes="protected __instancevar__" citdl="Thread()" line="141" name="_thread" /><variable attributes="protected __instancevar__" citdl="threading.Event()" line="142" name="_event" /><variable attributes="protected __instancevar__" citdl="threading.Lock()" line="144" name="_lock" /><variable attributes="protected __instancevar__" citdl="CallLaterTask()" line="145" name="_callLaterTask" /><variable attributes="protected __instancevar__" citdl="True" line="146" name="_allDone" /><scope ilk="function" line="156" lineend="158" name="__del__" signature="__del__()"><variable citdl="Scheduler" ilk="argument" name="self" /></scope><scope doc="Calls func with the given arguments at some later point, within this&#xA;scheduler.  This is a good way for another thread to call something in&#xA;a co-op-thread-safe manner." ilk="function" line="160" lineend="172" name="callLater" signature="callLater(func, *args, **kw)"><variable citdl="Scheduler" ilk="argument" name="self" /><variable ilk="argument" name="func" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope ilk="function" line="174" lineend="177" name="runThreaded" signature="runThreaded(daemon=False)"><variable citdl="Scheduler" ilk="argument" name="self" /><variable citdl="False" ilk="argument" name="daemon" /></scope><scope ilk="function" line="179" lineend="180" name="synchronized" returns="Synchronizer()" signature="synchronized()"><variable citdl="Scheduler" ilk="argument" name="self" /></scope><scope doc="Schedule the given task to run later.&#xA;If first is True, the task will be the next to run.&#xA;&#xA;Unlike fast_schedule(), this method will not schedule a task to run&#xA;multiple times.  The one exception is if a Task actually schedules&#xA;itself.  The easiest way to avoid this is simply not to do it.&#xA;See fast_schedule() and ScheduleTask for more info." ilk="function" line="182" lineend="207" name="schedule" returns="bool" signature="schedule(task, first=False)"><import line="199" module="logging" /><variable citdl="Scheduler" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable citdl="False" ilk="argument" name="first" /><variable citdl="ScheduleTask()" line="206" name="st" /></scope><scope doc="Schedule the given task to run later.&#xA;If first is True, the task will be the next to run.&#xA;&#xA;This method does not protect you from scheduling the same Task more&#xA;than once, which you probably really don&apos;t want to do.&#xA;&#xA;If you are scheduling an existing Task (waking it) from another Task,&#xA;you should either implement your own logic to ensure that you don&apos;t&#xA;schedule it multiple times, or you should just use schedule().&#xA;&#xA;If you are scheduling an existing Task (waking it) from any thread&#xA;besides the one the scheduler is running on, there&apos;s a race condition&#xA;which makes it nontrivial to ensure that multiple schedulings never&#xA;happen, and you should just use schedule() for such Tasks.&#xA;&#xA;If you are scheduling a new Task that you just created, this method&#xA;is always safe." ilk="function" line="209" lineend="238" name="fast_schedule" signature="fast_schedule(task, first=False)"><variable citdl="Scheduler" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable citdl="False" ilk="argument" name="first" /></scope><scope ilk="function" line="240" lineend="241" name="quit" signature="quit()"><variable citdl="Scheduler" ilk="argument" name="self" /></scope><scope ilk="function" line="243" lineend="255" name="run" signature="run()"><variable citdl="Scheduler" ilk="argument" name="self" /><variable citdl="self.cycle()" line="250" name="r" /></scope><scope ilk="function" line="257" lineend="308" name="cycle" returns="bool" signature="cycle()"><variable citdl="Scheduler" ilk="argument" name="self" /><variable citdl="self._ready.popleft()" line="262" name="t" /><variable citdl="t.execute()" line="276" name="rv" /></scope></scope><scope classrefs="object" doc="A base class for what can be thought of as syscalls for Tasks.&#xA;The separation between __init__ and execute may seem sort of artificial, but&#xA;it serves an actual purpose, which is that it makes it impossible for a task&#xA;to accidentally start to make a syscall (by instantiating a BlockingOperation)&#xA;without actually yielding." ilk="class" line="314" lineend="328" name="BlockingOperation"><scope attributes="__ctor__" doc="When the syscall is made by a task, this is executed " ilk="function" line="322" lineend="324" name="__init__" signature="BlockingOperation()"><variable citdl="BlockingOperation" ilk="argument" name="self" /></scope><scope doc="Scheduler calls this to actually execute the syscall " ilk="function" line="326" lineend="328" name="execute" signature="execute(task, scheduler)"><variable citdl="BlockingOperation" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="BlockingOperation" doc="Syscall that calls an actual blocking operation (like a real .recv()).&#xA;In order to keep from blocking, it calls it on another thread.&#xA;The return value is (ret_val, exc_info), one of which is always None." ilk="class" line="331" lineend="368" name="CallBlocking"><scope ilk="function" line="338" lineend="339" name="new" returns="CallBlocking.new._cls()" signature="new(_func, *_args, **_kw)"><variable citdl="CallBlocking" ilk="argument" name="_cls" /><variable ilk="argument" name="_func" /><variable attributes="varargs" ilk="argument" name="_args" /><variable attributes="kwargs" ilk="argument" name="_kw" /></scope><scope attributes="__ctor__" ilk="function" line="341" lineend="348" name="__init__" signature="CallBlocking(func, args=(), kw={})"><variable citdl="CallBlocking" ilk="argument" name="self" /><variable ilk="argument" name="func" /><variable citdl="tuple" ilk="argument" name="args" /><variable citdl="dict" ilk="argument" name="kw" /></scope><variable attributes="__instancevar__" citdl="threading.Thread()" line="342" name="t" /><variable attributes="__instancevar__" line="343" name="scheduler" /><variable attributes="__instancevar__" line="344" name="task" /><variable attributes="__instancevar__" line="346" name="func" /><variable attributes="__instancevar__" citdl="tuple" line="347" name="args" /><variable attributes="__instancevar__" citdl="dict" line="348" name="kw" /><scope attributes="protected" ilk="function" line="350" lineend="357" name="_proc" signature="_proc()"><import line="354" module="sys" /><variable citdl="CallBlocking" ilk="argument" name="self" /></scope><scope ilk="function" line="359" lineend="368" name="execute" signature="execute(task, scheduler)"><variable citdl="CallBlocking" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="BlockingOperation" doc="Syscall that kills the scheduler" ilk="class" line="371" lineend="379" name="Exit"><scope attributes="__ctor__" ilk="function" line="375" lineend="376" name="__init__" signature="Exit()"><variable citdl="Exit" ilk="argument" name="self" /></scope><scope ilk="function" line="378" lineend="379" name="execute" signature="execute(task, scheduler)"><variable citdl="Exit" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="BlockingOperation" doc="Sleep for specified amount of time (seconds)&#xA;None means unscheduler (i.e., sleep until an outside force wakes it)&#xA;0 means reschedule for later (no additional time)" ilk="class" line="382" lineend="400" name="Sleep"><scope attributes="__ctor__" ilk="function" line="388" lineend="390" name="__init__" signature="Sleep(timeToWake=None, absoluteTime=False)"><variable citdl="Sleep" ilk="argument" name="self" /><variable ilk="argument" name="timeToWake" /><variable citdl="False" ilk="argument" name="absoluteTime" /></scope><variable attributes="protected __instancevar__" line="390" name="_t" /><scope ilk="function" line="392" lineend="400" name="execute" signature="execute(task, scheduler)"><variable citdl="Sleep" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="BlockingOperation" doc="Should be very similar to Python select.select()" ilk="class" line="403" lineend="412" name="Select"><scope attributes="__ctor__" ilk="function" line="407" lineend="409" name="__init__" signature="Select(*args, **kw)"><variable citdl="Select" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><variable attributes="protected __instancevar__" line="408" name="_args" /><variable attributes="protected __instancevar__" line="409" name="_kw" /><scope ilk="function" line="411" lineend="412" name="execute" signature="execute(task, scheduler)"><variable citdl="Select" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><variable citdl="int" line="415" name="defaultRecvFlags" /><scope classrefs="BlockingOperation" ilk="class" line="421" lineend="449" name="Recv"><scope attributes="__ctor__" doc="Recv call on fd." ilk="function" line="422" lineend="430" name="__init__" signature="Recv(fd, bufsize=1024*8, flags=defaultRecvFlags, timeout=None)"><variable citdl="Recv" ilk="argument" name="self" /><variable ilk="argument" name="fd" /><variable citdl="int" ilk="argument" name="bufsize" /><variable citdl="int" ilk="argument" name="flags" /><variable ilk="argument" name="timeout" /></scope><variable attributes="protected __instancevar__" line="427" name="_fd" /><variable attributes="protected __instancevar__" citdl="int" line="428" name="_length" /><variable attributes="protected __instancevar__" line="429" name="_timeout" /><variable attributes="protected __instancevar__" citdl="int" line="430" name="_flags" /><scope attributes="protected" ilk="function" line="432" lineend="444" name="_recvReturnFunc" returns="sock.recv()" signature="_recvReturnFunc(task)"><variable citdl="Recv" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable line="438" name="sock" /></scope><scope ilk="function" line="446" lineend="449" name="execute" signature="execute(task, scheduler)"><variable citdl="Recv" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="BlockingOperation" ilk="class" line="452" lineend="486" name="Send"><scope attributes="__ctor__" ilk="function" line="453" lineend="457" name="__init__" signature="Send(fd, data)"><variable citdl="Send" ilk="argument" name="self" /><variable ilk="argument" name="fd" /><variable ilk="argument" name="data" /></scope><variable attributes="protected __instancevar__" line="454" name="_fd" /><variable attributes="protected __instancevar__" citdl="list" line="455" name="_data" /><variable attributes="protected __instancevar__" citdl="int" line="456" name="_sent" /><variable attributes="protected __instancevar__" line="457" name="_scheduler" /><scope attributes="protected" ilk="function" line="459" lineend="481" name="_sendReturnFunc" returns="object()" signature="_sendReturnFunc(task)"><variable citdl="Send" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable line="461" name="sock" /><variable citdl="list" line="469" name="data" /><variable citdl="sock.send()" line="471" name="l" /></scope><scope ilk="function" line="483" lineend="486" name="execute" signature="execute(task, scheduler)"><variable citdl="Send" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="scheduler" /></scope></scope><scope classrefs="object" doc="This class is a single select() loop that handles all Select() requests for&#xA;a scheduler as well as timed wakes (i.e., Sleep())." ilk="class" line="489" lineend="640" name="SelectHub"><scope attributes="__ctor__" ilk="function" line="494" lineend="507" name="__init__" signature="SelectHub(scheduler, useEpoll=False)"><variable citdl="SelectHub" ilk="argument" name="self" /><variable ilk="argument" name="scheduler" /><variable citdl="False" ilk="argument" name="useEpoll" /></scope><variable attributes="protected __instancevar__" citdl="list" line="496" name="_sleepers" /><variable attributes="protected __instancevar__" citdl="Queue()" line="497" name="_incoming" /><variable attributes="protected __instancevar__" line="499" name="_scheduler" /><variable attributes="protected __instancevar__" citdl="pox.lib.util.makePinger()" line="500" name="_pinger" /><variable attributes="__instancevar__" line="501" name="epoll" /><variable attributes="protected __instancevar__" citdl="False" line="503" name="_ready" /><variable attributes="protected __instancevar__" citdl="Thread()" line="505" name="_thread" /><scope attributes="protected" ilk="function" line="512" lineend="612" name="_threadProc" signature="_threadProc()"><variable citdl="SelectHub" ilk="argument" name="self" /><variable citdl="dict" line="513" name="tasks" /><variable citdl="list" line="514" name="timeouts" /><variable citdl="dict" line="515" name="rets" /><variable citdl="time.time()" line="521" name="timeout" /><variable citdl="dict" line="530" name="rl" /><variable citdl="dict" line="531" name="wl" /><variable citdl="dict" line="532" name="xl" /><variable citdl="t" line="535" name="timeoutTask" /><variable citdl="time.time()" line="537" name="now" /><variable citdl="list" line="539" name="expired" /><variable citdl="time.time()" line="549" name="tt" /><variable line="568" name="xo" /><variable line="568" name="wo" /><variable line="568" name="ro" /><variable citdl="self._incoming.get()" line="585" name="stuff" /><variable line="586" name="task" /></scope><scope ilk="function" line="614" lineend="621" name="registerSelect" signature="registerSelect(task, rlist=None, wlist=None, xlist=None, timeout=None, timeIsAbsolute=False)"><variable citdl="SelectHub" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="rlist" /><variable ilk="argument" name="wlist" /><variable ilk="argument" name="xlist" /><variable ilk="argument" name="timeout" /><variable citdl="False" ilk="argument" name="timeIsAbsolute" /></scope><scope attributes="protected" doc="Cycle the wait thread so that new timers or FDs can be picked up" ilk="function" line="623" lineend="627" name="_cycle" signature="_cycle()"><variable citdl="SelectHub" ilk="argument" name="self" /></scope><scope doc="Register a task to be wakened up interval units in the future.&#xA;It means timeToWake seconds in the future if absoluteTime is False." ilk="function" line="629" lineend="635" name="registerTimer" returns="SelectHub.registerSelect()" signature="registerTimer(task, timeToWake, timeIsAbsolute=False)"><variable citdl="SelectHub" ilk="argument" name="self" /><variable ilk="argument" name="task" /><variable ilk="argument" name="timeToWake" /><variable citdl="False" ilk="argument" name="timeIsAbsolute" /></scope><scope attributes="protected" ilk="function" line="637" lineend="640" name="_return" signature="_return(sleepingTask, returnVal)"><variable citdl="SelectHub" ilk="argument" name="self" /><variable ilk="argument" name="sleepingTask" /><variable ilk="argument" name="returnVal" /></scope></scope><scope classrefs="BaseTask" doc="If multiple real threads (such as a recoco scheduler thread and any&#xA;other thread, or any two other threads) try to schedule (&quot;wake&quot;) the&#xA;same Task with Scheduler.fast_schedule(), there is a race condition where&#xA;the Task may get scheduled multiple times, which is probably quite bad.&#xA;&#xA;Scheduler.schedule() fixes this by creating one of these ScheduleTasks,&#xA;and it&apos;s this ScheduleTask that actually calls fast_schedule().  This&#xA;way, the Task is only ever *really* scheduled from the scheduler thread&#xA;and the race condition doesn&apos;t exist." ilk="class" line="643" lineend="671" name="ScheduleTask"><scope attributes="__ctor__" ilk="function" line="655" lineend="658" name="__init__" signature="ScheduleTask(scheduler, task)"><variable citdl="ScheduleTask" ilk="argument" name="self" /><variable ilk="argument" name="scheduler" /><variable ilk="argument" name="task" /></scope><variable attributes="protected __instancevar__" line="657" name="_scheduler" /><variable attributes="protected __instancevar__" line="658" name="_task" /><scope ilk="function" line="660" lineend="671" name="run" signature="run()"><import line="666" module="logging" /><variable citdl="ScheduleTask" ilk="argument" name="self" /></scope></scope><scope classrefs="BaseTask" ilk="class" line="674" lineend="684" name="SyncTask"><scope attributes="__ctor__" ilk="function" line="675" lineend="680" name="__init__" signature="SyncTask(*args, **kw)"><variable citdl="SyncTask" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><variable attributes="__instancevar__" citdl="threading.Lock()" line="677" name="inlock" /><variable attributes="__instancevar__" citdl="threading.Lock()" line="678" name="outlock" /><scope ilk="function" line="682" lineend="684" name="run" signature="run()"><variable citdl="SyncTask" ilk="argument" name="self" /></scope></scope><scope classrefs="object" ilk="class" line="687" lineend="706" name="Synchronizer"><scope attributes="__ctor__" ilk="function" line="688" lineend="693" name="__init__" signature="Synchronizer(scheduler=None)"><variable citdl="Synchronizer" ilk="argument" name="self" /><variable ilk="argument" name="scheduler" /></scope><variable attributes="__instancevar__" line="691" name="scheduler" /><variable attributes="__instancevar__" citdl="SyncTask" line="692" name="syncer" /><variable attributes="__instancevar__" citdl="int" line="693" name="enter" /><scope ilk="function" line="695" lineend="701" name="__enter__" returns="SyncTask" signature="__enter__()"><variable citdl="Synchronizer" ilk="argument" name="self" /></scope><scope ilk="function" line="703" lineend="706" name="__exit__" signature="__exit__(type_, value, traceback)"><variable citdl="Synchronizer" ilk="argument" name="self" /><variable ilk="argument" name="type_" /><variable ilk="argument" name="value" /><variable ilk="argument" name="traceback" /></scope></scope><scope classrefs="Task" doc="A simple timer.&#xA;&#xA;timeToWake     Amount of time to wait before calling callback (seconds)&#xA;callback       Some callable to be called when the timer expires&#xA;absoluteTime   A specific time to fire (as from time.time())&#xA;recurring      Whether to call repeatedly or just once&#xA;args, kw       Args and keyword args for the callback&#xA;scheduler      The recoco scheduler to use (None means default scheduler)&#xA;started        If False, requires you to call .start() to begin timer&#xA;selfStoppable  If True, the callback can return False to cancel the timer" ilk="class" line="709" lineend="754" name="Timer"><scope attributes="__ctor__" ilk="function" line="722" lineend="741" name="__init__" signature="Timer(timeToWake, callback, absoluteTime=False, recurring=False, args=(), kw={}, scheduler=None, started=True, selfStoppable=True)"><variable citdl="Timer" ilk="argument" name="self" /><variable ilk="argument" name="timeToWake" /><variable ilk="argument" name="callback" /><variable citdl="False" ilk="argument" name="absoluteTime" /><variable citdl="False" ilk="argument" name="recurring" /><variable citdl="tuple" ilk="argument" name="args" /><variable citdl="dict" ilk="argument" name="kw" /><variable ilk="argument" name="scheduler" /><variable citdl="True" ilk="argument" name="started" /><variable citdl="True" ilk="argument" name="selfStoppable" /></scope><variable attributes="protected __instancevar__" citdl="True" line="728" name="_self_stoppable" /><variable attributes="protected __instancevar__" citdl="time.time()" line="729" name="_next" /><variable attributes="protected __instancevar__" line="730" name="_interval" /><variable attributes="protected __instancevar__" citdl="True" line="734" name="_cancelled" /><variable attributes="protected __instancevar__" citdl="False" line="736" name="_recurring" /><variable attributes="protected __instancevar__" line="737" name="_callback" /><variable attributes="protected __instancevar__" citdl="tuple" line="738" name="_args" /><variable attributes="protected __instancevar__" citdl="dict" line="739" name="_kw" /><scope ilk="function" line="743" lineend="744" name="cancel" signature="cancel()"><variable citdl="Timer" ilk="argument" name="self" /></scope><scope ilk="function" line="746" lineend="754" name="run" signature="run()"><variable citdl="Timer" ilk="argument" name="self" /><variable citdl="_callback()" line="751" name="rv" /></scope></scope><scope classrefs="BaseTask" ilk="class" line="757" lineend="782" name="CallLaterTask"><scope attributes="__ctor__" ilk="function" line="758" lineend="762" name="__init__" signature="CallLaterTask()"><import line="761" module="collections" symbol="deque" /><variable citdl="CallLaterTask" ilk="argument" name="self" /></scope><variable attributes="protected __instancevar__" citdl="pox.lib.util.makePinger()" line="760" name="_pinger" /><variable attributes="protected __instancevar__" citdl="deque()" line="762" name="_calls" /><scope ilk="function" line="764" lineend="767" name="callLater" signature="callLater(func, *args, **kw)"><variable citdl="CallLaterTask" ilk="argument" name="self" /><variable ilk="argument" name="func" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope ilk="function" line="769" lineend="782" name="run" signature="run()"><import line="779" module="logging" /><variable citdl="CallLaterTask" ilk="argument" name="self" /><variable citdl="self._calls.popleft()" line="775" name="e" /></scope></scope><scope classrefs="BaseTask" ilk="class" line="785" lineend="815" name="BlockingTask"><scope ilk="function" line="787" lineend="788" name="new" returns="BlockingTask.new._cls()" signature="new(_func, _cb=None, *_args, **_kw)"><variable citdl="BlockingTask" ilk="argument" name="_cls" /><variable ilk="argument" name="_func" /><variable ilk="argument" name="_cb" /><variable attributes="varargs" ilk="argument" name="_args" /><variable attributes="kwargs" ilk="argument" name="_kw" /></scope><scope attributes="__ctor__" doc="callback takes two parameters: rv and exc. One is always None.&#xA;if callback is actually a tuple, the first one is called with&#xA;the return value on normal exit, the second is called with&#xA;exc_info on an exception." ilk="function" line="790" lineend="801" name="__init__" signature="BlockingTask(func, callback=None, args=(), kw={})"><variable citdl="BlockingTask" ilk="argument" name="self" /><variable ilk="argument" name="func" /><variable ilk="argument" name="callback" /><variable citdl="tuple" ilk="argument" name="args" /><variable citdl="dict" ilk="argument" name="kw" /></scope><variable attributes="__instancevar__" line="798" name="func" /><variable attributes="__instancevar__" line="799" name="callback" /><variable attributes="__instancevar__" citdl="tuple" line="800" name="args" /><variable attributes="__instancevar__" citdl="dict" line="801" name="kw" /><scope ilk="function" line="803" lineend="815" name="run" signature="run()"><variable citdl="BlockingTask" ilk="argument" name="self" /></scope></scope><scope classrefs="BaseTask" ilk="class" line="820" lineend="829" name="TestTask"><scope attributes="__ctor__" ilk="function" line="821" lineend="822" name="__init__" signature="TestTask(*args, **kw)"><variable citdl="TestTask" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope ilk="function" line="824" lineend="829" name="run" signature="run(a, b, inc=1, sleep=0)"><variable citdl="TestTask" ilk="argument" name="self" /><variable ilk="argument" name="a" /><variable ilk="argument" name="b" /><variable citdl="int" ilk="argument" name="inc" /><variable citdl="int" ilk="argument" name="sleep" /><variable line="825" name="n" /></scope></scope><variable citdl="Scheduler" line="831" name="s" /><variable citdl="TestTask" line="833" name="t" /></scope>