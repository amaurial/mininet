<scope doc="Some of POX&apos;s core API and functionality is here, largely in&#xA;the POXCore class (an instance of which is available as&#xA;pox.core.core)." ilk="blob" lang="Python" name="core" src="/home/mininet/new_pox/pox/pox/core.py"><import line="26" module="__future__" symbol="print_function" /><import line="29" module="logging" /><import line="31" module="inspect" /><import line="32" module="time" /><import line="33" module="os" /><import line="114" module="pox.lib.revent" symbol="*" /><import line="128" module="pox.lib.revent.revent" /><import alias="recoco" line="158" module="pox.lib.recoco" /><variable attributes="protected" citdl="os.sep" line="35" name="_path" /><variable attributes="protected" citdl="list" line="36" name="_ext_path" /><variable citdl="int" line="40" name="SQUELCH_TIME" /><variable attributes="protected" citdl="str" line="42" name="_squelch" /><variable attributes="protected" citdl="int" line="43" name="_squelchTime" /><variable attributes="protected" citdl="int" line="44" name="_squelchCount" /><scope doc="In general, you don&apos;t need to call this directly, and will use&#xA;core.getLogger() instead." ilk="function" line="46" lineend="108" name="getLogger" returns="logging.getLogger()" signature="getLogger(name=None, moreFrames=0)"><variable citdl="list" ilk="argument" name="name" /><variable citdl="int" ilk="argument" name="moreFrames" /><variable line="52" name="s" /><variable citdl="name.split()" line="66" name="n" /><variable citdl="logging.getLogger()" line="78" name="l" /><variable citdl="globals()" line="79" name="g" /><scope ilk="function" line="81" lineend="103" name="printmsg" signature="printmsg(*args, **kw)"><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="__builtins__.str.join()" line="83" name="msg" /><variable line="84" name="s" /><variable citdl="str" line="85" name="o" /></scope></scope><variable line="112" name="log" /><scope attributes="protected" ilk="function" line="118" lineend="127" name="_revent_exception_hook" signature="_revent_exception_hook(source, event, args, kw, exc_info)"><variable ilk="argument" name="source" /><variable ilk="argument" name="event" /><variable ilk="argument" name="args" /><variable ilk="argument" name="kw" /><variable ilk="argument" name="exc_info" /><variable citdl="c.__class__.__name__" line="120" name="c" /><variable citdl="t.__class__.__name__" line="121" name="t" /></scope><scope classrefs="Event" doc="Fired when system is going up. " ilk="class" line="131" lineend="133" name="GoingUpEvent" /><scope classrefs="Event" doc="Fired when system is going down. " ilk="class" line="135" lineend="137" name="GoingDownEvent" /><scope classrefs="Event" doc="Fired when system is up. " ilk="class" line="139" lineend="141" name="UpEvent" /><scope classrefs="Event" doc="Fired when system is down. " ilk="class" line="143" lineend="145" name="DownEvent" /><scope classrefs="Event" doc="This is raised by core whenever a new component is registered.&#xA;By watching this, a component can monitor whether other components it&#xA;depends on are available." ilk="class" line="147" lineend="156" name="ComponentRegistered"><scope attributes="__ctor__" ilk="function" line="153" lineend="156" name="__init__" signature="ComponentRegistered(name, component)"><variable citdl="ComponentRegistered" ilk="argument" name="self" /><variable ilk="argument" name="name" /><variable ilk="argument" name="component" /></scope><variable attributes="__instancevar__" line="155" name="name" /><variable attributes="__instancevar__" line="156" name="component" /></scope><scope classrefs="EventMixin" doc="A nexus of of the POX API.&#xA;&#xA;pox.core.core is a reference to an instance of this class.  This class&#xA;serves a number of functions.&#xA;&#xA;An important one is that it can serve as a rendezvous point for&#xA;components.  A component can register objects on core, and they can&#xA;then be accessed on the core object (e.g., if you register foo, then&#xA;there will then be a pox.core.core.foo).  In many cases, this means you&#xA;won&apos;t need to import a module.&#xA;&#xA;Another purpose to the central registration is that it decouples&#xA;functionality from a specific module.  If myL2Switch and yourL2Switch&#xA;both register as &quot;switch&quot; and both provide the same API, then it doesn&apos;t&#xA;matter.  Doing this with imports is a pain.&#xA;&#xA;Additionally, a number of commmon API functions are vailable here." ilk="class" line="160" lineend="531" name="POXCore"><variable attributes="protected" citdl="set()" line="180" name="_eventMixin_events" /><scope attributes="__ctor__" ilk="function" line="188" lineend="199" name="__init__" signature="POXCore()"><variable citdl="POXCore" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="False" line="189" name="debug" /><variable attributes="__instancevar__" citdl="True" line="190" name="running" /><variable attributes="__instancevar__" citdl="dict" line="191" name="components" /><variable attributes="__instancevar__" citdl="tuple" line="193" name="version" /><variable attributes="__instancevar__" citdl="str" line="194" name="version_name" /><variable attributes="__instancevar__" citdl="recoco.Scheduler()" line="197" name="scheduler" /><variable attributes="protected __instancevar__" citdl="list" line="199" name="_waiters" /><variable attributes="property" citdl="__builtins__.str.format()" line="202" name="banner" /><scope attributes="__hidden__" ilk="function" line="202" lineend="204" name="banner (property getter)" returns="__builtins__.str.format()" signature="banner (property getter)()"><variable citdl="POXCore" ilk="argument" name="self" /></scope><variable attributes="property" citdl="str" line="207" name="version_string" /><scope attributes="__hidden__" ilk="function" line="207" lineend="208" name="version_string (property getter)" returns="tuple" signature="version_string (property getter)()"><variable citdl="POXCore" ilk="argument" name="self" /></scope><scope doc="Calls the function at a later time.&#xA;This is just a wrapper around a recoco timer." ilk="function" line="210" lineend="217" name="callDelayed" returns="recoco.Timer()" signature="callDelayed(_seconds, _func, *args, **kw)"><variable citdl="POXCore" ilk="argument" name="_self" /><variable ilk="argument" name="_seconds" /><variable ilk="argument" name="_func" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="recoco.Timer()" line="215" name="t" /></scope><scope doc="Call the given function with the given arguments within the context&#xA;of the co-operative threading environment.&#xA;It actually calls it sooner rather than later. ;)&#xA;Much of POX is written without locks because it&apos;s all thread-safe&#xA;with respect to itself, as it&apos;s written using the recoco co-operative&#xA;threading library.  If you have a real thread outside of the&#xA;co-operative thread context, you need to be careful about calling&#xA;things within it.  This function provides a rather simple way that&#xA;works for most situations: you give it a callable (like a method)&#xA;and some arguments, and it will call that callable with those&#xA;arguments from within the co-operative threader, taking care of&#xA;synchronization for you." ilk="function" line="219" lineend="236" name="callLater" signature="callLater(_func, *args, **kw)"><variable citdl="POXCore" ilk="argument" name="_self" /><variable ilk="argument" name="_func" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="This is similar to callLater(), but provides an easy way to raise a&#xA;revent event from outide the co-operative context.&#xA;Rather than foo.raiseEvent(BarEvent, baz, spam), you just do&#xA;core.raiseLater(foo, BarEvent, baz, spam)." ilk="function" line="238" lineend="247" name="raiseLater" signature="raiseLater(_obj, *args, **kw)"><variable citdl="POXCore" ilk="argument" name="_self" /><variable ilk="argument" name="_obj" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="Returns a logger.  Pass it the name you want if you&apos;d like to specify&#xA;one (e.g., core.getLogger(&quot;foo&quot;)).  If you don&apos;t specify a name, it&#xA;will make one up based on the module name it is called from." ilk="function" line="249" lineend="255" name="getLogger" returns="POXCore.getLogger()" signature="getLogger(*args, **kw)"><variable citdl="POXCore" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="Shut down POX." ilk="function" line="257" lineend="266" name="quit" signature="quit()"><import line="261" module="threading" /><variable citdl="POXCore" ilk="argument" name="self" /><variable citdl="threading.Thread()" line="263" name="t" /></scope><scope attributes="protected" ilk="function" line="268" lineend="283" name="_quit" signature="_quit()"><import line="272" module="gc" /><variable citdl="POXCore" ilk="argument" name="self" /></scope><scope attributes="protected" ilk="function" line="285" lineend="293" name="_get_python_version" returns="__builtins__.str.format()" signature="_get_python_version()"><import line="287" module="platform" /><variable citdl="POXCore" ilk="argument" name="self" /></scope><scope attributes="protected" ilk="function" line="295" lineend="300" name="_get_platform_info" returns="str" signature="_get_platform_info()"><import line="297" module="platform" /><variable citdl="POXCore" ilk="argument" name="self" /></scope><scope ilk="function" line="302" lineend="338" name="goUp" signature="goUp()"><import line="308" module="platform" /><variable citdl="POXCore" ilk="argument" name="self" /><variable citdl="__builtins__.str.join()" line="309" name="vers" /><variable citdl="logging.getLogger()" line="313" name="l" /><variable citdl="set()" line="324" name="waiting_for" /><variable citdl="list" line="327" name="components" /><variable citdl="set()" line="331" name="names" /></scope><scope doc="Returns True if a component with the given name has been registered." ilk="function" line="340" lineend="344" name="hasComponent" returns="bool" signature="hasComponent(name)"><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope><scope doc="Give it a class (and optional __init__ arguments), and it will&#xA;create an instance and register it using the class name.  If the&#xA;instance has a _core_name property, it will use that instead.&#xA;It returns the new instance.&#xA;core.registerNew(FooClass, arg) is roughly equivalent to&#xA;core.register(&quot;FooClass&quot;, FooClass(arg))." ilk="function" line="346" lineend="361" name="registerNew" returns="__componentClass()" signature="registerNew(__componentClass, *args, **kw)"><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="__componentClass" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="__componentClass.__name__" line="355" name="name" /><variable citdl="__componentClass()" line="356" name="obj" /></scope><scope doc="Makes the object &quot;component&quot; available as pox.core.core.name.&#xA;&#xA;If only one argument is specified, the given argument is registered&#xA;using its class name as the name." ilk="function" line="363" lineend="382" name="register" signature="register(name, component=None)"><variable citdl="POXCore" ilk="argument" name="self" /><variable citdl="component.__class__.__name__" ilk="argument" name="name" /><variable ilk="argument" name="component" /></scope><scope doc="Calls a callback when components are ready." ilk="function" line="384" lineend="414" name="call_when_ready" signature="call_when_ready(callback, components=[], name=None, args=(), kw={})"><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="callback" /><variable citdl="list" ilk="argument" name="components" /><variable citdl="getattr()" ilk="argument" name="name" /><variable citdl="tuple" ilk="argument" name="args" /><variable citdl="dict" ilk="argument" name="kw" /><variable attributes="protected" line="395" name="_" /><variable citdl="tuple" line="412" name="entry" /></scope><scope attributes="protected" doc="Tries a waiting callback.&#xA;&#xA;Calls the callback, removes from _waiters, and returns True if&#xA;all are satisfied." ilk="function" line="416" lineend="444" name="_try_waiter" returns="bool" signature="_try_waiter(entry)"><import line="435" module="traceback" /><import line="437" module="inspect" /><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="entry" /><variable citdl="name" line="436" name="msg" /></scope><scope attributes="protected" doc="Tries to satisfy all component-waiting callbacks" ilk="function" line="446" lineend="456" name="_try_waiters" signature="_try_waiters()"><variable citdl="POXCore" ilk="argument" name="self" /><variable citdl="True" line="450" name="changed" /></scope><scope doc="Look through *sink* for handlers named like _handle_component_event.&#xA;Use that to build a list of components, and append any components&#xA;explicitly specified by *components*.&#xA;&#xA;listen_args is a dict of &quot;component_name&quot;={&quot;arg_name&quot;:&quot;arg_value&quot;,...},&#xA;allowing you to specify additional arguments to addListeners().&#xA;&#xA;When all the referenced components are registered, do the following:&#xA;1) Set up all the event listeners&#xA;2) Call &quot;_all_dependencies_met&quot; on *sink* if it exists&#xA;3) If attrs=True, set attributes on *sink* for each component&#xA;   (e.g, sink._openflow_ would be set to core.openflow)&#xA;&#xA;For example, if topology is a dependency, a handler for topology&apos;s&#xA;SwitchJoin event must be defined as so:&#xA;   def _handle_topology_SwitchJoin (self, ...):&#xA;&#xA;*NOTE*: The semantics of this function changed somewhat in the&#xA;        Summer 2012 milestone, though its intention remains the same." ilk="function" line="458" lineend="525" name="listen_to_dependencies" signature="listen_to_dependencies(sink, components=None, attrs=True, short_attrs=False, listen_args={})"><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="sink" /><variable citdl="set()" ilk="argument" name="components" /><variable citdl="True" ilk="argument" name="attrs" /><variable citdl="False" ilk="argument" name="short_attrs" /><variable citdl="dict" ilk="argument" name="listen_args" /><variable citdl="__builtins__.str.join()" line="491" name="c" /><variable citdl="listen_args.pop()" line="496" name="args" /><scope ilk="function" line="508" lineend="521" name="done" signature="done(sink, components, attrs, short_attrs)"><variable ilk="argument" name="sink" /><variable ilk="argument" name="components" /><variable ilk="argument" name="attrs" /><variable ilk="argument" name="short_attrs" /><variable citdl="__builtins__.str.join()" line="512" name="attrname" /><variable citdl="dict" line="518" name="kwargs" /></scope></scope><scope ilk="function" line="528" lineend="531" name="__getattr__" signature="__getattr__(name)"><variable citdl="POXCore" ilk="argument" name="self" /><variable ilk="argument" name="name" /></scope></scope><variable citdl="POXCore" line="533" name="core" /></scope>