<scope doc="Revent is an event system wherein objects become a&#xA;composition of data, methods, and now events." ilk="blob" lang="Python" name="revent" src="/home/mininet/new_pox/pox/pox/lib/revent/revent.py"><import line="98" module="__future__" symbol="print_function" /><import line="100" module="operator" /><import line="104" module="weakref" /><variable attributes="protected" citdl="int" line="107" name="_nextEventID" /><scope attributes="protected" doc="Generates an event ID&#xA;This is (at present) mostly so that an event can later be removed.&#xA;Note that this function is not threadsafe." ilk="function" line="108" lineend="116" name="_generateEventID" returns="int" signature="_generateEventID()" /><scope doc="Event handlers can return special values.  You can craft these with this&#xA;function.&#xA;&#xA;If halt is True, further handlers will not be called for this particular&#xA;event.&#xA;&#xA;If remove is True, the handler will be removed (i.e. unsubscribed) and&#xA;will not be called anymore.&#xA;&#xA;Shortcut names are also available.  You can also simply do:&#xA;return EventHalt&#xA;return EventRemove&#xA;return HaltAndRemove" ilk="function" line="119" lineend="135" name="EventReturn" returns="tuple" signature="EventReturn(halt=False, remove=False)"><variable citdl="False" ilk="argument" name="halt" /><variable citdl="False" ilk="argument" name="remove" /></scope><variable citdl="EventReturn()" line="137" name="EventContinue" /><variable citdl="EventReturn()" line="140" name="EventHalt" /><variable citdl="EventReturn()" line="143" name="EventRemove" /><variable citdl="EventReturn()" line="147" name="EventHaltAndRemove" /><scope classrefs="object" doc="Superclass for events" ilk="class" line="150" lineend="159" name="Event"><scope attributes="__ctor__" ilk="function" line="154" lineend="156" name="__init__" signature="Event()"><variable citdl="Event" ilk="argument" name="self" /></scope><variable attributes="__instancevar__" citdl="False" line="155" name="halt" /><variable attributes="__instancevar__" line="156" name="source" /><scope attributes="protected" ilk="function" line="158" lineend="159" name="_invoke" returns="Event._invoke.handler()" signature="_invoke(handler, *args, **kw)"><variable citdl="Event" ilk="argument" name="self" /><variable ilk="argument" name="handler" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope></scope><scope doc="Called when an exception is raised by an event handler when the event&#xA;was raised by raiseEventNoErrors().&#xA;&#xA;You can replace this method if you&apos;d like to replace the default handling&#xA;(printing an error message an a traceback) with your own (for example if&#xA;you are using a logging system and would like to use that).  You can also&#xA;replace it with None to have events fail silently.&#xA;&#xA;&quot;source&quot; is the object sourcing the event.  &quot;event&quot; is the event that was&#xA;being raised when the exception occurred.  &quot;args&quot; and &quot;kw&quot; were the args&#xA;and kwargs passed to raiseEventNoErrors.  &quot;exc_info&quot; is the exception&#xA;info as returned by sys.exc_info())." ilk="function" line="161" lineend="187" name="handleEventException" signature="handleEventException(source, event, args, kw, exc_info)"><import line="184" module="sys" /><import line="186" module="traceback" /><variable ilk="argument" name="source" /><variable ilk="argument" name="event" /><variable ilk="argument" name="args" /><variable ilk="argument" name="kw" /><variable ilk="argument" name="exc_info" /><variable citdl="c.__class__.__name__" line="177" name="c" /><variable citdl="t.__name__" line="178" name="t" /></scope><scope classrefs="object" doc="Mixin for classes that want to source events" ilk="class" line="190" lineend="470" name="EventMixin"><variable attributes="protected" citdl="set()" line="198" name="_eventMixin_events" /><scope attributes="protected" ilk="function" line="200" lineend="202" name="_eventMixin_addEvents" signature="_eventMixin_addEvents(events)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="events" /></scope><scope attributes="protected" ilk="function" line="203" lineend="214" name="_eventMixin_addEvent" signature="_eventMixin_addEvent(eventType)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="eventType" /></scope><scope attributes="__ctor__" ilk="function" line="216" lineend="217" name="__init__" signature="EventMixin()"><variable citdl="EventMixin" ilk="argument" name="self" /></scope><scope attributes="protected" ilk="function" line="219" lineend="223" name="_eventMixin_init" signature="_eventMixin_init()"><variable citdl="EventMixin" ilk="argument" name="self" /></scope><scope doc="Raise an event, catching exceptions thrown by the handler.&#xA;If exceptions are caught, the global handleEventExceptions() is called.&#xA;Also see raiseEvent()" ilk="function" line="225" lineend="239" name="raiseEventNoErrors" returns="self.raiseEvent()" signature="raiseEventNoErrors(event, *args, **kw)"><import line="237" module="sys" /><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="event" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="Raises an event.&#xA;If &quot;event&quot; is an Event type, it will be initialized with args and kw,&#xA;but only if there are actually listeners.&#xA;Returns the event object, unless it was never created (because there&#xA;were no listeners) in which case returns None." ilk="function" line="241" lineend="303" name="raiseEvent" returns="eventType()" signature="raiseEvent(event, *args, **kw)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable citdl="eventType()" ilk="argument" name="event" /><variable attributes="varargs" citdl="tuple" ilk="argument" name="args" /><variable attributes="kwargs" citdl="dict" ilk="argument" name="kw" /><variable citdl="True" line="251" name="classCall" /><variable citdl="event.__class__" line="253" name="eventType" /><variable citdl="self._eventMixin_handlers.get()" line="278" name="handlers" /><variable citdl="event._invoke()" line="281" name="rv" /></scope><scope ilk="function" line="305" lineend="309" name="removeListeners" returns="bool" signature="removeListeners(listeners)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="listeners" /><variable citdl="False" line="306" name="altered" /></scope><scope attributes="protected" doc="Returns the number of listeners." ilk="function" line="311" lineend="315" name="_eventMixin_get_listener_count" returns="sum()" signature="_eventMixin_get_listener_count()"><variable citdl="EventMixin" ilk="argument" name="self" /></scope><scope doc="handlerOrEID : a reference to a handler object, an event ID (EID)&#xA;               identifying the event type, or (eventType, EID) pair&#xA;eventType : the type of event to remove the listener(s) for" ilk="function" line="317" lineend="368" name="removeListener" returns="bool" signature="removeListener(handlerOrEID, eventType=None)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="handlerOrEID" /><variable ilk="argument" name="eventType" /><variable line="327" name="handler" /><variable citdl="False" line="329" name="altered" /><variable line="333" name="handlers" /><variable citdl="len()" line="334" name="l" /></scope><scope doc="Add a listener by name. An eventType argument must be present, which is&#xA;used as the name. A handler argument must also be present.&#xA;&#xA;Also see addListener()." ilk="function" line="370" lineend="378" name="addListenerByName" returns="self.addListener()" signature="addListenerByName(*args, **kw)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /></scope><scope doc="Add an event handler for an event triggered by this object (subscribe).&#xA;&#xA;eventType : event class object (e.g. ConnectionUp). If byName is True,&#xA;            should be a string (e.g. &quot;ConnectionUp&quot;) &#xA;handler : function/method to be invoked when event is raised &#xA;once : if True, this handler is removed after being fired once&#xA;weak : If handler is a method on object A, then listening to an event&#xA;       on object B will normally make B have a reference to A, so A&#xA;       can not be released until after B is released or the listener&#xA;       is removed.&#xA;       If weak is True, there is no relationship between the lifetimes&#xA;       of the publisher and subscriber.&#xA;priority : The order in which to call event handlers if there are&#xA;           multiple for an event type.  Should probably be an integer,&#xA;           where higher means to call it earlier.  Do not specify if&#xA;           you don&apos;t care.&#xA;byName : True if eventType is a string name, else an Event subclass&#xA;&#xA;Raises an exception unless eventType is in the source&apos;s&#xA;_eventMixin_events set (or, alternately, _eventMixin_events must&#xA;be True).&#xA;&#xA;The return value can be used for removing the listener." ilk="function" line="380" lineend="442" name="addListener" returns="tuple" signature="addListener(eventType, handler, once=False, weak=False, priority=None, byName=False)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable citdl="e" ilk="argument" name="eventType" /><variable citdl="CallProxy()" ilk="argument" name="handler" /><variable citdl="False" ilk="argument" name="once" /><variable citdl="False" ilk="argument" name="weak" /><variable ilk="argument" name="priority" /><variable citdl="False" ilk="argument" name="byName" /><variable citdl="False" line="411" name="fail" /><variable citdl="list" line="426" name="handlers" /><variable citdl="_generateEventID()" line="431" name="eid" /><variable citdl="tuple" line="435" name="entry" /></scope><scope doc="Automatically subscribe to events on source.&#xA;&#xA;This method tries to bind all _handle_ methods on self to events&#xA;on source.  Kind of the opposite of addListeners().&#xA;&#xA;See also: addListeners(), autoBindEvents()" ilk="function" line="444" lineend="453" name="listenTo" returns="autoBindEvents()" signature="listenTo(source, *args, **kv)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="source" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kv" /></scope><scope doc="Automatically subscribe sink to our events.&#xA;&#xA;Tries to bind all _handle_ methods on sink to events that this object&#xA;raises.  Kind of the opposite of listenTo().&#xA;&#xA;See also: listenTo(), autoBindEvents()" ilk="function" line="455" lineend="464" name="addListeners" returns="autoBindEvents()" signature="addListeners(sink, prefix=&apos;&apos;, weak=False, priority=None)"><variable citdl="EventMixin" ilk="argument" name="self" /><variable ilk="argument" name="sink" /><variable citdl="str" ilk="argument" name="prefix" /><variable citdl="False" ilk="argument" name="weak" /><variable ilk="argument" name="priority" /></scope><scope doc="Remove all handlers from this object" ilk="function" line="466" lineend="470" name="clearHandlers" signature="clearHandlers()"><variable citdl="EventMixin" ilk="argument" name="self" /></scope><variable attributes="protected __instancevar__" citdl="dict" line="470" name="_eventMixin_handlers" /></scope><scope doc="Automatically set up listeners on sink for events raised by source.&#xA;&#xA;Often you have a &quot;sink&quot; object that is interested in multiple events&#xA;raised by some other &quot;source&quot; object.  This method makes setting that&#xA;up easy.&#xA;You name handler methods on the sink object in a special way.  For&#xA;example, lets say you have an object mySource which raises events of&#xA;types FooEvent and BarEvent.  You have an object mySink which wants to&#xA;listen to these events.  To do so, it names its handler methods&#xA;&quot;_handle_FooEvent&quot; and &quot;_handle_BarEvent&quot;.  It can then simply call&#xA;autoBindEvents(mySink, mySource), and the handlers are set up.&#xA;&#xA;You can also set a prefix which changes how the handlers are to be named.&#xA;For example, autoBindEvents(mySink, mySource, &quot;source1&quot;) would use a&#xA;handler named &quot;_handle_source1_FooEvent&quot;.&#xA;&#xA;&quot;weak&quot; has the same meaning as with addListener().&#xA;&#xA;Returns the added listener IDs (so that you can remove them later)." ilk="function" line="473" lineend="529" name="autoBindEvents" returns="list" signature="autoBindEvents(sink, source, prefix=&apos;&apos;, weak=False, priority=None)"><variable ilk="argument" name="sink" /><variable ilk="argument" name="source" /><variable citdl="str" ilk="argument" name="prefix" /><variable citdl="False" ilk="argument" name="weak" /><variable ilk="argument" name="priority" /><variable citdl="dict" line="502" name="events" /><variable citdl="list" line="509" name="listeners" /><variable citdl="getattr()" line="513" name="a" /><variable citdl="list" line="517" name="event" /></scope><scope classrefs="object" doc="Internal use.&#xA;&#xA;Custom proxy wrapper for /weak reference/ event handlers.  When the&#xA;publisher or subscriber objects are lost, this cleans up by removing&#xA;the listener entry in the publisher object." ilk="class" line="532" lineend="568" name="CallProxy"><scope attributes="__ctor__" doc="source : Event source (publisher)&#xA;handler : A &quot;weak handler&quot; callback&#xA;removeData :  The identifier used for removal of the handler" ilk="function" line="540" lineend="550" name="__init__" signature="CallProxy(source, handler, removeData)"><variable citdl="CallProxy" ilk="argument" name="self" /><variable ilk="argument" name="source" /><variable ilk="argument" name="handler" /><variable ilk="argument" name="removeData" /></scope><variable attributes="__instancevar__" citdl="weakref.ref()" line="546" name="source" /><variable attributes="__instancevar__" citdl="weakref.ref()" line="547" name="obj" /><variable attributes="__instancevar__" citdl="handler.im_func" line="548" name="method" /><variable attributes="__instancevar__" line="549" name="removeData" /><variable attributes="__instancevar__" citdl="str()" line="550" name="name" /><scope attributes="protected" ilk="function" line="552" lineend="558" name="_forgetMe" signature="_forgetMe(o)"><variable citdl="CallProxy" ilk="argument" name="self" /><variable ilk="argument" name="o" /><variable citdl="source()" line="555" name="source" /></scope><scope ilk="function" line="559" lineend="566" name="__call__" returns="CallProxy.method()" signature="__call__(*args, **kw)"><variable citdl="CallProxy" ilk="argument" name="self" /><variable attributes="varargs" ilk="argument" name="args" /><variable attributes="kwargs" ilk="argument" name="kw" /><variable citdl="obj()" line="562" name="o" /></scope><scope ilk="function" line="567" lineend="568" name="__str__" returns="str" signature="__str__()"><variable citdl="CallProxy" ilk="argument" name="self" /></scope></scope></scope>