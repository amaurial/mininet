<scope doc="distutils.command.sdist&#xA;Implements the Distutils &apos;sdist&apos; command (create a source distribution)." ilk="blob" lang="Python" name="distutils.command.sdist">
      <scope classrefs="object" doc="&#xA;" ilk="class" name="BuiltinFunctionType">
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope classrefs="object" doc="&#xA;" ilk="class" name="BuiltinMethodType">
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope classrefs="Exception" doc="Some compile/link operation failed.&#xA;" ilk="class" name="CCompilerError" />
      <scope classrefs="object" doc="code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,&#xA;constants, names, varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])  Create a code object.  Not for the faint of heart." ilk="class" name="CodeType">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope classrefs="object" doc="Abstract base class for defining command classes, the &quot;worker bees&quot;&#xA;of the Distutils.  A useful analogy for command classes is to think of them as subroutines with local variables called &quot;options&quot;.  The options are &quot;declared&quot; in &apos;initialize_options()&apos; and &quot;defined&quot; (given their final values, aka &quot;finalized&quot;) in &apos;finalize_options()&apos;, both of which must be defined by every command class.  The distinction between the two is necessary because option values might come from the outside world (command line, config file, ...), and any options dependent on other options must be computed *after* these outside influences have been processed -- hence &apos;finalize_options()&apos;.  The &quot;body&quot; of the subroutine, where it does all its work based on the values of its" ilk="class" name="Command">
        <scope ilk="function" name="_ensure_tested_string" signature="_ensure_tested_string(self, option, tester, what, error_fmt, default=None)" />
        <scope doc="Spawn an external command respecting dry-run flag." ilk="function" name="spawn" signature="spawn(self, cmd, search_path=1, level=1)" />
        <scope ilk="function" name="ensure_finalized" signature="ensure_finalized(self)" />
        <scope doc="Create and initialize a new Command object." ilk="function" name="__init__" signature="__init__(self, dist)" />
        <scope doc="Set default values for all the options that this command&#xA;supports." ilk="function" name="initialize_options" signature="initialize_options(self)" />
        <scope ilk="function" name="dump_options" signature="dump_options(self, header=None, indent=&apos;&apos;)" />
        <scope doc="# XXX A more explicit way to customize dry_run would be&#xA;better." ilk="function" name="__getattr__" signature="__getattr__(self, attr)" />
        <scope doc="Determine the sub-commands that are relevant in the current&#xA;distribution (ie., that need to be run)." ilk="function" name="get_sub_commands" signature="get_sub_commands(self)" />
        <scope doc="Copy an entire directory tree respecting verbose, dry-run,&#xA;and force flags." ilk="function" name="copy_tree" signature="copy_tree(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)" />
        <scope doc="If the current verbosity level is of greater than or equal&#xA;to &apos;level&apos; print &apos;msg&apos; to stdout." ilk="function" name="announce" signature="announce(self, msg, level=1)" />
        <scope doc="Run some other command: uses the &apos;run_command()&apos; method of&#xA;Distribution, which creates and finalizes the command object&#xA;if necessary and then invokes its &apos;run()&apos; method." ilk="function" name="run_command" signature="run_command(self, command)" />
        <scope doc="Set the values of any &quot;undefined&quot; options from corresponding&#xA;option values in some other command object." ilk="function" name="set_undefined_options" signature="set_undefined_options(self, src_cmd, *option_pairs)" />
        <scope doc="A command&apos;s raison d&apos;etre: carry out the action it exists to&#xA;perform, controlled by the options initialized in&#xA;&apos;initialize_options()&apos;, customized by other commands, the&#xA;setup script, the command-line, and config files, and&#xA;finalized in" ilk="function" name="run" signature="run(self)" />
        <scope doc="# XXX rename to &apos;get_reinitialized_command()&apos;? (should do&#xA;the # same in dist.py, if so)" ilk="function" name="reinitialize_command" signature="reinitialize_command(self, command, reinit_subcommands=0)" />
        <scope doc="Copy a file respecting verbose, dry-run and force flags." ilk="function" name="copy_file" signature="copy_file(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)" />
        <scope ilk="function" name="warn" signature="warn(self, msg)" />
        <scope ilk="function" name="ensure_dirname" signature="ensure_dirname(self, option)" />
        <scope doc="Move a file respecting dry-run flag." ilk="function" name="move_file" signature="move_file(self, src, dst, level=1)" />
        <scope doc="Ensure that &apos;option&apos; is a list of strings." ilk="function" name="ensure_string_list" signature="ensure_string_list(self, option)" />
        <scope ilk="function" name="_ensure_stringlike" signature="_ensure_stringlike(self, option, what, default=None)" />
        <scope doc="Wrapper around Distribution&apos;s &apos;get_command_obj()&apos; method:&#xA;find (create if necessary and &apos;create&apos; is true) the command&#xA;object for &apos;command&apos;, call its &apos;ensure_finalized()&apos; method,&#xA;and return the finalized command object." ilk="function" name="get_finalized_command" signature="get_finalized_command(self, command, create=1)" />
        <scope ilk="function" name="execute" signature="execute(self, func, args, msg=None, level=1)" />
        <scope doc="Ensure that &apos;option&apos; is a string; if not defined, set it to&#xA;&apos;default&apos;." ilk="function" name="ensure_string" signature="ensure_string(self, option, default=None)" />
        <scope ilk="function" name="mkpath" signature="mkpath(self, name, mode=511)" />
        <scope ilk="function" name="make_archive" signature="make_archive(self, base_name, format, root_dir=None, base_dir=None)" />
        <scope ilk="function" name="get_command_name" signature="get_command_name(self)" />
        <scope doc="Special case of &apos;execute()&apos; for operations that process one&#xA;or more input files and generate one output file." ilk="function" name="make_file" signature="make_file(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)" />
        <scope doc="Set final values for all the options that this command&#xA;supports." ilk="function" name="finalize_options" signature="finalize_options(self)" />
        <scope doc="Ensure that &apos;option&apos; is the name of an existing file." ilk="function" name="ensure_filename" signature="ensure_filename(self, option)" />
        <scope doc="Print &apos;msg&apos; to stdout if the global DEBUG (taken from the&#xA;DISTUTILS_DEBUG environment variable) flag is true." ilk="function" name="debug_print" signature="debug_print(self, msg)" />
      </scope>
      <scope classrefs="CCompilerError" doc="Failure to compile one or more C/C++ source files.&#xA;" ilk="class" name="CompileError" />
      <scope classrefs="DistutilsError" doc="Raised by fancy_getopt in response to getopt.error -- ie. an&#xA;error in the command line usage." ilk="class" name="DistutilsArgError" />
      <scope classrefs="DistutilsError" doc="Byte compile error.&#xA;" ilk="class" name="DistutilsByteCompileError" />
      <scope classrefs="DistutilsError" doc="Some command class (or possibly distribution class, if anyone&#xA;feels a need to subclass Distribution) is found not to be holding up its end of the bargain, ie. implementing some part of the &quot;command &quot;interface." ilk="class" name="DistutilsClassError" />
      <scope classrefs="Exception" doc="The root of all Distutils evil.&#xA;" ilk="class" name="DistutilsError" />
      <scope classrefs="DistutilsError" doc="Any problems executing an external program (such as the C&#xA;compiler, when compiling C files)." ilk="class" name="DistutilsExecError" />
      <scope classrefs="DistutilsError" doc="Any problems in the filesystem: expected file not found, etc.&#xA;Typically this is for problems that we detect before IOError or OSError could be raised." ilk="class" name="DistutilsFileError" />
      <scope classrefs="DistutilsError" doc="The option table provided to &apos;fancy_getopt()&apos; is bogus.&#xA;" ilk="class" name="DistutilsGetoptError" />
      <scope classrefs="DistutilsError" doc="Internal inconsistencies or impossibilities (obviously, this&#xA;should never be seen if the code is working!)." ilk="class" name="DistutilsInternalError" />
      <scope classrefs="DistutilsError" doc="Unable to load an expected module, or to find an expected class&#xA;within some module (in particular, command modules and classes)." ilk="class" name="DistutilsModuleError" />
      <scope classrefs="DistutilsError" doc="Syntactic/semantic errors in command options, such as use of&#xA;mutually conflicting options, or inconsistent options, badly-spelled values, etc.  No distinction is made between option values originating in the setup script, the command line, config files, or what-have-you -- but if we *know* something originated in the setup script, we&apos;ll raise DistutilsSetupError instead." ilk="class" name="DistutilsOptionError" />
      <scope classrefs="DistutilsError" doc="We don&apos;t know how to do something on the current platform (but&#xA;we do know how to do it on some platform) -- eg. trying to compile C files on a platform not supported by a CCompiler subclass." ilk="class" name="DistutilsPlatformError" />
      <scope classrefs="DistutilsError" doc="For errors that can be definitely blamed on the setup script,&#xA;such as invalid keyword arguments to &apos;setup()&apos;." ilk="class" name="DistutilsSetupError" />
      <scope classrefs="DistutilsError" doc="Syntax error in a file list template.&#xA;" ilk="class" name="DistutilsTemplateError" />
      <scope classrefs="object" doc="A list of files built by on exploring the filesystem and filtered by&#xA;applying various patterns to what we find there.  Instance attributes: dir directory from which files will be taken -- only used if &apos;allfiles&apos; not supplied to constructor files list of filenames currently being built/filtered/manipulated allfiles complete list of files under consideration (ie. without any" ilk="class" name="FileList">
        <scope ilk="function" name="sort" signature="sort(self)" />
        <scope doc="Select strings (presumably filenames) from &apos;self.files&apos; that&#xA;match &apos;pattern&apos;, a Unix-style wildcard (glob) pattern." ilk="function" name="include_pattern" signature="include_pattern(self, pattern, anchor=1, prefix=None, is_regex=0)" />
        <scope ilk="function" name="remove_duplicates" signature="remove_duplicates(self)" />
        <scope ilk="function" name="set_allfiles" signature="set_allfiles(self, allfiles)" />
        <scope ilk="function" name="extend" signature="extend(self, items)" />
        <scope ilk="function" name="process_template_line" signature="process_template_line(self, line)" />
        <scope doc="Remove strings (presumably filenames) from &apos;files&apos; that&#xA;match &apos;pattern&apos;." ilk="function" name="exclude_pattern" signature="exclude_pattern(self, pattern, anchor=1, prefix=None, is_regex=0)" />
        <scope ilk="function" name="_parse_template_line" signature="_parse_template_line(self, line)" />
        <scope ilk="function" name="findall" signature="findall(self, dir=&apos;.&apos;)" />
        <scope doc="Print &apos;msg&apos; to stdout if the global DEBUG (taken from the&#xA;DISTUTILS_DEBUG environment variable) flag is true." ilk="function" name="debug_print" signature="debug_print(self, msg)" />
        <scope ilk="function" name="__init__" signature="__init__(self, warn=None, debug_print=None)" />
        <scope ilk="function" name="append" signature="append(self, item)" />
      </scope>
      <scope classrefs="object" doc="&#xA;" ilk="class" name="FrameType">
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="F.__sizeof__() -&gt; size of F in memory, in bytes" ilk="function" name="__sizeof__" signature="F.__sizeof__() -&gt; size of F in memory, in bytes" />
      </scope>
      <scope classrefs="object" doc="function(code, globals[, name[, argdefs[, closure]]])&#xA;Create a function object from a code object and a dictionary. The optional name string overrides the name from the code object. The optional argdefs tuple specifies the default argument values. The optional closure tuple supplies the bindings for free variables." ilk="class" name="FunctionType">
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope classrefs="object" doc="&#xA;" ilk="class" name="GeneratorType">
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="return next yielded value or raise StopIteration." ilk="function" name="send" signature="send(arg) -&gt; send &apos;arg&apos; into generator," />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="close(arg) -&gt; raise GeneratorExit inside generator." ilk="function" name="close" signature="close(arg) -&gt; raise GeneratorExit inside generator." />
        <scope doc="return next yielded value or raise StopIteration." ilk="function" name="throw" signature="throw(typ[,val[,tb]]) -&gt; raise exception in generator," />
      </scope>
      <scope classrefs="object" doc="&#xA;" ilk="class" name="GetSetDescriptorType">
        <scope doc="descr.__set__(obj, value)" ilk="function" name="__set__" signature="descr.__set__(obj, value)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
        <scope doc="descr.__delete__(obj)" ilk="function" name="__delete__" signature="descr.__delete__(obj)" />
      </scope>
      <scope classrefs="object" doc="function(code, globals[, name[, argdefs[, closure]]])&#xA;Create a function object from a code object and a dictionary. The optional name string overrides the name from the code object. The optional argdefs tuple specifies the default argument values. The optional closure tuple supplies the bindings for free variables." ilk="class" name="LambdaType">
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope classrefs="CCompilerError" doc="Failure to create a static library from one or more C/C++ object&#xA;files." ilk="class" name="LibError" />
      <scope classrefs="CCompilerError" doc="Failure to link one or more C/C++ object files into an executable&#xA;or shared library file." ilk="class" name="LinkError" />
      <scope classrefs="object" doc="&#xA;" ilk="class" name="MemberDescriptorType">
        <scope doc="descr.__set__(obj, value)" ilk="function" name="__set__" signature="descr.__set__(obj, value)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
        <scope doc="descr.__delete__(obj)" ilk="function" name="__delete__" signature="descr.__delete__(obj)" />
      </scope>
      <scope classrefs="object" doc="method(function, instance)&#xA;Create a bound instance method object." ilk="class" name="MethodType">
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope classrefs="object" doc="module(name[, doc])&#xA;Create a module object. The name must be a string; the optional doc argument can have any type." ilk="class" name="ModuleType">
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="CCompilerError" doc="Failure to preprocess one or more C/C++ files.&#xA;" ilk="class" name="PreprocessError" />
      <scope classrefs="object" doc="Provides a file-like object that takes care of all the things you&#xA;commonly want to do when processing a text file that has some line-by-line syntax: strip comments (as long as &quot;#&quot; is your comment character), skip blank lines, join adjacent lines by escaping the newline (ie. backslash at end of line), strip leading and/or trailing whitespace.  All of these are optional and independently controllable.  Provides a &apos;warn()&apos; method so you can generate warning messages that report physical line number, even if the logical line in question spans multiple physical lines.  Also provides &apos;unreadline()&apos; for" ilk="class" name="TextFile">
        <scope doc="Open a new file named &apos;filename&apos;." ilk="function" name="open" signature="open(self, filename)" />
        <scope doc="Read and return the list of all logical lines remaining in&#xA;the current file." ilk="function" name="readlines" signature="readlines(self)" />
        <scope doc="line in the current file." ilk="function" name="warn" signature="Print (to stderr) a warning message tied to the current logical" />
        <scope ilk="function" name="error" signature="error(self, msg, line=None)" />
        <scope doc="Close the current file and forget everything we know about&#xA;it (filename, current line number)." ilk="function" name="close" signature="close(self)" />
        <scope doc="Read and return a single logical line from the current file&#xA;(or from an internal buffer if lines have previously been&#xA;&quot;unread&quot; with &apos;unreadline()&apos;)." ilk="function" name="readline" signature="readline(self)" />
        <scope ilk="function" name="gen_error" signature="gen_error(self, msg, line=None)" />
        <scope doc="Push &apos;line&apos; (a string) onto an internal buffer that will be&#xA;checked by future &apos;readline()&apos; calls." ilk="function" name="unreadline" signature="unreadline(self, line)" />
        <scope doc="Construct a new TextFile object." ilk="function" name="__init__" signature="__init__(self, filename=None, file=None, **options)" />
      </scope>
      <scope classrefs="object" doc="&#xA;" ilk="class" name="TracebackType">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope ilk="function" name="__dir__" />
      </scope>
      <scope classrefs="CCompilerError" doc="Attempt to process an unknown file type.&#xA;" ilk="class" name="UnknownFileError" />
      <import module="archive_util" />
      <scope doc="Return &apos;pathname&apos; as a name that will work on the native&#xA;filesystem, i.e." ilk="function" name="convert_path" signature="convert_path(pathname)" />
      <import module="dep_util" />
      <import module="dir_util" />
      <import module="file_util" />
      <scope doc="Return a list of paths matching a pathname pattern." ilk="function" name="glob" signature="glob(pathname)" />
      <import module="log" />
      <import module="os" />
      <scope classrefs="Command" doc="&#xA;" ilk="class" line="34" lineend="457" name="sdist">
        <scope doc="Read and parse manifest template file named by&#xA;self.template." ilk="function" line="290" lineend="314" name="read_template" signature="read_template(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="template.readline()" line="303" name="line" />
          <variable citdl="TextFile()" line="297" name="template" />
        </scope>
        <scope ilk="function" line="140" lineend="160" name="run" signature="run(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
        </scope>
        <scope doc="Create the directory tree that will become the source&#xA;distribution archive." ilk="function" line="382" lineend="422" name="make_release_tree" signature="make_release_tree(self, base_dir, files)">
          <variable ilk="argument" name="files" />
          <variable citdl="str" line="406" name="msg" />
          <variable citdl="str" line="405" name="link" />
          <variable citdl="os.path.join()" line="419" name="dest" />
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable ilk="argument" name="base_dir" />
        </scope>
        <scope doc="Deprecated API." ilk="function" line="162" lineend="168" name="check_metadata" signature="check_metadata(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="self.distribution.get_command_obj()" line="166" name="check" />
        </scope>
        <scope ilk="function" line="355" lineend="365" name="_manifest_is_not_generated" returns="bool" signature="_manifest_is_not_generated(self)">
          <variable citdl="open()" line="360" name="fp" />
          <variable citdl="fp.readline()" line="362" name="first_line" />
          <variable citdl="sdist" ilk="argument" name="self" />
        </scope>
        <scope doc="Create the source distribution(s)." ilk="function" line="424" lineend="451" name="make_distribution" signature="make_distribution(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="list" line="438" name="archive_files" />
          <variable citdl="self.make_archive()" line="444" name="file" />
          <variable citdl="os.path.join()" line="435" name="base_name" />
          <variable citdl="self.distribution.get_fullname()" line="434" name="base_dir" />
        </scope>
        <scope ilk="function" line="117" lineend="138" name="finalize_options" signature="finalize_options(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="archive_util.check_archive_formats()" line="132" name="bad_format" />
        </scope>
        <scope doc="Prune off branches that might slip into the file list as&#xA;created by &apos;read_template()&apos;, but really don&apos;t belong there:&#xA;* the build tree (typically &quot;build&quot;) * the release tree&#xA;itself (only an issue if we ran &quot;sdist&quot;" ilk="function" line="316" lineend="338" name="prune_file_list" signature="prune_file_list(self)">
          <variable citdl="str" line="331" name="seps" />
          <variable citdl="self.get_finalized_command()" line="324" name="build" />
          <variable citdl="str" line="337" name="vcs_ptrn" />
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="list" line="335" name="vcs_dirs" />
          <variable citdl="self.distribution.get_fullname()" line="325" name="base_dir" />
        </scope>
        <scope doc="Figure out the list of files to include in the source&#xA;distribution, and put it in &apos;self.filelist&apos;." ilk="function" line="170" lineend="208" name="get_file_list" signature="get_file_list(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="os.path.isfile()" line="184" name="template_exists" />
        </scope>
        <scope ilk="function" line="96" lineend="115" name="initialize_options" signature="initialize_options(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
        </scope>
        <scope doc="Callable used for the check sub-command." ilk="function" line="38" lineend="42" name="checking_metadata" returns="self.metadata_check" signature="checking_metadata(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
        </scope>
        <scope doc="Read the manifest file (named by &apos;self.manifest&apos;) and use it&#xA;to fill in &apos;self.filelist&apos;, the list of files to include in&#xA;the source distribution." ilk="function" line="367" lineend="380" name="read_manifest" signature="read_manifest(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="line.strip()" line="376" name="line" />
          <variable citdl="open()" line="373" name="manifest" />
        </scope>
        <scope doc="Add all the default files to self.filelist: - README or&#xA;README.txt - setup.py - test/test*.py" ilk="function" line="210" lineend="288" name="add_defaults" signature="add_defaults(self)">
          <variable citdl="filter()" line="246" name="files" />
          <variable citdl="self.get_finalized_command()" line="252" name="build_py" />
          <variable citdl="convert_path()" line="274" name="f" />
          <variable citdl="True" line="228" name="got_it" />
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="list" line="224" name="standards" />
          <variable citdl="convert_path()" line="268" name="item" />
          <variable citdl="self.get_finalized_command()" line="287" name="build_scripts" />
          <variable citdl="fn" line="227" name="alts" />
          <variable citdl="self.get_finalized_command()" line="283" name="build_clib" />
          <variable citdl="list" line="244" name="optional" />
          <variable citdl="self.get_finalized_command()" line="279" name="build_ext" />
        </scope>
        <scope doc="Write the file list in &apos;self.filelist&apos; (presumably as filled&#xA;in by &apos;add_defaults()&apos; and &apos;read_template()&apos;) to the&#xA;manifest file named by &apos;self.manifest&apos;." ilk="function" line="340" lineend="353" name="write_manifest" signature="write_manifest(self)">
          <variable citdl="list" line="350" name="content" />
          <variable citdl="sdist" ilk="argument" name="self" />
          <variable citdl="open()" line="339" name="fp" />
          <variable citdl="fp.readline()" line="341" name="first_line" />
        </scope>
        <scope doc="Return the list of archive files created when the command&#xA;was run, or None if the command hasn&apos;t run yet." ilk="function" line="453" lineend="457" name="get_archive_files" returns="list" signature="get_archive_files(self)">
          <variable citdl="sdist" ilk="argument" name="self" />
        </scope>
        <variable citdl="list" line="44" name="user_options" />
        <variable attributes="__instancevar__" citdl="list" line="110" name="formats" />
        <variable citdl="str" line="36" name="description" />
        <variable attributes="__instancevar__" citdl="int" line="104" name="use_defaults" />
        <variable attributes="__instancevar__" citdl="int" line="105" name="prune" />
        <variable citdl="list" line="94" name="sub_commands" />
        <variable citdl="list" line="79" name="boolean_options" />
        <variable citdl="list" line="83" name="help_options" />
        <variable attributes="__instancevar__" citdl="FileList()" line="143" name="filelist" />
        <variable attributes="__instancevar__" citdl="int" line="108" name="force_manifest" />
        <variable attributes="__instancevar__" citdl="int" line="107" name="manifest_only" />
        <variable attributes="__instancevar__" citdl="list" line="114" name="archive_files" />
        <variable attributes="__instancevar__" citdl="int" line="115" name="metadata_check" />
        <variable attributes="__instancevar__" citdl="str" line="99" name="template" />
        <variable citdl="dict" line="91" name="default_format" />
        <variable attributes="__instancevar__" citdl="int" line="111" name="keep_temp" />
        <variable attributes="__instancevar__" citdl="str" line="100" name="manifest" />
        <variable attributes="__instancevar__" citdl="str" line="112" name="dist_dir" />
        <variable citdl="dict" line="88" name="negative_opt" />
      </scope>
      <scope doc="Print all possible values for the &apos;formats&apos; option (used by&#xA;the &quot;--help-formats&quot; command-line option)." ilk="function" line="20" lineend="32" name="show_formats" signature="show_formats()">
        <variable citdl="list" line="26" name="formats" />
      </scope>
      <import module="string" />
      <import module="sys" />
      <scope doc="Issue a warning, or maybe ignore it or raise an exception." ilk="function" name="warn" />
      <variable citdl="str" line="5" name="__revision__" />
    </scope>
    