<scope doc="Built-in functions, exceptions, and other objects.&#xA;Noteworthy: None is the `nil&apos; object; Ellipsis represents `...&apos; in slices." ilk="blob" lang="Python" name="builtins">
      <scope classrefs="Exception" doc="Base class for arithmetic errors.&#xA;" ilk="class" name="ArithmeticError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Assertion failed.&#xA;" ilk="class" name="AssertionError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Attribute not found.&#xA;" ilk="class" name="AttributeError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="object" doc="Common base class for all exceptions&#xA;" ilk="class" name="BaseException">
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope ilk="function" name="__setstate__" />
        <scope ilk="function" name="__reduce__" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="set self.__traceback__ to tb and return self." ilk="function" name="with_traceback" signature="Exception.with_traceback(tb) --" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Buffer error.&#xA;" ilk="class" name="BufferError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about bytes and buffer related problems, mostly&#xA;related to conversion from str or comparing to str." ilk="class" name="BytesWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about deprecated features.&#xA;" ilk="class" name="DeprecationWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Read beyond end of file.&#xA;" ilk="class" name="EOFError">
        <scope ilk="function" name="__init__" />
      </scope>
      <variable citdl="ellipsis" name="Ellipsis" />
      <scope classrefs="Exception" doc="Base class for I/O related errors.&#xA;" ilk="class" name="EnvironmentError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__reduce__" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="BaseException" doc="Common base class for all non-exit exceptions.&#xA;" ilk="class" name="Exception">
        <scope ilk="function" name="__init__" />
      </scope>
      <variable citdl="bool" name="False" />
      <scope classrefs="ArithmeticError" doc="Floating point operation failed.&#xA;" ilk="class" name="FloatingPointError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about constructs that will change semantically&#xA;in the future." ilk="class" name="FutureWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="BaseException" doc="Request that a generator exit.&#xA;" ilk="class" name="GeneratorExit">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="EnvironmentError" doc="I/O operation failed.&#xA;" ilk="class" name="IOError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Import can&apos;t find module, or can&apos;t find name in module.&#xA;" ilk="class" name="ImportError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about probable mistakes in module imports&#xA;" ilk="class" name="ImportWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="SyntaxError" doc="Improper indentation.&#xA;" ilk="class" name="IndentationError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="LookupError" doc="Sequence index out of range.&#xA;" ilk="class" name="IndexError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="LookupError" doc="Mapping key not found.&#xA;" ilk="class" name="KeyError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="BaseException" doc="Program interrupted by user.&#xA;" ilk="class" name="KeyboardInterrupt">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Base class for lookup errors.&#xA;" ilk="class" name="LookupError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Out of memory.&#xA;" ilk="class" name="MemoryError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Name not found globally.&#xA;" ilk="class" name="NameError">
        <scope ilk="function" name="__init__" />
      </scope>
      <variable citdl="NoneType" name="None" />
      <variable citdl="NotImplementedType" name="NotImplemented" />
      <scope classrefs="RuntimeError" doc="Method or function hasn&apos;t been implemented yet.&#xA;" ilk="class" name="NotImplementedError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="EnvironmentError" doc="OS system call failed.&#xA;" ilk="class" name="OSError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="ArithmeticError" doc="Result too large to be represented.&#xA;" ilk="class" name="OverflowError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about features which will be deprecated&#xA;in the future." ilk="class" name="PendingDeprecationWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Weak ref proxy used after referent went away.&#xA;" ilk="class" name="ReferenceError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about resource usage.&#xA;" ilk="class" name="ResourceWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Unspecified run-time error.&#xA;" ilk="class" name="RuntimeError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about dubious runtime behavior.&#xA;" ilk="class" name="RuntimeWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Signal the end from iterator.__next__().&#xA;" ilk="class" name="StopIteration">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Invalid syntax.&#xA;" ilk="class" name="SyntaxError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about dubious syntax.&#xA;" ilk="class" name="SyntaxWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Internal error in the Python interpreter.&#xA;Please report this to the Python maintainer, along with the traceback, the Python version, and the hardware/OS platform and version." ilk="class" name="SystemError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="BaseException" doc="Request to exit from the interpreter.&#xA;" ilk="class" name="SystemExit">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="IndentationError" doc="Improper mixture of spaces and tabs.&#xA;" ilk="class" name="TabError">
        <scope ilk="function" name="__init__" />
      </scope>
      <variable citdl="bool" name="True" />
      <scope classrefs="Exception" doc="Inappropriate argument type.&#xA;" ilk="class" name="TypeError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="NameError" doc="Local name referenced but not bound to a value.&#xA;" ilk="class" name="UnboundLocalError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="UnicodeError" doc="Unicode decoding error.&#xA;" ilk="class" name="UnicodeDecodeError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="UnicodeError" doc="Unicode encoding error.&#xA;" ilk="class" name="UnicodeEncodeError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="ValueError" doc="Unicode related error.&#xA;" ilk="class" name="UnicodeError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="UnicodeError" doc="Unicode translation error.&#xA;" ilk="class" name="UnicodeTranslateError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings about Unicode related problems, mostly&#xA;related to conversion problems." ilk="class" name="UnicodeWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Warning" doc="Base class for warnings generated by user code.&#xA;" ilk="class" name="UserWarning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Inappropriate argument value (of correct type).&#xA;" ilk="class" name="ValueError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="Exception" doc="Base class for warning categories.&#xA;" ilk="class" name="Warning">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="OSError" doc="MS-Windows OS system call failed.&#xA;" ilk="class" name="WindowsError">
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope ilk="function" name="__init__" />
      </scope>
      <scope classrefs="ArithmeticError" doc="Second argument to a division or modulo operation was zero.&#xA;" ilk="class" name="ZeroDivisionError">
        <scope ilk="function" name="__init__" />
      </scope>
      <scope doc="Internal helper function used by the class statement." ilk="function" name="__build_class__" signature="__build_class__(func, name, *bases, metaclass=None, **kwds) -&gt; class" />
      <variable citdl="bool" name="__debug__" />
      <scope doc="Import a module." ilk="function" name="__import__" returns="module" signature="__import__(name, globals={}, locals={}, fromlist=[], level=-1) -&gt; module" />
      <scope doc="Return the absolute value of the argument." ilk="function" name="abs" returns="int" signature="abs(number) -&gt; number" />
      <scope doc="Return True if bool(x) is True for all values x in the&#xA;iterable." ilk="function" name="all" returns="bool" signature="all(iterable) -&gt; bool" />
      <scope doc="Return True if bool(x) is True for any x in the iterable." ilk="function" name="any" returns="bool" signature="any(iterable) -&gt; bool" />
      <scope doc="As repr(), return a string containing a printable&#xA;representation of an object, but escape the non-ASCII&#xA;characters in the string returned by repr() using \x, \u or&#xA;\U escapes." ilk="function" name="ascii" returns="str" signature="ascii(object) -&gt; string" />
      <scope doc="Return the binary representation of an integer." ilk="function" name="bin" returns="str" signature="bin(number) -&gt; string" />
      <scope classrefs="int" doc="bool(x) -&gt; bool&#xA;Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed." ilk="class" name="bool">
        <scope doc="x.__rand__(y) &lt;==&gt; y&amp;x" ilk="function" name="__rand__" signature="x.__rand__(y) &lt;==&gt; y&amp;x" />
        <scope doc="x.__ror__(y) &lt;==&gt; y|x" ilk="function" name="__ror__" signature="x.__ror__(y) &lt;==&gt; y|x" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__xor__(y) &lt;==&gt; x^y" ilk="function" name="__xor__" signature="x.__xor__(y) &lt;==&gt; x^y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__and__(y) &lt;==&gt; x&amp;y" ilk="function" name="__and__" signature="x.__and__(y) &lt;==&gt; x&amp;y" />
        <scope doc="x.__rxor__(y) &lt;==&gt; y^x" ilk="function" name="__rxor__" signature="x.__rxor__(y) &lt;==&gt; y^x" />
        <scope doc="x.__or__(y) &lt;==&gt; x|y" ilk="function" name="__or__" signature="x.__or__(y) &lt;==&gt; x|y" />
      </scope>
      <scope classrefs="object" doc="bytearray(iterable_of_ints) -&gt; bytearray&#xA;bytearray(string, encoding[, errors]) -&gt; bytearray bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray bytearray(memory_view) -&gt; bytearray  Construct an mutable bytearray object from: - an iterable yielding integers in range(256) - a text string encoded using the specified encoding - a bytes or a bytearray object - any object implementing the buffer API. " ilk="class" name="bytearray">
        <scope doc="Return a copy of B with all ASCII characters converted to&#xA;uppercase." ilk="function" name="upper" signature="B.upper() -&gt; copy of B" />
        <scope doc="Reverse the order of the values in B in place." ilk="function" name="reverse" signature="B.reverse() -&gt; None" />
        <scope doc="Return a list of the sections in B, using sep as the&#xA;delimiter, starting at the end of B and working to the&#xA;front." ilk="function" name="rsplit" returns="list" signature="B.rsplit(sep[, maxsplit]) -&gt; list of bytearrays" />
        <scope doc="Return True if B starts with the specified prefix, False&#xA;otherwise." ilk="function" name="startswith" returns="bool" signature="B.startswith(prefix[, start[, end]]) -&gt; bool" />
        <scope doc="Strip leading bytes contained in the argument and return the&#xA;result as a new bytearray." ilk="function" name="lstrip" signature="B.lstrip([bytes]) -&gt; bytearray" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Remove the first occurrence of a value in B." ilk="function" name="remove" signature="B.remove(int) -&gt; None" />
        <scope doc="Remove and return a single item from B." ilk="function" name="pop" returns="int" signature="B.pop([index]) -&gt; int" />
        <scope doc="Return a copy of B with all occurrences of subsection old&#xA;replaced by new." ilk="function" name="replace" signature="B.replace(old, new[, count]) -&gt; bytearray" />
        <scope doc="Return True if all characters in B are digits and there is&#xA;at least one character in B, False otherwise." ilk="function" name="isdigit" returns="bool" signature="B.isdigit() -&gt; bool" />
        <scope doc="Return True if B ends with the specified suffix, False&#xA;otherwise." ilk="function" name="endswith" returns="bool" signature="B.endswith(suffix[, start[, end]]) -&gt; bool" />
        <scope doc="Return a list of the lines in B, breaking at line&#xA;boundaries." ilk="function" name="splitlines" returns="list" signature="B.splitlines([keepends]) -&gt; list of lines" />
        <scope doc="Return a copy of B where all tab characters are expanded&#xA;using spaces." ilk="function" name="expandtabs" signature="B.expandtabs([tabsize]) -&gt; copy of B" />
        <scope doc="Strip leading and trailing bytes contained in the argument&#xA;and return the result as a new bytearray." ilk="function" name="strip" signature="B.strip([bytes]) -&gt; bytearray" />
        <scope doc="x.__rmul__(n) &lt;==&gt; n*x" ilk="function" name="__rmul__" signature="x.__rmul__(n) &lt;==&gt; n*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="Return B left justified in a string of length width." ilk="function" name="ljust" signature="B.ljust(width[, fillchar]) -&gt; copy of B" />
        <scope doc="Returns the size of B in memory, in bytes" ilk="function" name="__sizeof__" returns="int" signature="B.__sizeof__() -&gt; int" />
        <scope ilk="function" name="__init__" />
        <scope doc="Like B.find() but raise ValueError when the subsection is&#xA;not found." ilk="function" name="index" returns="int" signature="B.index(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return True if all characters in B are alphanumeric and&#xA;there is at least one character in B, False otherwise." ilk="function" name="isalnum" returns="bool" signature="B.isalnum() -&gt; bool" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope doc="Like B.rfind() but raise ValueError when the subsection is&#xA;not found." ilk="function" name="rindex" returns="int" signature="B.rindex(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return a copy of B with only its first character capitalized&#xA;(ASCII) and the rest lower-cased." ilk="function" name="capitalize" signature="B.capitalize() -&gt; copy of B" />
        <scope doc="Return the lowest index in B where subsection sub is found,&#xA;such that sub is contained within B[start,end]." ilk="function" name="find" returns="int" signature="B.find(sub[, start[, end]]) -&gt; int" />
        <scope doc="Decode B using the codec registered for encoding." ilk="function" name="decode" returns="str" signature="B.decode(encoding=&apos;utf-8&apos;, errors=&apos;strict&apos;) -&gt; str" />
        <scope doc="Return True if all characters in B are alphabetic and there&#xA;is at least one character in B, False otherwise." ilk="function" name="isalpha" returns="bool" signature="B.isalpha() -&gt; bool" />
        <scope doc="Return the number of bytes actually allocated." ilk="function" name="__alloc__" returns="int" signature="B.__alloc__() -&gt; int" />
        <scope doc="Strip trailing bytes contained in the argument and return&#xA;the result as a new bytearray." ilk="function" name="rstrip" signature="B.rstrip([bytes]) -&gt; bytearray" />
        <scope doc="Return a copy of B, where all characters occurring in the&#xA;optional argument deletechars are removed, and the remaining&#xA;characters have been mapped through the given translation&#xA;table, which must be a bytes object of length 256." ilk="function" name="translate" signature="B.translate(table[, deletechars]) -&gt; bytearray" />
        <scope doc="Return True if all characters in B are whitespace and there&#xA;is at least one character in B, False otherwise." ilk="function" name="isspace" returns="bool" signature="B.isspace() -&gt; bool" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__mul__(n) &lt;==&gt; x*n" ilk="function" name="__mul__" signature="x.__mul__(n) &lt;==&gt; x*n" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="Return the highest index in B where subsection sub is found,&#xA;such that sub is contained within B[start,end]." ilk="function" name="rfind" returns="int" signature="B.rfind(sub[, start[, end]]) -&gt; int" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="Insert a single item into the bytearray before the given&#xA;index." ilk="function" name="insert" signature="B.insert(index, int) -&gt; None" />
        <scope doc="Return state information for pickling." ilk="function" name="__reduce__" />
        <scope doc="Return a copy of B with all ASCII characters converted to&#xA;lowercase." ilk="function" name="lower" signature="B.lower() -&gt; copy of B" />
        <scope doc="Append a single item to the end of B." ilk="function" name="append" signature="B.append(int) -&gt; None" />
        <scope doc="Return a copy of B with uppercase ASCII characters converted&#xA;to lowercase ASCII and vice versa." ilk="function" name="swapcase" signature="B.swapcase() -&gt; copy of B" />
        <scope doc="x.__setitem__(i, y) &lt;==&gt; x[i]=y" ilk="function" name="__setitem__" signature="x.__setitem__(i, y) &lt;==&gt; x[i]=y" />
        <scope doc="Pad a numeric string B with zeros on the left, to fill a&#xA;field of the specified width." ilk="function" name="zfill" signature="B.zfill(width) -&gt; copy of B" />
        <scope doc="Search for the separator sep in B, starting at the end of B,&#xA;and return the part before it, the separator itself, and the&#xA;part after it." ilk="function" name="rpartition" signature="B.rpartition(sep) -&gt; (head, sep, tail)" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="Return B right justified in a string of length width." ilk="function" name="rjust" signature="B.rjust(width[, fillchar]) -&gt; copy of B" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="Return B centered in a string of length width." ilk="function" name="center" signature="B.center(width[, fillchar]) -&gt; copy of B" />
        <scope doc="Return the number of non-overlapping occurrences of&#xA;subsection sub in bytes B[start:end]." ilk="function" name="count" returns="int" signature="B.count(sub[, start[, end]]) -&gt; int" />
        <scope doc="x.__delitem__(y) &lt;==&gt; del x[y]" ilk="function" name="__delitem__" signature="x.__delitem__(y) &lt;==&gt; del x[y]" />
        <scope doc="Append all the elements from the iterator or sequence to the&#xA;end of B." ilk="function" name="extend" signature="B.extend(iterable_of_ints) -&gt; None" />
        <scope doc="Concatenate any number of bytes/bytearray objects, with B in&#xA;between each pair, and return the result as a new bytearray." ilk="function" name="join" signature="B.join(iterable_of_bytes) -&gt; bytearray" />
        <scope doc="x.__imul__(y) &lt;==&gt; x*=y" ilk="function" name="__imul__" signature="x.__imul__(y) &lt;==&gt; x*=y" />
        <scope doc="Return a list of the sections in B, using sep as the&#xA;delimiter." ilk="function" name="split" returns="list" signature="B.split([sep[, maxsplit]]) -&gt; list of bytearrays" />
        <scope doc="Search for the separator sep in B, and return the part&#xA;before it, the separator itself, and the part after it." ilk="function" name="partition" signature="B.partition(sep) -&gt; (head, sep, tail)" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__iadd__(y) &lt;==&gt; x+=y" ilk="function" name="__iadd__" signature="x.__iadd__(y) &lt;==&gt; x+=y" />
        <scope doc="Return True if B is a titlecased string and there is at&#xA;least one character in B, i.e." ilk="function" name="istitle" returns="bool" signature="B.istitle() -&gt; bool" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="Return True if all cased characters in B are lowercase and&#xA;there is at least one cased character in B, False otherwise." ilk="function" name="islower" returns="bool" signature="B.islower() -&gt; bool" />
        <scope doc="Return a titlecased version of B, i.e." ilk="function" name="title" signature="B.title() -&gt; copy of B" />
        <scope doc="Return True if all cased characters in B are uppercase and&#xA;there is at least one cased character in B, False otherwise." ilk="function" name="isupper" returns="bool" signature="B.isupper() -&gt; bool" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope classrefs="object" doc="bytes(iterable_of_ints) -&gt; bytes&#xA;bytes(string, encoding[, errors]) -&gt; bytes bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer bytes(memory_view) -&gt; bytes  Construct an immutable array of bytes from: - an iterable yielding integers in range(256) - a text string encoded using the specified encoding - a bytes or a buffer object - any object implementing the buffer API." ilk="class" name="bytes">
        <scope doc="Return a copy of B with all ASCII characters converted to&#xA;uppercase." ilk="function" name="upper" signature="B.upper() -&gt; copy of B" />
        <scope doc="Return True if B starts with the specified prefix, False&#xA;otherwise." ilk="function" name="startswith" returns="bool" signature="B.startswith(prefix[, start[, end]]) -&gt; bool" />
        <scope doc="Strip leading bytes contained in the argument." ilk="function" name="lstrip" signature="B.lstrip([bytes]) -&gt; bytes" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Search for the separator sep in B, starting at the end of B,&#xA;and return the part before it, the separator itself, and the&#xA;part after it." ilk="function" name="rpartition" signature="B.rpartition(sep) -&gt; (head, sep, tail)" />
        <scope doc="Return a copy of B with all occurrences of subsection old&#xA;replaced by new." ilk="function" name="replace" signature="B.replace(old, new[, count]) -&gt; bytes" />
        <scope doc="Return True if all characters in B are digits and there is&#xA;at least one character in B, False otherwise." ilk="function" name="isdigit" returns="bool" signature="B.isdigit() -&gt; bool" />
        <scope doc="Return True if B ends with the specified suffix, False&#xA;otherwise." ilk="function" name="endswith" returns="bool" signature="B.endswith(suffix[, start[, end]]) -&gt; bool" />
        <scope doc="Return a list of the lines in B, breaking at line&#xA;boundaries." ilk="function" name="splitlines" returns="list" signature="B.splitlines([keepends]) -&gt; list of lines" />
        <scope doc="Return the highest index in B where substring sub is found,&#xA;such that sub is contained within B[start:end]." ilk="function" name="rfind" returns="int" signature="B.rfind(sub[, start[, end]]) -&gt; int" />
        <scope doc="Strip leading and trailing bytes contained in the argument." ilk="function" name="strip" signature="B.strip([bytes]) -&gt; bytes" />
        <scope doc="x.__rmul__(n) &lt;==&gt; n*x" ilk="function" name="__rmul__" signature="x.__rmul__(n) &lt;==&gt; n*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="Return the lowest index in B where substring sub is found,&#xA;such that sub is contained within B[start:end]." ilk="function" name="find" returns="int" signature="B.find(sub[, start[, end]]) -&gt; int" />
        <scope doc="Like B.find() but raise ValueError when the substring is not&#xA;found." ilk="function" name="index" returns="int" signature="B.index(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return B left justified in a string of length width." ilk="function" name="ljust" signature="B.ljust(width[, fillchar]) -&gt; copy of B" />
        <scope doc="Return True if all characters in B are alphanumeric and&#xA;there is at least one character in B, False otherwise." ilk="function" name="isalnum" returns="bool" signature="B.isalnum() -&gt; bool" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope doc="Like B.rfind() but raise ValueError when the substring is&#xA;not found." ilk="function" name="rindex" returns="int" signature="B.rindex(sub[, start[, end]]) -&gt; int" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="Decode B using the codec registered for encoding." ilk="function" name="decode" returns="str" signature="B.decode(encoding=&apos;utf-8&apos;, errors=&apos;strict&apos;) -&gt; str" />
        <scope doc="Return True if all characters in B are alphabetic and there&#xA;is at least one character in B, False otherwise." ilk="function" name="isalpha" returns="bool" signature="B.isalpha() -&gt; bool" />
        <scope doc="Return a list of the sections in B, using sep as the&#xA;delimiter." ilk="function" name="split" returns="list" signature="B.split([sep[, maxsplit]]) -&gt; list of bytes" />
        <scope doc="Strip trailing bytes contained in the argument." ilk="function" name="rstrip" signature="B.rstrip([bytes]) -&gt; bytes" />
        <scope doc="Return a copy of B, where all characters occurring in the&#xA;optional argument deletechars are removed, and the remaining&#xA;characters have been mapped through the given translation&#xA;table, which must be a bytes object of length 256." ilk="function" name="translate" signature="B.translate(table[, deletechars]) -&gt; bytes" />
        <scope doc="Return True if all characters in B are whitespace and there&#xA;is at least one character in B, False otherwise." ilk="function" name="isspace" returns="bool" signature="B.isspace() -&gt; bool" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__mul__(n) &lt;==&gt; x*n" ilk="function" name="__mul__" signature="x.__mul__(n) &lt;==&gt; x*n" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="Return B right justified in a string of length width." ilk="function" name="rjust" signature="B.rjust(width[, fillchar]) -&gt; copy of B" />
        <scope doc="Return a copy of B with uppercase ASCII characters converted&#xA;to lowercase ASCII and vice versa." ilk="function" name="swapcase" signature="B.swapcase() -&gt; copy of B" />
        <scope doc="Return True if all cased characters in B are lowercase and&#xA;there is at least one cased character in B, False otherwise." ilk="function" name="islower" returns="bool" signature="B.islower() -&gt; bool" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="Pad a numeric string B with zeros on the left, to fill a&#xA;field of the specified width." ilk="function" name="zfill" signature="B.zfill(width) -&gt; copy of B" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="Return a copy of B with only its first character capitalized&#xA;(ASCII) and the rest lower-cased." ilk="function" name="capitalize" signature="B.capitalize() -&gt; copy of B" />
        <scope doc="B.__sizeof__() -&gt; size of B in memory, in bytes" ilk="function" name="__sizeof__" signature="B.__sizeof__() -&gt; size of B in memory, in bytes" />
        <scope doc="Return the number of non-overlapping occurrences of&#xA;substring sub in string B[start:end]." ilk="function" name="count" returns="int" signature="B.count(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return a copy of B with all ASCII characters converted to&#xA;lowercase." ilk="function" name="lower" signature="B.lower() -&gt; copy of B" />
        <scope doc="Concatenate any number of bytes objects, with B in between&#xA;each pair." ilk="function" name="join" signature="B.join(iterable_of_bytes) -&gt; bytes" />
        <scope doc="Return B centered in a string of length width." ilk="function" name="center" signature="B.center(width[, fillchar]) -&gt; copy of B" />
        <scope doc="Search for the separator sep in B, and return the part&#xA;before it, the separator itself, and the part after it." ilk="function" name="partition" signature="B.partition(sep) -&gt; (head, sep, tail)" />
        <scope doc="Return a list of the sections in B, using sep as the&#xA;delimiter, starting at the end of B and working to the&#xA;front." ilk="function" name="rsplit" returns="list" signature="B.rsplit([sep[, maxsplit]]) -&gt; list of bytes" />
        <scope doc="Return a copy of B where all tab characters are expanded&#xA;using spaces." ilk="function" name="expandtabs" signature="B.expandtabs([tabsize]) -&gt; copy of B" />
        <scope doc="Return True if B is a titlecased string and there is at&#xA;least one character in B, i.e." ilk="function" name="istitle" returns="bool" signature="B.istitle() -&gt; bool" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="Return a titlecased version of B, i.e." ilk="function" name="title" signature="B.title() -&gt; copy of B" />
        <scope doc="Return True if all cased characters in B are uppercase and&#xA;there is at least one cased character in B, False otherwise." ilk="function" name="isupper" returns="bool" signature="B.isupper() -&gt; bool" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="Return whether the object is callable (i.e., some kind of&#xA;function)." ilk="function" name="callable" returns="bool" signature="callable(object) -&gt; bool" />
      <scope doc="Return a Unicode string of one character with ordinal i; 0&#xA;&lt;= i &lt;= 0x10ffff." ilk="function" name="chr" returns="unicode" signature="chr(i) -&gt; Unicode character" />
      <scope classrefs="object" doc="classmethod(function) -&gt; method&#xA;Convert a function to be a class method.  A class method receives the class as implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom:  class C: def f(cls, arg1, arg2, ...): ... f = classmethod(f) " ilk="class" name="classmethod">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope ilk="function" name="__init__" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope doc="Compile the source string (a Python module, statement or&#xA;expression) into a code object that can be executed by&#xA;exec() or eval()." ilk="function" name="compile" returns="code" signature="compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object" />
      <scope classrefs="object" doc="complex(real[, imag]) -&gt; complex number&#xA;Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0." ilk="class" name="complex">
        <scope doc="x.__int__() &lt;==&gt; int(x)" ilk="function" name="__int__" signature="x.__int__() &lt;==&gt; int(x)" />
        <scope doc="x.__rtruediv__(y) &lt;==&gt; y/x" ilk="function" name="__rtruediv__" signature="x.__rtruediv__(y) &lt;==&gt; y/x" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__radd__(y) &lt;==&gt; y+x" ilk="function" name="__radd__" signature="x.__radd__(y) &lt;==&gt; y+x" />
        <scope doc="x.__truediv__(y) &lt;==&gt; x/y" ilk="function" name="__truediv__" signature="x.__truediv__(y) &lt;==&gt; x/y" />
        <scope doc="x.__rsub__(y) &lt;==&gt; y-x" ilk="function" name="__rsub__" signature="x.__rsub__(y) &lt;==&gt; y-x" />
        <scope doc="Returns the complex conjugate of its argument." ilk="function" name="conjugate" returns="complex" signature="complex.conjugate() -&gt; complex" />
        <scope doc="x.__rmul__(y) &lt;==&gt; y*x" ilk="function" name="__rmul__" signature="x.__rmul__(y) &lt;==&gt; y*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="x.__rmod__(y) &lt;==&gt; y%x" ilk="function" name="__rmod__" signature="x.__rmod__(y) &lt;==&gt; y%x" />
        <scope doc="x.__float__() &lt;==&gt; float(x)" ilk="function" name="__float__" signature="x.__float__() &lt;==&gt; float(x)" />
        <scope doc="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__rpow__" signature="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" />
        <scope doc="Converts to a string according to format_spec." ilk="function" name="__format__" returns="str" signature="complex.__format__() -&gt; str" />
        <scope doc="x.__abs__() &lt;==&gt; abs(x)" ilk="function" name="__abs__" signature="x.__abs__() &lt;==&gt; abs(x)" />
        <scope doc="x.__pos__() &lt;==&gt; +x" ilk="function" name="__pos__" signature="x.__pos__() &lt;==&gt; +x" />
        <scope doc="x.__rfloordiv__(y) &lt;==&gt; y//x" ilk="function" name="__rfloordiv__" signature="x.__rfloordiv__(y) &lt;==&gt; y//x" />
        <scope doc="x.__mul__(y) &lt;==&gt; x*y" ilk="function" name="__mul__" signature="x.__mul__(y) &lt;==&gt; x*y" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" ilk="function" name="__rdivmod__" signature="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" />
        <scope doc="x.__divmod__(y) &lt;==&gt; divmod(x, y)" ilk="function" name="__divmod__" signature="x.__divmod__(y) &lt;==&gt; divmod(x, y)" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__bool__() &lt;==&gt; x != 0" ilk="function" name="__bool__" signature="x.__bool__() &lt;==&gt; x != 0" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__mod__(y) &lt;==&gt; x%y" ilk="function" name="__mod__" signature="x.__mod__(y) &lt;==&gt; x%y" />
        <scope doc="x.__neg__() &lt;==&gt; -x" ilk="function" name="__neg__" signature="x.__neg__() &lt;==&gt; -x" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__floordiv__(y) &lt;==&gt; x//y" ilk="function" name="__floordiv__" signature="x.__floordiv__(y) &lt;==&gt; x//y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__sub__(y) &lt;==&gt; x-y" ilk="function" name="__sub__" signature="x.__sub__(y) &lt;==&gt; x-y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
        <scope doc="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__pow__" signature="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" />
      </scope>
      <variable citdl="_Printer" name="copyright" />
      <variable citdl="_Printer" name="credits" />
      <scope doc="Delete a named attribute on an object; delattr(x, &apos;y&apos;) is&#xA;equivalent to ``del x.y&apos;&apos;." ilk="function" name="delattr" signature="delattr(object, name)" />
      <scope classrefs="object" doc="dict() -&gt; new empty dictionary&#xA;dict(mapping) -&gt; new dictionary initialized from a mapping object&apos;s (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1, two=2)" ilk="class" name="dict">
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="If key is not found, d is returned if given, otherwise&#xA;KeyError is raised" ilk="function" name="pop" signature="D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value." />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="D.__sizeof__() -&gt; size of D in memory, in bytes" ilk="function" name="__sizeof__" signature="D.__sizeof__() -&gt; size of D in memory, in bytes" />
        <scope ilk="function" name="__init__" />
        <scope doc="D.__contains__(k) -&gt; True if D has a key k, else False" ilk="function" name="__contains__" returns="bool" signature="D.__contains__(k) -&gt; True if D has a key k, else False" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None." ilk="function" name="get" signature="D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None." />
        <scope doc="D.keys() -&gt; a set-like object providing a view on D&apos;s keys" ilk="function" name="keys" signature="D.keys() -&gt; a set-like object providing a view on D&apos;s keys" />
        <scope doc="If E has a .keys() method, does:     for k in E: D[k] = E[k]&#xA;If E lacks .keys() method, does:     for (k, v) in E: D[k] =&#xA;v In either case, this is followed by: for k in F: D[k] =&#xA;F[k]" ilk="function" name="update" signature="D.update(E, **F) -&gt; None.  Update D from dict/iterable E and F." />
        <scope doc="x.__setitem__(i, y) &lt;==&gt; x[i]=y" ilk="function" name="__setitem__" signature="x.__setitem__(i, y) &lt;==&gt; x[i]=y" />
        <scope doc="2-tuple; but raise KeyError if D is empty." ilk="function" name="popitem" signature="D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a" />
        <scope doc="D.copy() -&gt; a shallow copy of D" ilk="function" name="copy" signature="D.copy() -&gt; a shallow copy of D" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__delitem__(y) &lt;==&gt; del x[y]" ilk="function" name="__delitem__" signature="x.__delitem__(y) &lt;==&gt; del x[y]" />
        <scope doc="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D" ilk="function" name="setdefault" signature="D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D" />
        <scope doc="D.items() -&gt; a set-like object providing a view on D&apos;s items" ilk="function" name="items" signature="D.items() -&gt; a set-like object providing a view on D&apos;s items" />
        <scope doc="D.clear() -&gt; None.  Remove all items from D." ilk="function" name="clear" signature="D.clear() -&gt; None.  Remove all items from D." />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="D.values() -&gt; an object providing a view on D&apos;s values" ilk="function" name="values" signature="D.values() -&gt; an object providing a view on D&apos;s values" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="If called without an argument, return the names in the&#xA;current scope." ilk="function" name="dir" returns="list" signature="dir([object]) -&gt; list of strings" />
      <scope doc="Return the tuple ((x-x%y)/y, x%y)." ilk="function" name="divmod" signature="divmod(x, y) -&gt; (div, mod)" />
      <scope classrefs="object" doc="enumerate(iterable[, start]) -&gt; iterator for index, value of iterable&#xA;Return an enumerate object.  iterable must be another object that supports iteration.  The enumerate object yields pairs containing a count (from start, which defaults to zero) and a value yielded by the iterable argument. enumerate is useful for obtaining an indexed list: (0, seq[0]), (1, seq[1]), (2, seq[2]), ..." ilk="class" name="enumerate">
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
      </scope>
      <scope doc="Evaluate the source in the context of globals and locals." ilk="function" name="eval" signature="eval(source[, globals[, locals]]) -&gt; value" />
      <scope doc="Read and execute code from an object, which can be a string&#xA;or a code object." ilk="function" name="exec" signature="exec(object[, globals[, locals]])" />
      <variable citdl="Quitter" name="exit" />
      <scope classrefs="object" doc="filter(function or None, iterable) --&gt; filter object&#xA;Return an iterator yielding those items of iterable for which function(item) is true. If function is None, return the items that are true." ilk="class" name="filter">
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
      </scope>
      <scope classrefs="object" doc="float(x) -&gt; floating point number&#xA;Convert a string or number to a floating point number, if possible." ilk="class" name="float">
        <scope doc="x.__int__() &lt;==&gt; int(x)" ilk="function" name="__int__" signature="x.__int__() &lt;==&gt; int(x)" />
        <scope doc="x.__rtruediv__(y) &lt;==&gt; y/x" ilk="function" name="__rtruediv__" signature="x.__rtruediv__(y) &lt;==&gt; y/x" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__radd__(y) &lt;==&gt; y+x" ilk="function" name="__radd__" signature="x.__radd__(y) &lt;==&gt; y+x" />
        <scope doc="Returns the Integral closest to x between 0 and x." ilk="function" name="__trunc__" />
        <scope doc="x.__truediv__(y) &lt;==&gt; x/y" ilk="function" name="__truediv__" signature="x.__truediv__(y) &lt;==&gt; x/y" />
        <scope doc="x.__rsub__(y) &lt;==&gt; y-x" ilk="function" name="__rsub__" signature="x.__rsub__(y) &lt;==&gt; y-x" />
        <scope doc="Returns self, the complex conjugate of any float." ilk="function" name="conjugate" />
        <scope doc="x.__rmul__(y) &lt;==&gt; y*x" ilk="function" name="__rmul__" signature="x.__rmul__(y) &lt;==&gt; y*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="Returns a pair of integers, whose ratio is exactly equal to&#xA;the original float and with a positive denominator." ilk="function" name="as_integer_ratio" signature="float.as_integer_ratio() -&gt; (int, int)" />
        <scope doc="x.__rmod__(y) &lt;==&gt; y%x" ilk="function" name="__rmod__" signature="x.__rmod__(y) &lt;==&gt; y%x" />
        <scope doc="x.__float__() &lt;==&gt; float(x)" ilk="function" name="__float__" signature="x.__float__() &lt;==&gt; float(x)" />
        <scope doc="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__rpow__" signature="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="Formats the float according to format_spec." ilk="function" name="__format__" returns="str" signature="float.__format__(format_spec) -&gt; string" />
        <scope doc="Return a hexadecimal representation of a floating-point&#xA;number." ilk="function" name="hex" returns="str" signature="float.hex() -&gt; string" />
        <scope doc="x.__abs__() &lt;==&gt; abs(x)" ilk="function" name="__abs__" signature="x.__abs__() &lt;==&gt; abs(x)" />
        <scope doc="x.__pos__() &lt;==&gt; +x" ilk="function" name="__pos__" signature="x.__pos__() &lt;==&gt; +x" />
        <scope doc="x.__rfloordiv__(y) &lt;==&gt; y//x" ilk="function" name="__rfloordiv__" signature="x.__rfloordiv__(y) &lt;==&gt; y//x" />
        <scope doc="x.__mul__(y) &lt;==&gt; x*y" ilk="function" name="__mul__" signature="x.__mul__(y) &lt;==&gt; x*y" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" ilk="function" name="__rdivmod__" signature="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" />
        <scope doc="x.__divmod__(y) &lt;==&gt; divmod(x, y)" ilk="function" name="__divmod__" signature="x.__divmod__(y) &lt;==&gt; divmod(x, y)" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__bool__() &lt;==&gt; x != 0" ilk="function" name="__bool__" signature="x.__bool__() &lt;==&gt; x != 0" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="Returns True if the float is an integer." ilk="function" name="is_integer" />
        <scope doc="Returns the Integral closest to x, rounding half toward&#xA;even." ilk="function" name="__round__" />
        <scope doc="x.__mod__(y) &lt;==&gt; x%y" ilk="function" name="__mod__" signature="x.__mod__(y) &lt;==&gt; x%y" />
        <scope doc="x.__neg__() &lt;==&gt; -x" ilk="function" name="__neg__" signature="x.__neg__() &lt;==&gt; -x" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__floordiv__(y) &lt;==&gt; x//y" ilk="function" name="__floordiv__" signature="x.__floordiv__(y) &lt;==&gt; x//y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__sub__(y) &lt;==&gt; x-y" ilk="function" name="__sub__" signature="x.__sub__(y) &lt;==&gt; x-y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
        <scope doc="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__pow__" signature="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" />
      </scope>
      <scope doc="Returns value.__format__(format_spec) format_spec defaults&#xA;to &quot;&quot;" ilk="function" name="format" returns="str" signature="format(value[, format_spec]) -&gt; string" />
      <scope classrefs="object" doc="frozenset() -&gt; empty frozenset object&#xA;frozenset(iterable) -&gt; frozenset object  Build an immutable unordered collection of unique elements." ilk="class" name="frozenset">
        <scope doc="x.__ror__(y) &lt;==&gt; y|x" ilk="function" name="__ror__" signature="x.__ror__(y) &lt;==&gt; y|x" />
        <scope doc="Report whether another set contains this set." ilk="function" name="issubset" />
        <scope doc="Return the symmetric difference of two sets as a new set." ilk="function" name="symmetric_difference" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Report whether this set contains another set." ilk="function" name="issuperset" />
        <scope doc="x.__rsub__(y) &lt;==&gt; y-x" ilk="function" name="__rsub__" signature="x.__rsub__(y) &lt;==&gt; y-x" />
        <scope doc="x.__and__(y) &lt;==&gt; x&amp;y" ilk="function" name="__and__" signature="x.__and__(y) &lt;==&gt; x&amp;y" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="S.__sizeof__() -&gt; size of S in memory, in bytes" ilk="function" name="__sizeof__" signature="S.__sizeof__() -&gt; size of S in memory, in bytes" />
        <scope doc="x.__rand__(y) &lt;==&gt; y&amp;x" ilk="function" name="__rand__" signature="x.__rand__(y) &lt;==&gt; y&amp;x" />
        <scope doc="Return the intersection of two sets as a new set." ilk="function" name="intersection" />
        <scope doc="Return the difference of two or more sets as a new set." ilk="function" name="difference" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x." ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x." />
        <scope doc="Return the union of sets as a new set." ilk="function" name="union" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="Return state information for pickling." ilk="function" name="__reduce__" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__or__(y) &lt;==&gt; x|y" ilk="function" name="__or__" signature="x.__or__(y) &lt;==&gt; x|y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="Return a shallow copy of a set." ilk="function" name="copy" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__rxor__(y) &lt;==&gt; y^x" ilk="function" name="__rxor__" signature="x.__rxor__(y) &lt;==&gt; y^x" />
        <scope doc="Return True if two sets have a null intersection." ilk="function" name="isdisjoint" />
        <scope doc="x.__xor__(y) &lt;==&gt; x^y" ilk="function" name="__xor__" signature="x.__xor__(y) &lt;==&gt; x^y" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__sub__(y) &lt;==&gt; x-y" ilk="function" name="__sub__" signature="x.__sub__(y) &lt;==&gt; x-y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="Get a named attribute from an object; getattr(x, &apos;y&apos;) is&#xA;equivalent to x.y." ilk="function" name="getattr" signature="getattr(object, name[, default]) -&gt; value" />
      <scope doc="Return the dictionary containing the current scope&apos;s global&#xA;variables." ilk="function" name="globals" returns="dict" signature="globals() -&gt; dictionary" />
      <scope doc="Return whether the object has an attribute with the given&#xA;name." ilk="function" name="hasattr" returns="bool" signature="hasattr(object, name) -&gt; bool" />
      <scope doc="Return a hash value for the object." ilk="function" name="hash" returns="int" signature="hash(object) -&gt; integer" />
      <variable citdl="_Helper" name="help" />
      <scope doc="Return the hexadecimal representation of an integer." ilk="function" name="hex" returns="str" signature="hex(number) -&gt; string" />
      <scope doc="Return the identity of an object." ilk="function" name="id" returns="int" signature="id(object) -&gt; integer" />
      <scope doc="Read a string from standard input." ilk="function" name="input" returns="str" signature="input([prompt]) -&gt; string" />
      <scope classrefs="object" doc="int(x[, base]) -&gt; integer&#xA;Convert a string or number to an integer, if possible.  A floating point argument will be truncated towards zero (this does not include a string representation of a floating point number!)  When converting a string, use the optional base.  It is an error to supply a base when converting a non-string." ilk="class" name="int">
        <scope doc="x.__int__() &lt;==&gt; int(x)" ilk="function" name="__int__" signature="x.__int__() &lt;==&gt; int(x)" />
        <scope doc="x.__ror__(y) &lt;==&gt; y|x" ilk="function" name="__ror__" signature="x.__ror__(y) &lt;==&gt; y|x" />
        <scope doc="x.__rtruediv__(y) &lt;==&gt; y/x" ilk="function" name="__rtruediv__" signature="x.__rtruediv__(y) &lt;==&gt; y/x" />
        <scope doc="x.__lshift__(y) &lt;==&gt; x&lt;&lt;y" ilk="function" name="__lshift__" signature="x.__lshift__(y) &lt;==&gt; x&lt;&lt;y" />
        <scope doc="x.__rshift__(y) &lt;==&gt; x&gt;&gt;y" ilk="function" name="__rshift__" signature="x.__rshift__(y) &lt;==&gt; x&gt;&gt;y" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__radd__(y) &lt;==&gt; y+x" ilk="function" name="__radd__" signature="x.__radd__(y) &lt;==&gt; y+x" />
        <scope doc="x.__and__(y) &lt;==&gt; x&amp;y" ilk="function" name="__and__" signature="x.__and__(y) &lt;==&gt; x&amp;y" />
        <scope doc="x.__truediv__(y) &lt;==&gt; x/y" ilk="function" name="__truediv__" signature="x.__truediv__(y) &lt;==&gt; x/y" />
        <scope doc="x.__rrshift__(y) &lt;==&gt; y&gt;&gt;x" ilk="function" name="__rrshift__" signature="x.__rrshift__(y) &lt;==&gt; y&gt;&gt;x" />
        <scope doc="x.__rsub__(y) &lt;==&gt; y-x" ilk="function" name="__rsub__" signature="x.__rsub__(y) &lt;==&gt; y-x" />
        <scope doc="Returns self, the complex conjugate of any int." ilk="function" name="conjugate" />
        <scope doc="x.__rmul__(y) &lt;==&gt; y*x" ilk="function" name="__rmul__" signature="x.__rmul__(y) &lt;==&gt; y*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="Ceiling of an Integral returns itself." ilk="function" name="__ceil__" />
        <scope doc="x.__rmod__(y) &lt;==&gt; y%x" ilk="function" name="__rmod__" signature="x.__rmod__(y) &lt;==&gt; y%x" />
        <scope doc="x.__float__() &lt;==&gt; float(x)" ilk="function" name="__float__" signature="x.__float__() &lt;==&gt; float(x)" />
        <scope doc="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__rpow__" signature="y.__rpow__(x[, z]) &lt;==&gt; pow(x, y[, z])" />
        <scope doc="x.__rand__(y) &lt;==&gt; y&amp;x" ilk="function" name="__rand__" signature="x.__rand__(y) &lt;==&gt; y&amp;x" />
        <scope doc="Return an array of bytes representing an integer." ilk="function" name="to_bytes" signature="int.to_bytes(length, byteorder, *, signed=False) -&gt; bytes" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="x.__or__(y) &lt;==&gt; x|y" ilk="function" name="__or__" signature="x.__or__(y) &lt;==&gt; x|y" />
        <scope doc="x.__rlshift__(y) &lt;==&gt; y&lt;&lt;x" ilk="function" name="__rlshift__" signature="x.__rlshift__(y) &lt;==&gt; y&lt;&lt;x" />
        <scope doc="x.__abs__() &lt;==&gt; abs(x)" ilk="function" name="__abs__" signature="x.__abs__() &lt;==&gt; abs(x)" />
        <scope doc="x.__pos__() &lt;==&gt; +x" ilk="function" name="__pos__" signature="x.__pos__() &lt;==&gt; +x" />
        <scope doc="x[y:z] &lt;==&gt; x[y.__index__():z.__index__()]" ilk="function" name="__index__" />
        <scope doc="x.__rfloordiv__(y) &lt;==&gt; y//x" ilk="function" name="__rfloordiv__" signature="x.__rfloordiv__(y) &lt;==&gt; y//x" />
        <scope doc="Number of bits necessary to represent self in binary." ilk="function" name="bit_length" returns="int" signature="int.bit_length() -&gt; int" />
        <scope doc="Flooring an Integral returns itself." ilk="function" name="__floor__" />
        <scope doc="x.__mul__(y) &lt;==&gt; x*y" ilk="function" name="__mul__" signature="x.__mul__(y) &lt;==&gt; x*y" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" ilk="function" name="__rdivmod__" signature="x.__rdivmod__(y) &lt;==&gt; divmod(y, x)" />
        <scope doc="x.__invert__() &lt;==&gt; ~x" ilk="function" name="__invert__" signature="x.__invert__() &lt;==&gt; ~x" />
        <scope ilk="function" name="__format__" />
        <scope doc="x.__divmod__(y) &lt;==&gt; divmod(x, y)" ilk="function" name="__divmod__" signature="x.__divmod__(y) &lt;==&gt; divmod(x, y)" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__bool__() &lt;==&gt; x != 0" ilk="function" name="__bool__" signature="x.__bool__() &lt;==&gt; x != 0" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__rxor__(y) &lt;==&gt; y^x" ilk="function" name="__rxor__" signature="x.__rxor__(y) &lt;==&gt; y^x" />
        <scope doc="Returns size in memory, in bytes" ilk="function" name="__sizeof__" />
        <scope doc="Rounding an Integral returns itself." ilk="function" name="__round__" />
        <scope doc="x.__mod__(y) &lt;==&gt; x%y" ilk="function" name="__mod__" signature="x.__mod__(y) &lt;==&gt; x%y" />
        <scope doc="x.__neg__() &lt;==&gt; -x" ilk="function" name="__neg__" signature="x.__neg__() &lt;==&gt; -x" />
        <scope doc="Truncating an Integral returns itself." ilk="function" name="__trunc__" />
        <scope doc="x.__xor__(y) &lt;==&gt; x^y" ilk="function" name="__xor__" signature="x.__xor__(y) &lt;==&gt; x^y" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__floordiv__(y) &lt;==&gt; x//y" ilk="function" name="__floordiv__" signature="x.__floordiv__(y) &lt;==&gt; x//y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__sub__(y) &lt;==&gt; x-y" ilk="function" name="__sub__" signature="x.__sub__(y) &lt;==&gt; x-y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
        <scope doc="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" ilk="function" name="__pow__" signature="x.__pow__(y[, z]) &lt;==&gt; pow(x, y[, z])" />
      </scope>
      <scope doc="Return whether an object is an instance of a class or of a&#xA;subclass thereof." ilk="function" name="isinstance" returns="bool" signature="isinstance(object, class-or-type-or-tuple) -&gt; bool" />
      <scope doc="Return whether class C is a subclass (i.e., a derived class)&#xA;of class B." ilk="function" name="issubclass" returns="bool" signature="issubclass(C, B) -&gt; bool" />
      <scope doc="Get an iterator from an object." ilk="function" name="iter" signature="iter(iterable) -&gt; iterator&#xA;iter(callable, sentinel) -&gt; iterator" />
      <scope doc="Return the number of items of a sequence or mapping." ilk="function" name="len" returns="int" signature="len(object) -&gt; integer" />
      <variable citdl="_Printer" name="license" />
      <scope classrefs="object" doc="list() -&gt; new empty list&#xA;list(iterable) -&gt; new list initialized from iterable&apos;s items" ilk="class" name="list">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Raises IndexError if list is empty or index is out of range." ilk="function" name="pop" signature="L.pop([index]) -&gt; item -- remove and return item at index (default last)." />
        <scope doc="remove first occurrence of value." ilk="function" name="remove" signature="L.remove(value)" />
        <scope doc="x.__rmul__(n) &lt;==&gt; n*x" ilk="function" name="__rmul__" signature="x.__rmul__(n) &lt;==&gt; n*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="size of L in memory, in bytes" ilk="function" name="__sizeof__" signature="L.__sizeof__()" />
        <scope ilk="function" name="__init__" />
        <scope doc="L.count(value) -&gt; integer -- return number of occurrences of value" ilk="function" name="count" returns="int" signature="L.count(value) -&gt; integer -- return number of occurrences of value" />
        <scope doc="Raises ValueError if the value is not present." ilk="function" name="index" returns="int" signature="L.index(value, [start, [stop]]) -&gt; integer -- return first index of value." />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope doc="append object to end" ilk="function" name="append" signature="L.append(object)" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__mul__(n) &lt;==&gt; x*n" ilk="function" name="__mul__" signature="x.__mul__(n) &lt;==&gt; x*n" />
        <scope doc="stable sort *IN PLACE*" ilk="function" name="sort" signature="L.sort(key=None, reverse=False)" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="insert object before index" ilk="function" name="insert" signature="L.insert(index, object)" />
        <scope doc="x.__setitem__(i, y) &lt;==&gt; x[i]=y" ilk="function" name="__setitem__" signature="x.__setitem__(i, y) &lt;==&gt; x[i]=y" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="reverse *IN PLACE*" ilk="function" name="reverse" signature="L.reverse()" />
        <scope doc="extend list by appending elements from the iterable" ilk="function" name="extend" signature="L.extend(iterable)" />
        <scope doc="x.__delitem__(y) &lt;==&gt; del x[y]" ilk="function" name="__delitem__" signature="x.__delitem__(y) &lt;==&gt; del x[y]" />
        <scope doc="return a reverse iterator over the list" ilk="function" name="__reversed__" signature="L.__reversed__()" />
        <scope doc="x.__imul__(y) &lt;==&gt; x*=y" ilk="function" name="__imul__" signature="x.__imul__(y) &lt;==&gt; x*=y" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__iadd__(y) &lt;==&gt; x+=y" ilk="function" name="__iadd__" signature="x.__iadd__(y) &lt;==&gt; x+=y" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="Update and return a dictionary containing the current&#xA;scope&apos;s local variables." ilk="function" name="locals" returns="dict" signature="locals() -&gt; dictionary" />
      <scope classrefs="object" doc="map(func, *iterables) --&gt; map object&#xA;Make an iterator that computes the function using arguments from each of the iterables.  Stops when the shortest iterable is exhausted." ilk="class" name="map">
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
      </scope>
      <scope doc="With a single iterable argument, return its largest item." ilk="function" name="max" signature="max(iterable[, key=func]) -&gt; value&#xA;max(a, b, c, ...[, key=func]) -&gt; value" />
      <scope classrefs="object" doc="memoryview(object)&#xA;Create a new memoryview object which references the given object." ilk="class" name="memoryview">
        <scope ilk="function" name="tolist" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope ilk="function" name="__enter__" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope ilk="function" name="__exit__" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="x.__setitem__(i, y) &lt;==&gt; x[i]=y" ilk="function" name="__setitem__" signature="x.__setitem__(i, y) &lt;==&gt; x[i]=y" />
        <scope ilk="function" name="tobytes" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__delitem__(y) &lt;==&gt; del x[y]" ilk="function" name="__delitem__" signature="x.__delitem__(y) &lt;==&gt; del x[y]" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope ilk="function" name="release" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="With a single iterable argument, return its smallest item." ilk="function" name="min" signature="min(iterable[, key=func]) -&gt; value&#xA;min(a, b, c, ...[, key=func]) -&gt; value" />
      <scope doc="Return the next item from the iterator." ilk="function" name="next" signature="next(iterator[, default])" />
      <scope doc="The most base type&#xA;" ilk="class" name="object">
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="helper for pickle" ilk="function" name="__reduce_ex__" />
        <scope doc="helper for pickle" ilk="function" name="__reduce__" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="default object formatter" ilk="function" name="__format__" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope ilk="function" name="__init__" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="size of object in memory, in bytes" ilk="function" name="__sizeof__" returns="int" signature="__sizeof__() -&gt; int" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="Return the octal representation of an integer." ilk="function" name="oct" returns="str" signature="oct(number) -&gt; string" />
      <scope doc="open(file, mode=&apos;r&apos;, buffering=-1, encoding=None,&#xA;errors=None, newline=None, closefd=True) -&gt; file object" ilk="function" name="open" />
      <scope doc="Return the integer ordinal of a one-character string." ilk="function" name="ord" returns="int" signature="ord(c) -&gt; integer" />
      <scope doc="With two arguments, equivalent to x**y." ilk="function" name="pow" returns="int" signature="pow(x, y[, z]) -&gt; number" />
      <scope doc="Prints the values to a stream, or to sys.stdout by default." ilk="function" name="print" signature="print(value, ..., sep=&apos; &apos;, end=&apos;\n&apos;, file=sys.stdout)" />
      <scope classrefs="object" doc="property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute&#xA;fget is a function to be used for getting an attribute value, and likewise fset is a function for setting, and fdel a function for del&apos;ing, an attribute.  Typical use is to define a managed attribute x: class C(object): def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, &quot;I&apos;m the &apos;x&apos; property.&quot;)  Decorators make defining new properties or modifying existing ones easy:" ilk="class" name="property">
        <scope doc="Descriptor to change the setter on a property." ilk="function" name="setter" />
        <scope doc="descr.__set__(obj, value)" ilk="function" name="__set__" signature="descr.__set__(obj, value)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Descriptor to change the getter on a property." ilk="function" name="getter" />
        <scope doc="Descriptor to change the deleter on a property." ilk="function" name="deleter" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
        <scope ilk="function" name="__init__" />
        <scope doc="descr.__delete__(obj)" ilk="function" name="__delete__" signature="descr.__delete__(obj)" />
      </scope>
      <variable citdl="Quitter" name="quit" />
      <scope classrefs="object" doc="range([start,] stop[, step]) -&gt; range object&#xA;Returns a virtual sequence of numbers from start to stop by step." ilk="class" name="range">
        <scope doc="rangeobject.count(value) -&gt; integer -- return number of occurrences of value" ilk="function" name="count" returns="int" signature="rangeobject.count(value) -&gt; integer -- return number of occurrences of value" />
        <scope doc="Raises ValueError if the value is not present." ilk="function" name="index" returns="int" signature="rangeobject.index(value, [start, [stop]]) -&gt; integer -- return index of value." />
        <scope doc="Returns a reverse iterator." ilk="function" name="__reversed__" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope ilk="function" name="__reduce__" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
      </scope>
      <scope doc="Return the canonical string representation of the object." ilk="function" name="repr" returns="str" signature="repr(object) -&gt; string" />
      <scope classrefs="object" doc="reversed(sequence) -&gt; reverse iterator over values of the sequence&#xA;Return a reverse iterator" ilk="class" name="reversed">
        <scope doc="Private method returning an estimate of len(list(it))." ilk="function" name="__length_hint__" />
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
      </scope>
      <scope doc="Round a number to a given precision in decimal digits&#xA;(default 0 digits)." ilk="function" name="round" returns="int" signature="round(number[, ndigits]) -&gt; number" />
      <scope classrefs="object" doc="set() -&gt; new empty set object&#xA;set(iterable) -&gt; new set object  Build an unordered collection of unique elements." ilk="class" name="set">
        <scope doc="x.__ror__(y) &lt;==&gt; y|x" ilk="function" name="__ror__" signature="x.__ror__(y) &lt;==&gt; y|x" />
        <scope doc="Remove all elements of another set from this set." ilk="function" name="difference_update" />
        <scope doc="x.__isub__(y) &lt;==&gt; x-y" ilk="function" name="__isub__" signature="x.__isub__(y) &lt;==&gt; x-y" />
        <scope doc="Return the symmetric difference of two sets as a new set." ilk="function" name="symmetric_difference" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Remove and return an arbitrary set element." ilk="function" name="pop" />
        <scope doc="Report whether this set contains another set." ilk="function" name="issuperset" />
        <scope doc="Report whether another set contains this set." ilk="function" name="issubset" />
        <scope doc="x.__rsub__(y) &lt;==&gt; y-x" ilk="function" name="__rsub__" signature="x.__rsub__(y) &lt;==&gt; y-x" />
        <scope doc="Remove an element from a set; it must be a member." ilk="function" name="remove" />
        <scope doc="x.__and__(y) &lt;==&gt; x&amp;y" ilk="function" name="__and__" signature="x.__and__(y) &lt;==&gt; x&amp;y" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="S.__sizeof__() -&gt; size of S in memory, in bytes" ilk="function" name="__sizeof__" signature="S.__sizeof__() -&gt; size of S in memory, in bytes" />
        <scope ilk="function" name="__init__" />
        <scope doc="x.__rand__(y) &lt;==&gt; y&amp;x" ilk="function" name="__rand__" signature="x.__rand__(y) &lt;==&gt; y&amp;x" />
        <scope doc="Return the intersection of two sets as a new set." ilk="function" name="intersection" />
        <scope doc="Return the difference of two or more sets as a new set." ilk="function" name="difference" />
        <scope doc="x.__iand__(y) &lt;==&gt; x&amp;y" ilk="function" name="__iand__" signature="x.__iand__(y) &lt;==&gt; x&amp;y" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x." ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x." />
        <scope doc="Return the union of sets as a new set." ilk="function" name="union" />
        <scope doc="Remove an element from a set if it is a member." ilk="function" name="discard" />
        <scope doc="Add an element to a set." ilk="function" name="add" />
        <scope doc="x.__ixor__(y) &lt;==&gt; x^y" ilk="function" name="__ixor__" signature="x.__ixor__(y) &lt;==&gt; x^y" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="Update a set with the symmetric difference of itself and&#xA;another." ilk="function" name="symmetric_difference_update" />
        <scope doc="Return state information for pickling." ilk="function" name="__reduce__" />
        <scope doc="Update a set with the union of itself and others." ilk="function" name="update" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__or__(y) &lt;==&gt; x|y" ilk="function" name="__or__" signature="x.__or__(y) &lt;==&gt; x|y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="Return a shallow copy of a set." ilk="function" name="copy" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__rxor__(y) &lt;==&gt; y^x" ilk="function" name="__rxor__" signature="x.__rxor__(y) &lt;==&gt; y^x" />
        <scope doc="Return True if two sets have a null intersection." ilk="function" name="isdisjoint" />
        <scope doc="Remove all elements from this set." ilk="function" name="clear" />
        <scope doc="Update a set with the intersection of itself and another." ilk="function" name="intersection_update" />
        <scope doc="x.__xor__(y) &lt;==&gt; x^y" ilk="function" name="__xor__" signature="x.__xor__(y) &lt;==&gt; x^y" />
        <scope doc="x.__ior__(y) &lt;==&gt; x|y" ilk="function" name="__ior__" signature="x.__ior__(y) &lt;==&gt; x|y" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__sub__(y) &lt;==&gt; x-y" ilk="function" name="__sub__" signature="x.__sub__(y) &lt;==&gt; x-y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="Set a named attribute on an object; setattr(x, &apos;y&apos;, v) is&#xA;equivalent to ``x.y = v&apos;&apos;." ilk="function" name="setattr" signature="setattr(object, name, value)" />
      <scope classrefs="object" doc="slice([start,] stop[, step])&#xA;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2])." ilk="class" name="slice">
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="Return state information for pickling." ilk="function" name="__reduce__" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Assuming a sequence of length len, calculate the start and&#xA;stop indices, and the stride length of the extended slice&#xA;described by S." ilk="function" name="indices" signature="S.indices(len) -&gt; (start, stop, stride)" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope doc="sorted(iterable, key=None, reverse=False) --&gt; new sorted list" ilk="function" name="sorted" signature="sorted(iterable, key=None, reverse=False) --&gt; new sorted list" />
      <scope classrefs="object" doc="staticmethod(function) -&gt; method&#xA;Convert a function to be a static method.  A static method does not receive an implicit first argument. To declare a static method, use this idiom:  class C: def f(arg1, arg2, ...): ... f = staticmethod(f)  It can be called either on the class (e.g. C.f()) or on an instance" ilk="class" name="staticmethod">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope ilk="function" name="__init__" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope classrefs="object" doc="str(string[, encoding[, errors]]) -&gt; str&#xA;Create a new string object from the given encoded string. encoding defaults to the current default string encoding. errors can be &apos;strict&apos;, &apos;replace&apos; or &apos;ignore&apos; and defaults to &apos;strict&apos;." ilk="class" name="str">
        <scope doc="Return a copy of S converted to uppercase." ilk="function" name="upper" returns="str" signature="S.upper() -&gt; str" />
        <scope doc="Search for the separator sep in S, and return the part&#xA;before it, the separator itself, and the part after it." ilk="function" name="partition" signature="S.partition(sep) -&gt; (head, sep, tail)" />
        <scope doc="Return True if S starts with the specified prefix, False&#xA;otherwise." ilk="function" name="startswith" returns="bool" signature="S.startswith(prefix[, start[, end]]) -&gt; bool" />
        <scope doc="Return a copy of the string S with leading whitespace&#xA;removed." ilk="function" name="lstrip" returns="str" signature="S.lstrip([chars]) -&gt; str" />
        <scope doc="Return a capitalized version of S, i.e." ilk="function" name="capitalize" returns="str" signature="S.capitalize() -&gt; str" />
        <scope doc="x.__str__() &lt;==&gt; str(x)" ilk="function" name="__str__" signature="x.__str__() &lt;==&gt; str(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="Search for the separator sep in S, starting at the end of S,&#xA;and return the part before it, the separator itself, and the&#xA;part after it." ilk="function" name="rpartition" signature="S.rpartition(sep) -&gt; (head, sep, tail)" />
        <scope doc="Return a copy of S with all occurrences of substring old&#xA;replaced by new." ilk="function" name="replace" returns="str" signature="S.replace(old, new[, count]) -&gt; str" />
        <scope doc="Return True if all characters in S are digits and there is&#xA;at least one character in S, False otherwise." ilk="function" name="isdigit" returns="bool" signature="S.isdigit() -&gt; bool" />
        <scope doc="Return True if S ends with the specified suffix, False&#xA;otherwise." ilk="function" name="endswith" returns="bool" signature="S.endswith(suffix[, start[, end]]) -&gt; bool" />
        <scope doc="Return a list of the lines in S, breaking at line&#xA;boundaries." ilk="function" name="splitlines" returns="list" signature="S.splitlines([keepends]) -&gt; list of strings" />
        <scope doc="Return the highest index in S where substring sub is found,&#xA;such that sub is contained within S[start:end]." ilk="function" name="rfind" returns="int" signature="S.rfind(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return a copy of the string S with leading and trailing&#xA;whitespace removed." ilk="function" name="strip" returns="str" signature="S.strip([chars]) -&gt; str" />
        <scope doc="x.__rmul__(n) &lt;==&gt; n*x" ilk="function" name="__rmul__" signature="x.__rmul__(n) &lt;==&gt; n*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope doc="Return S left-justified in a Unicode string of length width." ilk="function" name="ljust" returns="str" signature="S.ljust(width[, fillchar]) -&gt; str" />
        <scope doc="Return True if there are only decimal characters in S, False&#xA;otherwise." ilk="function" name="isdecimal" returns="bool" signature="S.isdecimal() -&gt; bool" />
        <scope doc="x.__rmod__(y) &lt;==&gt; y%x" ilk="function" name="__rmod__" signature="x.__rmod__(y) &lt;==&gt; y%x" />
        <scope doc="Like S.find() but raise ValueError when the substring is not&#xA;found." ilk="function" name="index" returns="int" signature="S.index(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return True if all characters in S are considered printable&#xA;in repr() or S is empty, False otherwise." ilk="function" name="isprintable" returns="bool" signature="S.isprintable() -&gt; bool" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="Return a formatted version of S, using substitutions from&#xA;mapping." ilk="function" name="format_map" returns="str" signature="S.format_map(mapping) -&gt; str" />
        <scope doc="Return True if all characters in S are alphanumeric and&#xA;there is at least one character in S, False otherwise." ilk="function" name="isalnum" returns="bool" signature="S.isalnum() -&gt; bool" />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope doc="Like S.rfind() but raise ValueError when the substring is&#xA;not found." ilk="function" name="rindex" returns="int" signature="S.rindex(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return a list of the words in S, using sep as the delimiter&#xA;string, starting at the end of the string and working to the&#xA;front." ilk="function" name="rsplit" returns="list" signature="S.rsplit([sep[, maxsplit]]) -&gt; list of strings" />
        <scope doc="Return a formatted version of S, using substitutions from&#xA;args and kwargs." ilk="function" name="format" returns="str" signature="S.format(*args, **kwargs) -&gt; str" />
        <scope doc="Return the lowest index in S where substring sub is found,&#xA;such that sub is contained within S[start:end]." ilk="function" name="find" returns="int" signature="S.find(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return True if all characters in S are alphabetic and there&#xA;is at least one character in S, False otherwise." ilk="function" name="isalpha" returns="bool" signature="S.isalpha() -&gt; bool" />
        <scope doc="Return a list of the words in S, using sep as the delimiter&#xA;string." ilk="function" name="split" returns="list" signature="S.split([sep[, maxsplit]]) -&gt; list of strings" />
        <scope doc="Return a copy of the string S with trailing whitespace&#xA;removed." ilk="function" name="rstrip" returns="str" signature="S.rstrip([chars]) -&gt; str" />
        <scope doc="Encode S using the codec registered for encoding." ilk="function" name="encode" signature="S.encode(encoding=&apos;utf-8&apos;, errors=&apos;strict&apos;) -&gt; bytes" />
        <scope doc="Return a copy of the string S, where all characters have&#xA;been mapped through the given translation table, which must&#xA;be a mapping of Unicode ordinals to Unicode ordinals,&#xA;strings, or None." ilk="function" name="translate" returns="str" signature="S.translate(table) -&gt; str" />
        <scope doc="Return True if S is a titlecased string and there is at&#xA;least one character in S, i.e." ilk="function" name="istitle" returns="bool" signature="S.istitle() -&gt; bool" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__mul__(n) &lt;==&gt; x*n" ilk="function" name="__mul__" signature="x.__mul__(n) &lt;==&gt; x*n" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="Return S right-justified in a string of length width." ilk="function" name="rjust" returns="str" signature="S.rjust(width[, fillchar]) -&gt; str" />
        <scope doc="Return a copy of S with uppercase characters converted to&#xA;lowercase and vice versa." ilk="function" name="swapcase" returns="str" signature="S.swapcase() -&gt; str" />
        <scope doc="Return a formatted version of S as described by format_spec." ilk="function" name="__format__" returns="str" signature="S.__format__(format_spec) -&gt; str" />
        <scope doc="Return True if all cased characters in S are lowercase and&#xA;there is at least one cased character in S, False otherwise." ilk="function" name="islower" returns="bool" signature="S.islower() -&gt; bool" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="Pad a numeric string S with zeros on the left, to fill a&#xA;field of the specified width." ilk="function" name="zfill" returns="str" signature="S.zfill(width) -&gt; str" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="S.__sizeof__() -&gt; size of S in memory, in bytes" ilk="function" name="__sizeof__" signature="S.__sizeof__() -&gt; size of S in memory, in bytes" />
        <scope doc="Return the number of non-overlapping occurrences of&#xA;substring sub in string S[start:end]." ilk="function" name="count" returns="int" signature="S.count(sub[, start[, end]]) -&gt; int" />
        <scope doc="Return a copy of the string S converted to lowercase." ilk="function" name="lower" returns="str" signature="S.lower() -&gt; str" />
        <scope doc="Return True if there are only numeric characters in S, False&#xA;otherwise." ilk="function" name="isnumeric" returns="bool" signature="S.isnumeric() -&gt; bool" />
        <scope doc="Return a string which is the concatenation of the strings in&#xA;the iterable." ilk="function" name="join" returns="str" signature="S.join(iterable) -&gt; str" />
        <scope doc="Return S centered in a string of length width." ilk="function" name="center" returns="str" signature="S.center(width[, fillchar]) -&gt; str" />
        <scope doc="x.__mod__(y) &lt;==&gt; x%y" ilk="function" name="__mod__" signature="x.__mod__(y) &lt;==&gt; x%y" />
        <scope doc="Return a titlecased version of S, i.e." ilk="function" name="title" returns="str" signature="S.title() -&gt; str" />
        <scope doc="Return a copy of S where all tab characters are expanded&#xA;using spaces." ilk="function" name="expandtabs" returns="str" signature="S.expandtabs([tabsize]) -&gt; str" />
        <scope doc="Return True if all characters in S are whitespace and there&#xA;is at least one character in S, False otherwise." ilk="function" name="isspace" returns="bool" signature="S.isspace() -&gt; bool" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="Return True if all cased characters in S are uppercase and&#xA;there is at least one cased character in S, False otherwise." ilk="function" name="isupper" returns="bool" signature="S.isupper() -&gt; bool" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
        <scope doc="Return True if S is a valid identifier according to the&#xA;language definition." ilk="function" name="isidentifier" returns="bool" signature="S.isidentifier() -&gt; bool" />
      </scope>
      <scope doc="Returns the sum of an iterable of numbers (NOT strings) plus&#xA;the value of parameter &apos;start&apos; (which defaults to 0)." ilk="function" name="sum" signature="sum(iterable[, start]) -&gt; value" />
      <scope classrefs="object" doc="super() -&gt; same as super(__class__, &lt;first argument&gt;)&#xA;super(type) -&gt; unbound super object super(type, obj) -&gt; bound super object; requires isinstance(obj, type) super(type, type2) -&gt; bound super object; requires issubclass(type2, type) Typical use to call a cooperative superclass method: class C(B): def meth(self, arg): super().meth(arg) This works for class methods too: class C(B): @classmethod" ilk="class" name="super">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope ilk="function" name="__init__" />
        <scope doc="descr.__get__(obj[, type]) -&gt; value" ilk="function" name="__get__" signature="descr.__get__(obj[, type]) -&gt; value" />
      </scope>
      <scope classrefs="object" doc="tuple() -&gt; empty tuple&#xA;tuple(iterable) -&gt; tuple initialized from iterable&apos;s items  If the argument is a tuple, the return value is the same object." ilk="class" name="tuple">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope doc="x.__rmul__(n) &lt;==&gt; n*x" ilk="function" name="__rmul__" signature="x.__rmul__(n) &lt;==&gt; n*x" />
        <scope doc="x.__lt__(y) &lt;==&gt; x&lt;y" ilk="function" name="__lt__" signature="x.__lt__(y) &lt;==&gt; x&lt;y" />
        <scope ilk="function" name="__getnewargs__" />
        <scope doc="size of T in memory, in bytes" ilk="function" name="__sizeof__" signature="T.__sizeof__()" />
        <scope doc="Raises ValueError if the value is not present." ilk="function" name="index" returns="int" signature="T.index(value, [start, [stop]]) -&gt; integer -- return first index of value." />
        <scope doc="x.__contains__(y) &lt;==&gt; y in x" ilk="function" name="__contains__" signature="x.__contains__(y) &lt;==&gt; y in x" />
        <scope doc="x.__len__() &lt;==&gt; len(x)" ilk="function" name="__len__" signature="x.__len__() &lt;==&gt; len(x)" />
        <scope doc="x.__mul__(n) &lt;==&gt; x*n" ilk="function" name="__mul__" signature="x.__mul__(n) &lt;==&gt; x*n" />
        <scope doc="x.__ne__(y) &lt;==&gt; x!=y" ilk="function" name="__ne__" signature="x.__ne__(y) &lt;==&gt; x!=y" />
        <scope doc="x.__getitem__(y) &lt;==&gt; x[y]" ilk="function" name="__getitem__" signature="x.__getitem__(y) &lt;==&gt; x[y]" />
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__add__(y) &lt;==&gt; x+y" ilk="function" name="__add__" signature="x.__add__(y) &lt;==&gt; x+y" />
        <scope doc="x.__gt__(y) &lt;==&gt; x&gt;y" ilk="function" name="__gt__" signature="x.__gt__(y) &lt;==&gt; x&gt;y" />
        <scope doc="x.__eq__(y) &lt;==&gt; x==y" ilk="function" name="__eq__" signature="x.__eq__(y) &lt;==&gt; x==y" />
        <scope doc="T.count(value) -&gt; integer -- return number of occurrences of value" ilk="function" name="count" returns="int" signature="T.count(value) -&gt; integer -- return number of occurrences of value" />
        <scope doc="x.__le__(y) &lt;==&gt; x&lt;=y" ilk="function" name="__le__" signature="x.__le__(y) &lt;==&gt; x&lt;=y" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
        <scope doc="x.__hash__() &lt;==&gt; hash(x)" ilk="function" name="__hash__" signature="x.__hash__() &lt;==&gt; hash(x)" />
        <scope doc="x.__ge__(y) &lt;==&gt; x&gt;=y" ilk="function" name="__ge__" signature="x.__ge__(y) &lt;==&gt; x&gt;=y" />
      </scope>
      <scope classrefs="object" doc="type(object) -&gt; the object&apos;s type&#xA;type(name, bases, dict) -&gt; a new type" ilk="class" name="type">
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
        <scope ilk="function" name="__init__" />
        <scope doc="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" ilk="function" name="__setattr__" signature="x.__setattr__(&apos;name&apos;, value) &lt;==&gt; x.name = value" />
        <scope doc="__subclasses__() -&gt; list of immediate subclasses" ilk="function" name="__subclasses__" returns="list" signature="__subclasses__() -&gt; list of immediate subclasses" />
        <scope doc="x.__call__(...) &lt;==&gt; x(...)" ilk="function" name="__call__" signature="x.__call__(...) &lt;==&gt; x(...)" />
        <scope doc="check if an object is an instance" ilk="function" name="__instancecheck__" returns="bool" signature="__instancecheck__() -&gt; bool" />
        <scope doc="check if a class is a subclass" ilk="function" name="__subclasscheck__" returns="bool" signature="__subclasscheck__() -&gt; bool" />
        <scope doc="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" ilk="function" name="__delattr__" signature="x.__delattr__(&apos;name&apos;) &lt;==&gt; del x.name" />
        <scope doc="return a type&apos;s method resolution order" ilk="function" name="mro" returns="list" signature="mro() -&gt; list" />
        <scope doc="x.__repr__() &lt;==&gt; repr(x)" ilk="function" name="__repr__" signature="x.__repr__() &lt;==&gt; repr(x)" />
      </scope>
      <scope doc="Without arguments, equivalent to locals()." ilk="function" name="vars" returns="dict" signature="vars([object]) -&gt; dictionary" />
      <scope classrefs="object" doc="zip(iter1 [,iter2 [...]]) --&gt; zip object&#xA;Return a zip object whose .__next__() method returns a tuple where the i-th element comes from the i-th iterable argument.  The .__next__() method continues until the shortest iterable in the argument sequence is exhausted and then it raises StopIteration." ilk="class" name="zip">
        <scope doc="x.__iter__() &lt;==&gt; iter(x)" ilk="function" name="__iter__" signature="x.__iter__() &lt;==&gt; iter(x)" />
        <scope doc="x.__next__() &lt;==&gt; next(x)" ilk="function" name="__next__" signature="x.__next__() &lt;==&gt; next(x)" />
        <scope doc="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" ilk="function" name="__getattribute__" signature="x.__getattribute__(&apos;name&apos;) &lt;==&gt; x.name" />
      </scope>
    </scope>
    